{
  "id": "oscillation",
  "slug": "oscillation",
  "title": "3. Oscillation",
  "type": "chapter",
  "content": "\nChapter 3. Oscillation\n\n  \n    Trigonometry is a sine of the times.\n    \n      —Anonymous\n    \n  \n\n\n  \n    \n    \n  \n  Gala by Bridget Riley, 1974; acrylic on canvas, 159.7 × 159.7 cm\n  Bridget Riley, a celebrated British artist, was a driving force behind the Op Art movement of the 1960s. Her work features geometric patterns that challenge the viewer’s perceptions and evoke feelings of movement or vibration. Her 1974 piece Gala showcases a series of curvilinear forms that ripple across the canvas, evoking the natural rhythm of the sine wave.\n\nIn Chapters 1 and 2, I carefully worked out an object-oriented structure to animate a shape in a p5.js canvas, using a vector to represent position, velocity, and acceleration driven by forces in the environment. I could move straight from here into topics such as particle systems, steering forces, group behaviors, and more. However, doing so would mean skipping a fundamental aspect of motion in the natural world: oscillation, or the back-and-forth movement of an object around a central point or position.\nTo model oscillation, you need to understand a little bit about trigonometry, the mathematics of triangles. Learning some trig will give you new tools to generate patterns and create new motion behaviors in a p5.js sketch. You’ll learn to harness angular velocity and acceleration to spin objects as they move. You’ll be able to use the sine and cosine functions to model nice ease-in, ease-out wave patterns. You’ll also learn to calculate the more complex forces at play in situations that involve angles, such as a pendulum swinging or a box sliding down an incline.\nI’ll start with the basics of working with angles in p5.js, then cover several aspects of trigonometry. In the end, I’ll connect trigonometry with what you learned about forces in Chapter 2. This chapter’s content will pave the way for more sophisticated examples that require trig later in this book.\nAngles\n\nBefore going any further, I need to make sure you understand how the concept of an angle fits into creative coding in p5.js. If you have experience with p5.js, you’ve undoubtedly encountered this issue while using the rotate() function to rotate and spin objects. You’re most likely to be familiar with the concept of an angle as measured in degrees (see Figure 3.1).\n\n  \n  Figure 3.1: Angles measured in degrees\n\n\n  \n    \n    Figure 3.2: A square rotated by 45 degrees\n  \n\nA full rotation goes from 0 to 360 degrees, and 90 degrees (a right angle) is one-fourth of 360, shown in Figure 3.1 as two perpendicular lines.\nAngles are commonly used in computer graphics to specify a rotation for a shape. For example, the square in Figure 3.2 is rotated 45 degrees around its center.\n\n  \n    \n    Figure 3.3: The arc length for an angle of 1 radian is equal to the radius.\n  \n\nThe catch is that, by default, p5.js measures angles not in degrees but in radians. This alternative unit of measurement is defined by the ratio of the length of the arc of a circle (a segment of the circle’s circumference) to the radius of that circle. One radian is the angle at which that ratio equals 1 (see Figure 3.3). A full circle (360 degrees) is equivalent to 2\\pi radians, 180 degrees is equivalent to \\pi radians, and 90 degrees is equivalent to \\pi/2 radians.\nThe formula to convert from degrees to radians is as follows:\n\\text{radians} = {2\\pi \\times \\text{degrees} \\over 360}\nThankfully, if you prefer to think of angles in degrees, you can call angleMode(DEGREES), or you can use the convenience function radians() to convert values from degrees to radians. The constants PI, TWO_PI, and HALF_PI are also available (equivalent to 180, 360, and 90 degrees, respectively). For example, here are two ways in p5.js to rotate a shape by 60 degrees:\nlet angle = 60;\nrotate(radians(angle));\n\nangleMode(DEGREES);\nrotate(angle);\n\n  What Is Pi?\n  The mathematical constant pi (or the Greek letter \\pi) is a real number defined as the ratio of a circle’s circumference (the distance around the outside of the circle) to its diameter (a straight line that passes through the circle’s center). It’s equal to approximately 3.14159 and can be accessed in p5.js with the built-in PI variable.\n\nWhile degrees can be useful, for the purposes of this book, I’ll be working with radians because they’re the standard unit of measurement across many programming languages and graphics environments. If they’re new to you, this is a good opportunity to practice! Additionally, if you aren’t familiar with the way rotation is implemented in p5.js, I recommend watching my Coding Train video series on transformations in p5.js.\n\n  Exercise 3.1\n  Rotate a baton-like object around its center by using translate() and rotate().\n  \n    \n    \n  \n\nAngular Motion\n\nAnother term for rotation is angular motion—that is, motion about an angle. Just as linear motion can be described in terms of velocity—the rate at which an object’s position changes over time—angular motion can be described in terms of angular velocity—the rate at which an object’s angle changes over time. By extension, angular acceleration describes changes in an object’s angular velocity.\nLuckily, you already have all the math you need to understand angular motion. Remember the stuff I dedicated almost all of Chapters 1 and 2 to explaining?\n\n  \\overrightarrow{\\text{velocity}} = \\overrightarrow{\\text{velocity}} + \\overrightarrow{\\text{acceleration}}\n  \\overrightarrow{\\text{position}} = \\overrightarrow{\\text{position}} + \\overrightarrow{\\text{velocity}}\n\nYou can apply exactly the same logic to a rotating object:\n\\text{angular velocity} = \\text{angular velocity} + \\text{angular~acceleration}\n\\text{angle} = \\text{angle} + \\text{angular velocity}\nIn fact, these angular motion formulas are simpler than their linear motion equivalents since the angle here is a scalar quantity (a single number), not a vector! This is because in 2D space, there’s one axis of rotation; in 3D space, the angle would become a vector. (Note that in most contexts, these formulas would include a multiplication by the change in time, referred to as delta time. I’m assuming a delta time of 1 that corresponds to one frame of animation in p5.js.)\nUsing the answer from Exercise 3.1, let’s say you wanted to rotate a baton in p5.js by a certain angle. Originally, the code might have read as follows:\ntranslate(width / 2, height / 2);\nrotate(angle);\nline(-60, 0, 60, 0);\ncircle(60, 0, 16);\ncircle(-60, 0, 16);\n\nangle = angle + 0.1;\nAdding in the principles of angular motion, I can instead write the following example (the solution to Exercise 3.1).\n\n  Example 3.1: Angular Motion Using rotate()\n  \n    \n    \n  \n\n\n  // Position\nlet angle = 0;\n// Velocity\nlet angleVelocity = 0;\n// Acceleration\nlet angleAcceleration = 0.0001;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  translate(width / 2, height / 2);\n  //{!1} Rotate according to that angle.\n  rotate(angle);\n  stroke(0);\n  fill(127);\n  line(-60, 0, 60, 0);\n  circle(60, 0, 16);\n  circle(-60, 0, 16);\n  // Angular equivalent of <code>velocity.add(acceleration)</code>\n  angleVelocity += angleAcceleration;\n  // Angular equivalent of <code>position.add(velocity)</code>\n  angle += angleVelocity;\n}\n\n\n\nInstead of incrementing angle by a fixed amount to steadily rotate the baton, for every frame I add angleAcceleration to angleVelocity, then add angleVelocity to angle. As a result, the baton starts with no rotation and then spins faster and faster as the angular velocity accelerates.\n\n  Exercise 3.2\n  Add an interaction to the spinning baton. How can you control the acceleration with the mouse? Can you introduce the idea of drag, decreasing the angular velocity over time so the baton eventually comes to rest?\n\nThe logical next step is to incorporate this idea of angular motion into the Mover class. First, I need to add some variables to the class’s constructor:\n\n  class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    this.mass = 1.0;\n    // Variables for angular motion\n    this.angle = 0;\n    this.angleVelocity = 0;\n    this.angleAcceleration = 0;\n  }\n\nThen, in update(), the mover’s position and angle are updated according to the algorithm I just demonstrated:\n\n    update() {\n    // Regular old-fashioned motion\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!2} Newfangled angular motion\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }\n\nOf course, for any of this to matter, I also need to rotate the object when drawing it in the show() method. (I’ll add a line from the center to the edge of the circle so that rotation is visible. You could also draw the object as a shape other than a circle.)\n\n    show() {\n    stroke(0);\n    fill(175, 200);\n    // Use <code>push()</code> to save the current state so the rotation of this shape doesn’t affect the rest of the world.\n    push();\n    // Set the origin at the shape’s position.\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate by the angle.\n    rotate(this.angle);\n    circle(0, 0, this.radius * 2);\n    line(0, 0, this.radius, 0);\n    // Use <code>pop()</code> to restore the previous state after rotation is complete.\n    pop();\n  }\n\nAt this point, if you were to actually go ahead and create a Mover object, you wouldn’t see it\nbehave any differently. This is because the angular acceleration is initialized to zero (this.angleAcceleration = 0;). For the object to rotate, it needs a nonzero acceleration! Certainly, one option is to hardcode a number in the constructor:\n    this.angleAcceleration = 0.01;\nYou can produce a more interesting result, however, by dynamically assigning an angular acceleration in the update() method according to forces in the environment. This could be my cue to start researching the physics of angular acceleration based on the concepts of torque and moment of inertia, but at this stage, that level of simulation would be a bit of a rabbit hole. (I’ll cover modeling angular acceleration with a pendulum in more detail in “The Pendulum”, as well as look at how third-party physics libraries realistically model rotational motion in Chapter 6.)\nInstead, a quick-and-dirty solution that yields creative results will suffice. A reasonable approach is to calculate angular acceleration as a function of the object’s linear acceleration, its rate of change of velocity along a path vector, as opposed to its rotation. Here’s an example:\n    // Use the x-component of the object’s linear acceleration to calculate angular acceleration.\n    this.angleAcceleration = this.acceleration.x;\nYes, this is arbitrary, but it does do something. If the object is accelerating to the right, its angular rotation accelerates in a clockwise direction; acceleration to the left results in a counterclockwise rotation. Of course, it’s important to think about scale in this case. The value of the acceleration vector’s x component might be too large, causing the object to spin in a way that looks ridiculous or unrealistic. You might even notice a visual illusion called the wagon wheel effect: an object appears to be rotating more slowly or even in the opposite direction because of the large changes between each frame of animation.\nDividing the x component by a value, or perhaps constraining the angular velocity to a reasonable range, could really help. Here’s the entire update() function with these tweaks added.\n\n  Example 3.2: Forces with (Arbitrary) Angular Motion\n  \n    \n    \n  \n\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!1} Calculate angular acceleration according to acceleration’s x-component.\n    this.angleAcceleration = this.acceleration.x / 10.0;\n    this.angleVelocity += this.angleAcceleration;\n    //{!1} Use <code>constrain()</code> to ensure that angular velocity doesn’t spin out of control.\n    this.angleVelocity = constrain(this.angleVelocity, -0.1, 0.1);\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }\nNotice that I’ve used multiple strategies to keep the object from spinning out of control. First, I divide acceleration.x by 10 before assigning it to angleAcceleration. Then, for good measure, I also use constrain() to confine angleVelocity to the range (–0.1, 0.1).\n\n  Exercise 3.3\n  Step 1: Create a simulation of objects being shot out of a cannon. Each object should experience a sudden force when shot (just once) as well as gravity (always present).\n  \n  Step 2: Add rotation to the object to model its spin as it’s shot from the cannon. How realistic can you make it look?\n\nTrigonometry Functions\nI think I’m ready to reveal the secret of trigonometry. I’ve discussed angles, I’ve spun a baton. Now it’s time for . . . wait for it . . . sohcahtoa. Yes, sohcahtoa! This seemingly nonsensical word is actually the foundation for much of computer graphics work. A basic understanding of trigonometry is essential if you want to calculate angles, figure out distances between points, and work with circles, arcs, or lines. And sohcahtoa is a mnemonic device (albeit a somewhat absurd one) for remembering the meanings of the trigonometric functions sine, cosine, and tangent. It references the sides of a right triangle, as shown in Figure 3.4.\n\n  \n  Figure 3.4: A right triangle showing the sides as adjacent, opposite, and hypotenuse\n\nTake one of the non-right angles in the triangle. The adjacent side is the one touching that angle, the opposite side is the one not touching that angle, and the hypotenuse is the side opposite the right angle. Sohcahtoa tells you how to calculate the angle’s trigonometric functions in terms of the lengths of these sides:\n\n  soh: \\text{\\textbf{s}ine(angle)} = \\text{\\textbf{o}pposite}/\\text{\\textbf{h}ypotenuse}\n  cah: \\text{\\textbf{c}osine(angle)} = \\text{\\textbf{a}djacent} / \\text{\\textbf{h}ypotenuse}\n  toa: \\text{\\textbf{t}angent(angle)} = \\text{\\textbf{o}pposite} / \\text{\\textbf{a}djacent}\n\nTake a look at Figure 3.4 again. You don’t need to memorize it, but see if you feel comfortable with it. Try redrawing it yourself. Next, let’s look at it in a slightly different way (see Figure 3.5).\n\n  \n    \n    Figure 3.5: A vector \\vec{v} with components x, y, and angle\n  \n\nSee how a right triangle is created from the vector \\vec{v}? The vector arrow is the hypotenuse, and the components of the vector (x and y) are the sides of the triangle. The angle is an additional means for specifying the vector’s direction (or heading). Viewed in this way, the trigonometric functions establish a relationship between the components of a vector and its direction + magnitude. As such, trigonometry will prove very useful throughout this book. To illustrate this, let’s look at an example that requires the tangent function.\nPointing in the Direction of Movement\n\nThink all the way back to Example 1.10, which featured a Mover object accelerating toward the mouse (Figure 3.6).\n\n  \n  Figure 3.6: A mover accelerating toward the mouse (from Example 1.10)\n\nYou might notice that almost all the shapes I’ve been drawing so far have been circles. This is convenient for several reasons, one of which is that using circles allows me to avoid the question of rotation. Rotate a circle and, well, it looks exactly the same. Nevertheless, there comes a time in all motion programmers’ lives when they want to move something around onscreen that isn’t shaped like a circle. Perhaps it’s an ant, or a car, or a spaceship. To look realistic, that object should point in its direction of movement.\nWhen I say “point in its direction of movement,” what I really mean is “rotate according to its velocity vector.” Velocity is a vector, with an x- and y-component, but to rotate in p5.js, you need one number, an angle. Let’s look at the trigonometry diagram once more, this time focused on an object’s velocity vector (Figure 3.7).\n\n  \n  Figure 3.7: The tangent of a velocity vector’s angle is y divided by x.\n\nThe vector’s x- and y-components are related to its angle through the tangent function. Using the toa in sohcahtoa, I can write the relationship as follows:\n\\text{tangent(angle)} = \\frac{\\text{velocity}_y}{\\text{velocity}_x}\nThe problem here is that while I know the x- and y-components of the velocity vector, I don’t know the angle of its direction. I have to solve for that angle. This is where another function known as the inverse tangent, or arctangent (arctan or atan, for short), comes in. (There are also inverse sine and inverse cosine functions, called arcsine and arccosine, respectively.)\nIf the tangent of value a equals value b, then the inverse tangent of b equals a. For example:\n\n  \n    \n      If\n      \\tan(a) = b\n    \n    \n      then\n      a = \\arctan(b)\n    \n  \n\nSee how one is the inverse of the other? This allows me to solve for the vector’s angle:\n\n  \n    \n      If\n      \\tan(\\text{angle}) = \\frac{\\text{velocity}_y}{\\text{velocity}_x}\n    \n    \n      then\n      \\text{angle} = \\arctan(\\frac{\\text{velocity}_y}{\\text{velocity}_x})\n    \n  \n\nNow that I have the formula, let’s see where it should go in the Mover class’s show() method to make the mover (now drawn as a rectangle) point in its direction of motion. Note that in p5.js, the function for inverse tangent is atan():\n  show() {\n    //{!1} Solve for the angle by using <code>atan()</code>.\n    let angle = atan(this.velocity.y / this.velocity.x);\n    stroke(0);\n    fill(175);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }\n\n  \n    \n    Figure 3.8: The vectors \\vec{v}_1 and \\vec{v}_2 with components (4, –3) and (–4, 3) point in opposite directions.\n  \n\nThis code is pretty darn close and almost works. There’s a big problem, though. Consider the two velocity vectors depicted in Figure 3.8.\nThough superficially similar, the two vectors point in quite different directions—opposite directions, in fact! In spite of this, look at what happens if I apply the inverse tangent formula to solve for the angle of each vector:\n\\vec{v}_1 ⇒ \\text{angle} = \\arctan(3/{-4}) = \\arctan(-0.75) = -0.643501 \\text{ radians} = -37 \\text{ degrees}\n\\vec{v}_2 ⇒ \\text{angle} = \\arctan(-3/4) = \\arctan(-0.75) = -0.643501 \\text{ radians} = -37 \\text{ degrees}\nI get the same angle! That can’t be right, though, since the vectors are pointing in opposite directions. It turns out this is a pretty common problem in computer graphics. I could use atan() along with conditional statements to account for positive/negative scenarios, but p5.js (along with most programming environments) has a helpful function called atan2() that resolves the issue for me.\n\n  Example 3.3: Pointing in the Direction of Motion\n  \n    \n    \n  \n\n\n    show() {\n    //{!1} Use <code>atan2()</code> to account for all possible directions.\n    let angle = atan2(this.velocity.y, this.velocity.x);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }\n\nTo simplify this even further, the p5.Vector class provides a method called heading(), which takes care of calling atan2() and returns the 2D direction angle, in radians, for any p5.Vector:\n    // The easiest way to do this!\n    let angle = this.velocity.heading();\nWith heading(), it turns out you don’t actually need to implement the trigonometry functions in your code, but understanding how they’re all working is still helpful.\n\n  Exercise 3.4\n  Create a simulation of a vehicle that you can drive around the screen by using the arrow keys: the left arrow accelerates the car to the left, and the right arrow accelerates to the right. The car should point in the direction in which it’s currently moving.\n\nPolar vs. Cartesian Coordinates\n\nAnytime you draw a shape in p5.js, you have to specify a pixel position, a set of x- and y-coordinates. These are known as Cartesian coordinates, named for René Descartes, the French mathematician who developed the ideas behind Cartesian space.\nAnother useful coordinate system, known as polar coordinates, describes a point in space as a distance from the origin (like the radius of a circle) and an angle of rotation around the origin (usually called \\theta, the Greek letter theta). Thinking in terms of vectors, a Cartesian coordinate describes a vector’s x- and y-components, whereas a polar coordinate describes a vector’s magnitude (length) and direction (angle).\nWhen working in p5.js, you may find it more convenient to think in polar coordinates, especially when creating sketches that involve rotational or circular movements. However, p5.js’s drawing functions understand only (x, y) Cartesian coordinates. Happily for you, trigonometry holds the key to converting back and forth between polar and Cartesian (see Figure 3.9). This allows you to design with whatever coordinate system you have in mind, while always drawing using Cartesian coordinates.\n\n  \n  Figure 3.9: The Greek letter \\theta (theta) is often used to denote an angle. Since a polar coordinate is conventionally referred to as (r, \\theta), I’ll use theta as a variable name when referring to an angle in p5.js.\n\nFor example, given a polar coordinate with a radius of 75 pixels and an angle (\\theta) of 45 degrees (or \\pi/4 radians), the Cartesian x and y can be computed as follows:\n\\cos(\\theta) = x/r \\Rightarrow x = r \\times \\cos(\\theta)\n\\sin(\\theta) = y / r \\Rightarrow y = r \\times \\sin(\\theta)\nThe functions for sine and cosine in p5.js are sin() and cos(), respectively. Each takes one argument, a number representing an angle in radians. These formulas can thus be coded as follows:\nlet r = 75;\nlet theta = PI / 4;\n// Convert from polar (<em>r</em>, <em>theta</em>) to Cartesian (<em>x</em>, <em>y</em>).\nlet x = r * cos(theta);\nlet y = r * sin(theta);\nThis type of conversion can be useful in certain applications. For instance, moving a shape along a circular path using Cartesian coordinates isn’t so easy. However, with polar coordinates, it’s simple: just increment the angle! Here’s how it’s done with global r and theta variables.\n\n  Example 3.4: Polar to Cartesian\n  \n    \n    \n  \n\nlet r;\nlet theta;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize all values.\n  r = height * 0.45;\n  theta = 0;\n}\n\nfunction draw() {\n  background(255);\n  // Translate the origin point to the center of the screen.\n  translate(width / 2, height / 2);\n  //{!2} Polar coordinates (<em>r</em>, <em>theta</em>) are converted to Cartesian (<em>x</em>, <em>y</em>) for use in the <code>circle()</code> function.\n  let x = r * cos(theta);\n  let y = r * sin(theta);\n  fill(127);\n  stroke(0);\n  line(0, 0, x, y);\n  circle(x, y, 48);\n  //{!1} Increase the angle over time.\n  theta += 0.02;\n}\n\n  Polar-to-Cartesian conversion is common enough that p5.js includes a handy function to take care of it for you. It’s included as a static method of the p5.Vector class called fromAngle(). It takes an angle in radians and creates a unit vector in Cartesian space that points in the direction specified by the angle. Here’s how that would look in Example 3.4:\n    // Create a unit vector pointing in the direction of an angle.\n  let position = p5.Vector.fromAngle(theta);\n  // To complete polar-to-Cartesian conversion, scale <code>position</code> by <code>r</code>.\n  position.mult(r);\n  // Draw the circle by using the x- and y-components of the vector.\n  circle(position.x, position.y, 48);\n\nAre you amazed yet? I’ve demonstrated some pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates). I could stop right here and be satisfied. But I’m not going to. This is only the beginning. As I’ll show you next, what sine and cosine can do for you goes beyond mathematical formulas and right triangles.\n\n  Exercise 3.5\n  Using Example 3.4 as a basis, draw a spiral path. Start in the center and move outward. Note that this can be done by changing only one line of code and adding one line of code!\n  \n    \n    \n  \n\n\n  Exercise 3.6\n  Simulate the spaceship in the game Asteroids. In case you aren’t familiar with Asteroids, here’s a brief description: A spaceship (represented as a triangle) floats in 2D space. The left arrow key turns the spaceship counterclockwise; the right arrow key turns it clockwise. The Z key applies a thrust force in the direction the spaceship is pointing. \n  \n    \n    \n  \n\nProperties of Oscillation\n\nTake a look at the graph of the sine function in Figure 3.10, where y = sin(x).\n\n  \n  Figure 3.10: A graph of y = sin(x)\n\nThe output of the sine function is a smooth curve alternating between –1 and 1, also known as a sine wave. This behavior, a periodic movement between two points, is the oscillation I mentioned at the start of the chapter. Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—all are examples of oscillating motion that can be modeled using the sine function.\nIn a p5.js sketch, you can simulate oscillation by assigning the output of the sine function to an object’s position. I’ll begin with a basic scenario: I want a circle to oscillate between the left side and the right side of a canvas (Figure 3.11).\n\n  \n  Figure 3.11: An oscillating circle\n\nThis pattern of oscillating back and forth around a central point is known as simple harmonic motion (or, to be fancier, the periodic sinusoidal oscillation of an object). The code to achieve it is remarkably simple, but before I get into it, I’d like to introduce some of the key terminology related to oscillation (and waves).\nWhen a moving object exhibits simple harmonic motion, its position (in this case, the x-position) can be expressed as a function of time, with the following two elements:\n\n  Amplitude: The distance from the center of motion to either extreme\n  Period: The duration (time) for one complete cycle of motion\n\nTo understand these terms, look again at the graph of the sine function in Figure 3.10. The curve never rises above 1 or below –1 along the y-axis, so the sine function has an amplitude of 1. Meanwhile, the wave pattern of the curve repeats every 2\\pi units along the x-axis, so the sine function’s period is 2\\pi. (By convention, the units here are radians, since the input value to the sine function is customarily an angle measured in radians.)\nSo much for the amplitude and period of an abstract sine function, but what are amplitude and period in the p5.js world of an oscillating circle? Well, amplitude can be measured rather easily in pixels. For example, if the canvas is 200 pixels wide, I might choose to oscillate around the center of the canvas, going between 100 pixels right of center and 100 pixels left of center. In other words, the amplitude is 100 pixels.\n// The amplitude is measured in pixels.\nlet amplitude = 100;\nThe period is the amount of time for one complete cycle of an oscillation. However, in a p5.js sketch, what does time really mean? In theory, I could say I want the circle to oscillate every three seconds, then come up with an elaborate algorithm for moving the object according to real-world time, using millis() to track the passage of milliseconds. For what I’m trying to accomplish here, however, real-world time isn’t necessary. The more useful measure of time in p5.js is the number of frames that have elapsed, available through the built-in frameCount variable. Do I want the oscillating motion to repeat every 30 frames? Every 50 frames? For now, how about a period of 120 frames:\n// The period is measured in frames (the unit of time for animation).\nlet period = 120;\nOnce I have the amplitude and period, it’s time to write a formula to calculate the circle’s x-position as a function of time (the current frame count):\n// <code>amplitude</code> and <code>period</code> are my own variables; <code>frameCount</code> is built into p5.js.\nlet x = amplitude * sin(TWO_PI * frameCount / period);\nThink about what’s going on here. First, whatever value the sin() function returns is multiplied by amplitude. As you saw in Figure 3.10, the output of the sine function oscillates between –1 and 1. Multiplying that value by my chosen amplitude—call it a—gives me the desired result: a value that oscillates between –a and a. (This is also a place where you could use p5.js’s map() function to map the output of sin() to a custom range.)\nNow, think about what’s inside the sin() function:\nTWO_PI * frameCount / period\nWhat’s going on here? Start with what you know. I’ve explained that sine has a period of 2\\pi, meaning it will start at 0 and repeat at 2\\pi, 4\\pi, 6\\pi, and so on. If my desired period of oscillation is 120 frames, I want the circle to be in the same position when frameCount is at 120 frames, 240 frames, 360 frames, and so on. Here, frameCount is the only value changing over time; it starts at 0 and counts upward. Let’s take a look at what the formula yields as frameCount increases.\n\n  \n    \n      frameCount\n      frameCount / period\n      TWO_PI * frameCount / period\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      60\n      0.5\n      \\pi\n    \n    \n      120\n      1\n      2\\pi\n    \n    \n      240\n      2\n      4\\pi\n    \n    \n      . . .\n      . . .\n      . . .\n    \n  \n\nDividing frameCount by period tells me the number of cycles that have been completed. (Is the wave halfway through the first cycle? Have two cycles completed?) Multiplying that number by TWO_PI, I get the desired result, an appropriate input to the sin() function, since TWO_PI is the value required for sine (or cosine) to complete one full cycle.\nPutting it together, here’s an example that oscillates the x position of a circle with an amplitude of 100 pixels and a period of 120 frames.\n\n  Example 3.5: Simple Harmonic Motion I\n  \n    \n    \n  \n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let period = 120;\n  let amplitude = 200;\n  //{!1} Calculate the horizontal position according to the formula for simple harmonic motion.\n  let x = amplitude * sin(TWO_PI * frameCount / period);\n  stroke(0);\n  fill(127);\n  translate(width / 2, height / 2);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}\nBefore moving on, I would be remiss not to mention frequency, the number of cycles of an oscillation per time unit. Frequency is the inverse of the period—that is, 1 divided by the period. For example, if the period is 120 frames, only 1/120th of a cycle is completed in 1 frame, and so the frequency is 1/120. In Example 3.5, I chose to define the rate of oscillation in terms of the period, and therefore I didn’t need a variable for frequency. Sometimes, however, thinking in terms of frequency rather than period is more useful.\n\n\n  Exercise 3.7\n  Using the sine function, create a simulation of a weight (sometimes referred to as a bob) that hangs from a spring from the top of the window. Use the map() function to calculate the vertical position of the bob. In “Spring Forces”, I’ll demonstrate how to create this same simulation by modeling the forces of a spring according to Hooke’s law.\n\nOscillation with Angular Velocity\nAn understanding of oscillation, amplitude, and period (or frequency) can be essential in the course of simulating real-world behaviors. However, there’s a slightly easier way to implement the simple harmonic motion from Example 3.5, one that achieves the same result with fewer variables. Take one more look at the oscillation formula:\nlet x = amplitude * sin(TWO_PI * frameCount / period);\nNow I’ll rewrite it in a slightly different way:\nlet x = amplitude * sin( <strong>some value that increments slowly</strong> );\nIf you care about precisely defining the period of oscillation in terms of frames of animation, you might need the formula as I first wrote it. If you don’t care about the exact period, however—for example, if you’ll be choosing it randomly—all you really need inside the sin() function is a value that increments slowly enough for the object’s motion to appear smooth from one frame to the next. Every time this value ticks past a multiple of 2\\pi, the object will have completed one cycle of oscillation.\nThis technique mirrors what I did with Perlin noise in Chapter 0. In that case, I incremented an offset variable (which I called t or xoff) to sample various outputs from the noise() function, creating a smooth transition of values. Now, I’m going to increment a value (I’ll call it angle) that’s fed into the sin() function. The difference is that the output from sin() is a smoothly repeating sine wave, without any randomness.\nYou might be wondering why I refer to the incrementing value as angle, given that the object has no visible rotation. The term angle is used because the value is passed into the sin() function, and angles are the traditional inputs to trigonometric functions. With this in mind, I can reintroduce the concept of angular velocity (and acceleration) to rewrite the example to calculate the x position in terms of a changing angle. I’ll assume these global variables:\nlet angle = 0;\nlet angleVelocity = 0.05;\nI can then write this:\nfunction draw() {\n  angle += angleVelocity;\n  let x = amplitude * sin(angle);\n}\nHere angle is my “value that increments slowly,” and the amount it slowly increments by is angleVelocity.\n\n  Example 3.6: Simple Harmonic Motion II\n  \n    \n    \n  \n\nlet angle = 0;\nlet angleVelocity = 0.05;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let amplitude = 200;\n  let x = amplitude * sin(angle);\n  //{!1} Use the concept of angular velocity to increment an angle variable.\n  angle += angleVelocity;\n  translate(width / 2, height / 2);\n  stroke(0);\n  fill(127);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}\nJust because I’m not referencing the period directly doesn’t mean that I’ve eliminated the concept. After all, the greater the angular velocity, the faster the circle will oscillate (and therefore the shorter the period). In fact, the period is the number of frames it takes for angle to increment by 2\\pi. Since the amount angle increments is controlled by the angular velocity, I can calculate the period as follows:\n\\text{period} = 2\\pi / \\text{angular velocity}\nTo illustrate the power of thinking of oscillation in terms of angular velocity, I’ll expand the example a bit more by creating an Oscillator class whose objects can oscillate independently along both the x-axis (as before) and the y-axis. The class will need two angles, two angular velocities, and two amplitudes (one for each axis).\nThis is a perfect opportunity to use createVector() to package each pair of values together! Unlike previous vectors, the values in these vectors won’t be sets of Cartesian coordinates. Nevertheless, the p5.Vector class provides a convenient way to manage pairs of values—in this case, pairs of angles (and their associated velocities, accelerations, and so on).\n\n  Example 3.7: Oscillator Objects\n  \n    \n    \n  \n\nclass Oscillator  {\n  constructor()  {\n    //{!1} Use a <code>p5.Vector</code> to track two angles!\n    this.angle = createVector();\n    //{!1.continue}\n    this.angleVelocity = createVector(random(-0.05, 0.05), random(-0.05, 0.05));\n    // Random velocities and amplitudes\n    this.amplitude = createVector(random(20, width / 2), random(20, height / 2));\n  }\n\n  update()  {\n    this.angle.add(this.angleVelocity);\n  }\n\n  show()  {\n    // Oscillating on the x-axis\n    let x = sin(this.angle.x) * this.amplitude.x;\n    //{!1} Oscillating on the y-axis\n    let y = sin(this.angle.y) * this.amplitude.y;\n    push();\n    translate(width / 2, height / 2);\n    stroke(0);\n    fill(127);\n    // Draw the oscillator as a line connecting a circle.\n    line(0, 0, x, y);\n    circle(x, y, 32);\n    pop();\n  }\n}\nTo better understand the Oscillator class, it might be helpful to focus on the movement of a single oscillator in the animation. First, observe its horizontal movement. You’ll notice that it oscillates regularly back and forth along the x-axis. Switching your focus to its vertical movement, you’ll see it oscillating up and down along the y-axis. Each oscillator has its own distinct rhythm, given the random initialization of its angle, angular velocity, and amplitude.\nThe key is to recognize that the x and y properties of the p5.Vector objects this.angle, this.angleVelocity, and this.amplitude aren’t tied to spatial vectors anymore. Instead, they’re used to store the respective properties for two separate oscillations (one along the x-axis, one along the y-axis). Ultimately, these oscillations are manifested spatially when x and y are calculated in the show() method, mapping the oscillations onto the positions of the object.\n\n  Exercise 3.8\n  Try initializing each Oscillator object with velocities and amplitudes that aren’t random to create some sort of regular pattern. Can you make the oscillators appear to be the legs of an insect-like creature?\n\n\n  Exercise 3.9\n  Incorporate angular acceleration into the Oscillator object.\n\nWaves\n\nImagine a single circle oscillating up and down according to the sine function. This is the equivalent of simulating a single point along the x-axis of a wave. With a little panache and a for loop, you can animate the entire wave by placing a series of oscillating circles next to one another (Figure 3.12).\n\n  \n  Figure 3.12: Animating the sine wave with oscillating circles\n\nYou could use this wavy pattern to design the body or appendages of a creature, or to simulate a soft surface (such as water). Let’s dive into how the code for this sketch works.\nHere, the same concepts of amplitude (the wave’s height) and period (the wave’s duration) come into play. However, when drawing the entire wave, the term period shifts its meaning from representing time to describing the width (in pixels) of a full wave cycle. The term for the spatial period (as opposed to the temporal period) of a wave is wavelength—the distance a wave travels to complete one full oscillation cycle. And just as with the previous oscillation example, you have the choice of computing the wave pattern according to a precise wavelength or by arbitrarily incrementing the angle value (delta angle) for each spot on the wave.\nI’ll go with the simpler case, incrementing the angle. I know I need three variables: an angle, a delta angle (analogous to the previous angular velocity), and an amplitude:\nlet angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;\nThen I’m going to loop through all the x values for each point on the wave. For now, I’ll put 24 pixels between adjacent x values. For each x, I’ll follow these three steps:\n\n  Calculate the y-position according to amplitude and the sine of the angle.\n  Draw a circle at the (x, y) position.\n  Increment the angle by the delta angle.\n\nThe following example translates these steps into code.\n\n  Example 3.8: Static Wave\n  \n    \n    \n  \n\nlet angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;\n\nfunction setup() {\n  createCanvas(640, 240);\n  background(255);\n  stroke(0);\n  fill(127, 127);\n  for (let x = 0; x <= width; x += 24) {\n    // Step 1: Calculate the y-position according to the amplitude and sine of the angle.\n    let y = amplitude * sin(angle);\n    // Step 2: Draw a circle at the <code>(x, y)</code> position.\n    circle(x, y + height / 2, 48);\n    // Step 3: Increment the angle according to the delta angle.\n    angle += deltaAngle;\n  }\n}\nWhat happens if you try different values for deltaAngle? Figure 3.13 shows some options.\n\n  \n    \n      \n    \n    \n      \n    \n    \n      \n    \n  \n  Figure 3.13: Three sine waves with varying deltaAngle values (0.05, 0.2, and 0.6 from left to right)\n\nAlthough I’m not precisely calculating the wavelength, you can see that the greater the change in angle, the shorter the wavelength. It’s also worth noting that as the wavelength decreases, it becomes more difficult to make out the wave since the vertical distance between the individual points increases.\nNotice that everything in Example 3.8 happens inside setup(), so the result is static. The wave never changes or undulates. Adding motion is a bit tricky. Your first instinct might be to say, “Hey, no problem, I’ll just put the for loop inside the draw() function and let angle continue incrementing from one cycle to the next.”\nThat’s a nice thought, but it doesn’t work. If you try it out, the result will appear extremely erratic and glitchy. To understand why, look back at Example 3.8. The right edge of the wave doesn’t match the height of the left edge, so where the wave ends in one cycle of draw() can’t be where it starts in the next. Instead, you need a variable dedicated entirely to tracking the starting angle value in each frame of the animation. This variable (which I’ll call startAngle) increments at its own pace, controlling how much the wave progresses from one frame to the next.\n\n  Example 3.9: The Wave\n  \n    \n    \n  \n\n//{!1} A new global variable tracking the starting angle of the wave\nlet startAngle = 0;\nlet deltaAngle = 0.2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Each time through <code>draw()</code>, the angle that increments is set to <code>startAngle</code>.\n  let angle = startAngle;\n  for (let x = 0; x <= width; x += 24) {\n    let y = map(sin(angle), -1, 1, 0, height);\n    stroke(0);\n    fill(127, 127);\n    circle(x, y, 48);\n    angle += deltaAngle;\n  }\n  // Increment the starting angle.\n  startAngle += 0.02;\n}\nIn this code example, the increment of startAngle is hardcoded to be 0.02, but you may want to consider reusing deltaAngle or creating a second variable instead. By reusing deltaAngle, the spatial progression of the wave would be tied to the temporal one, possibly creating a more synchronized movement. Introducing a separate variable, perhaps called startAngleVelocity, would allow independent control of the speed of the wave. The term velocity is appropriate here since the start angle is changing over time.\n\n  Exercise 3.10\n  Try using the Perlin noise function instead of sine or cosine to set the y values in Example 3.9.\n\n\n  Exercise 3.11\n  Encapsulate the wave-generating code into a Wave class, and create a sketch that displays two waves (with different amplitudes/periods), as shown in the following image. Try moving beyond plain circles and lines to visualize the wave in a more creative way. What about connecting the points by using beginShape(), endShape(), and vertex()?\n  \n    \n    \n  \n\n\n  Exercise 3.12\n  \n  To create more complex waves, you can add multiple waves together. Calculate the height (or y) values for several waves and add those values together to get a single y value. The result is a new wave that incorporates the characteristics of each individual wave.\n  \n    \n    \n  \n\nSpring Forces\n\n\n  \n    \n    Figure 3.14: A spring with an anchor and bob\n  \n\nExploring the mathematics of triangles and waves has been lovely, but perhaps you’re starting to miss Newton’s laws of motion and vectors. After all, the core of this book is about simulating the physics of moving bodies. In “Properties of Oscillation”, I modeled simple harmonic motion by mapping a sine wave to a range of pixels on a canvas. Exercise 3.7 asked you to use this technique to create a simulation of a bob hanging from a spring with the sin() function. That kind of quick-and-dirty, one-line-of-code solution won’t do, however, if what you really want is a bob hanging from a spring that responds to other forces in the environment (wind, gravity, and so on). To achieve a simulation like that, you need to model the force of the spring by using vectors.\nI’ll consider a spring to be a connection between a movable bob (or weight) and a fixed anchor point (see Figure 3.14).\n\n  \n    \n    Figure 3.15: A spring’s extension (x) is the difference between its current length and its rest length.\n  \n\nThe force of the spring is a vector calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the formula in 1660. Hooke originally stated the law in Latin: “Ut tensio, sic vis,” or “As the extension, so the force.” Think of it this way:\nThe force of the spring is directly proportional to the extension of the spring.\nThe extension is a measure of how much the spring has been stretched or compressed: as shown in Figure 3.15, it’s the difference between the current length of the spring and the spring’s resting length (its equilibrium state). Hooke’s law therefore says that if you pull on the bob a lot, the spring’s force will be strong, whereas if you pull on the bob a little, the force will be weak.\nMathematically, the law is stated as follows:\nF_{spring} = -kx\nHere k is the spring constant. Its value scales the force, setting how elastic or rigid the spring is. Meanwhile, x is the extension, the current length minus the rest length.\nNow remember, force is a vector, so you need to calculate both magnitude and direction. For the code, I’ll start with the following three variables—two vectors for the anchor and bob positions, and one rest length:\n// Pick arbitrary values for the positions and rest length.\nlet anchor = createVector(0, 0);\nlet bob = createVector(0, 120);\nlet restLength = 100;\nI’ll then use Hooke’s law to calculate the magnitude of the force. For that, I need k and x. Calculating k is easy; it’s just a constant, so I’ll make something up:\nlet k = 0.1;\nFinding x is perhaps a bit more difficult. I need to know the difference between the current length and the rest length. The rest length is defined as the variable restLength. What’s the current length? The distance between the anchor and the bob. And how can I calculate that distance? How about the magnitude of a vector that points from the anchor to the bob? (Note that this is exactly the same process I employed to find the distance between objects for the purposes of calculating gravitational attraction in Chapter 2.)\n//{!1} A vector pointing from the anchor to the bob gives you the current length of the spring.\nlet dir = p5.Vector.sub(bob, anchor);\nlet currentLength = dir.mag();\nlet x = currentLength - restLength;\nNow that I’ve sorted out the elements necessary for the magnitude of the force (–kx), I need to figure out the direction, a unit vector pointing in the direction of the force. The good news is that I already have this vector. Right? Just a moment ago I asked the question, “How can I calculate that distance?” and I answered, “How about the magnitude of a vector that points from the anchor to the bob?” Well, that vector describes the direction of the force!\nFigure 3.16 shows that if you stretch the spring beyond its rest length, a force should pull it back toward the anchor. And if the spring shrinks below its rest length, the force should push it away from the anchor. The Hooke’s law formula accounts for this reversal of direction with the –1.\n\n  \n  Figure 3.16: The spring force points in the opposite direction of the displacement.\n\nAll I need to do now is set the magnitude of the vector used for the distance calculation. Let’s take a look at the code and rename that vector variable force:\n// The magnitude of the spring force according to Hooke’s law\nlet k = 0.1;\nlet force = p5.Vector.sub(bob, anchor);\nlet currentLength = force.mag();\nlet x = currentLength - restLength;\n// Put it together: direction and magnitude!\nforce.setMag(-1 * k * x);\nNow that I have the algorithm for computing the spring force, the question remains: What OOP structure should I use? This is one of those situations that has no one correct answer. Several possibilities exist, and the one I choose depends on my goals and personal coding style.\nSince I’ve been working all along with a Mover class, I’ll stick with this same framework. I’ll think of the Mover class as the spring’s bob. The bob needs position, velocity, and acceleration vectors to move about the canvas. Perfect—I have those already! And perhaps the bob experiences a gravity force via the applyForce() method. This leaves just one more step, applying the spring force:\nlet bob;\n\nfunction setup() {\n  bob = new Bob();\n}\n\nfunction draw()  {\n  //{!2} Chapter 2’s make-up-a-gravity force\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  // Calculate and apply a spring force!\n  <strong>let springForce = _______________????\n  bob.applyForce(</strong><strong>spring</strong><strong>Force);</strong>\n  // The standard <code>update()</code> and <code>show()</code> methods\n  bob.update();\n  bob.show();\n}\nOne option would be to write all the spring-force code in the main draw() loop. But thinking ahead to when you might have multiple bob and spring connections, it would be wise to create an additional class, a Spring class. As shown in Figure 3.17, the Bob class keeps track of the bob’s movements; the Spring class keeps track of the spring’s anchor position and its rest length, and calculates the spring force on the bob.\n\n  \n  Figure 3.17: The Spring class has anchor and rest length; the Bob class has position, velocity, and acceleration.\n\nThis allows me to write a lovely sketch as follows:\nlet bob;\n// Add a <code>Spring</code> object.\n<strong>let spring;</strong>\n\nfunction setup() {\n  bob = new Bob();\n  spring = new Spring();\n}\n\nfunction draw()  {\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  //{!1} This new method in the <code>Spring</code> class will take care of computing the force of the spring on the bob.\n  <strong>spring.connect(bob);</strong>\n  bob.update();\n  bob.show();\n  spring.show();\n}\nThink about how this compares to my first stab at gravitational attraction in Example 2.6, when I had separate Mover and Attractor classes. There, I wrote something like this:\n  let force = attractor.attract(mover);\n  mover.applyForce(force);\nThe analogous situation with a spring might have been as follows:\n  let force = spring.connect(bob);\n  bob.applyForce(force);\nInstead, in this example I have the following:\n  spring.connect(bob);\nWhat gives? Why don’t I need to call applyForce() on the bob? The answer, of course, is that I do need to call applyForce() on the bob. It’s just that instead of doing it in draw(), I’m demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the connect() method to call applyForce() on the bob internally:\n  connect(bob) {\n    let force = <em>some fancy calculations</em>\n    // The <code>connect()</code> method takes care of calling <code>applyForce()</code> and therefore doesn’t have to return a vector to the calling area.\n    bob.applyForce(force);\n  }\nWhy do it one way with the Attractor class and another way with the Spring class? When I first discussed forces, showing all the forces being applied in the draw() loop was a clearer way to help you learn about force accumulation. Now that you’re more comfortable, perhaps it’s simpler to embed some of the details inside the objects themselves.\nLet’s take a look at the rest of the elements in the Spring class.\n\n  Example 3.10: A Spring Connection\n  \n    \n    \n  \n\nclass Spring {\n  // The constructor initializes the anchor point and rest length.\n  constructor(x, y, length) {\n    // The spring’s anchor position\n    this.anchor = createVector(x, y);\n    // Rest length and spring constant variables\n    this.restLength = length;\n    this.k = 0.2;\n  }\n\n  // Calculate the spring force as an implementation of Hooke’s law.\n  connect(bob) {\n    // Get a vector pointing from the anchor to the bob position.\n    <strong>let force = p5.Vector.sub(bob.position, this.anchor);</strong>\n    // Calculate the displacement between distance and rest length. I’ll use the variable name <code>stretch</code> instead of <code>x</code> to be more descriptive. \n    <strong>let currentLength = force.mag();\n    let stretch = currentLength - this.restLength;</strong>\n    // Direction and magnitude together!\n    <strong>force.setMag(-1 * this.k * stretch);</strong>\n    // Call <code>applyForce()</code> right here!\n    bob.applyForce(force);\n  }\n\n  // Draw the anchor.\n  show() {\n    fill(127);\n    circle(this.anchor.x, this.anchor.y, 10);\n  }\n\n  //{!2.bottom-align} Draw the spring connection between the bob position and the anchor.\n  showLine(bob) {\n    stroke(0);\n    //{!2.continue}\n    line(bob.position.x, bob.position.y, this.anchor.x, this.anchor.y);\n  }\n}\nThe complete code for this example is available on the book’s website and incorporates two additional features: (1) the Bob class includes methods for mouse interactivity, allowing you to drag the bob around the window, and (2) the Spring class includes a method to constrain the connection’s length between a minimum and a maximum value.\n\n  Exercise 3.13\n  Before running to see the example online, take a look at this constrainLength method and see if you can fill in the blanks:\n  constrainLength(bob, minlen, maxlen) {\n  //{!1} A vector pointing from the bob to the anchor\n  let direction = p5.Vector.sub(<span class=\"blank\">bob.position</span>, <span class=\"blank\">this.anchor</span>);\n  let length = direction.mag();\n  //{!1} Is it too short?\n  if (length < minlen) {\n    direction.setMag(<span class=\"blank\">minlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  //{!1} Is it too long?\n  } else if (length<span class=\"blank\"> > maxlen</span>) {\n    direction.setMag(<span class=\"blank\">maxlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  }\n}\n\n\n  Exercise 3.14\n  Create a system of multiple bobs and spring connections. How about connecting a bob to another bob with no fixed anchor?\n\nThe Pendulum\n\n\n  \n    \n    Figure 3.18: A pendulum with a pivot, arm, and bob\n  \n\nYou might have noticed that in Example 3.10’s spring code, I never once used sine or cosine. Before you write off all this trigonometry stuff as a tangent, however, allow me to show an example of how it all fits together. Imagine a bob hanging from an anchor connected by a spring with a fully rigid connection that can be neither compressed nor extended. This idealized scenario describes a pendulum and provides an excellent opportunity to practice combining all that you’ve learned about forces and trigonometry.\nA pendulum is a bob suspended by an arm from a pivot (previously called the anchor in the spring). When the pendulum is at rest, it hangs straight down, as in Figure 3.18. If you lift up the pendulum at an angle from its resting state and then release it, however, it starts to swing back and forth, tracing the shape of an arc. A real-world pendulum would live in a 3D space, but I’m going to look at a simpler scenario: a pendulum in the 2D space of a p5.js canvas. Figure 3.19 shows the pendulum in a nonresting position and adds the forces at play: gravity and tension.\nWhen the pendulum swings, its arm and bob are essentially rotating around the fixed point of the pivot. If no arm connected the bob and the pivot, the bob would simply fall to the ground under the influence of gravity. Obviously, that isn’t what happens. Instead, the fixed length of the arm creates the second force—tension. However, I’m not going to work with this scenario according to these forces, at least not in the way I approached the spring scenario.\n\n  \n    \n    Figure 3.19: A pendulum showing \\theta as the angle relative to its resting position\n  \n\nInstead of using linear acceleration and velocity, I’m going to describe the motion of the pendulum in terms of angular acceleration and angular velocity, which refer to the change of the arm’s angle \\theta relative to the pendulum’s resting position. I should first warn you, especially if you’re a seasoned physicist, that I’m going to conveniently ignore several important concepts here: conservation of energy, momentum, centripetal force, and more. This isn’t intended to be a comprehensive description of pendulum physics. My goal is to offer you an opportunity to practice your new skills in trigonometry and further explore the relationship between forces and angles through a concrete example.\nTo calculate the pendulum’s angular acceleration, I’m going to use Newton’s second law of motion but with a little trigonometric twist. Take a look at Figure 3.19 and tilt your head\nso that the pendulum’s arm becomes the vertical axis. The force of gravity suddenly points askew, a little to the left—it’s at an angle with respect to your tilted head. If this is starting to hurt your neck, don’t worry. I’ll redraw the tilted figure and relabel the forces F_g for gravity and T for tension (Figure 3.20, left).\nLet’s now take the force of gravity and divide its vector into x- and y-components, with the arm as the new y-axis. These components form a right triangle, with the force of gravity as the hypotenuse (Figure 3.20, right). I’ll call them F_{gx} and F_{gy}, but what do these components mean? Well, the F_{gy} component represents the force that’s opposite to T, the tension force. Remember, the tension force is what keeps the bob from falling off.\nThe other component, F_{gx}, is perpendicular to the arm of the pendulum, and it’s the force I’ve been looking for all along! It causes the pendulum to rotate. As the pendulum swings, the y-axis (the arm) will always be perpendicular to the direction of motion. Therefore, I can ignore the tension and F_{gy} forces and focus on F_{gx}, which is the net force in the direction of motion. And because this force is part of a right triangle, I can calculate it with . . . you guessed it, trigonometry!\n\n  \n  Figure 3.20: On the left, the pendulum is drawn rotated so that the arm is the y-axis. The right shows F_g zoomed in and divided into components F_{gx} and F_{gy}.\n\nThe key here is that the top angle of the right triangle is the same as the angle \\theta between the pendulum’s arm and its resting position. Just as I demonstrated in the discussion of polar coordinates, the sine and cosine functions allow me to separate out the components of the gravity force (the hypotenuse) according to this angle. For F_{gx}, I need to use sine:\n\\sin(\\theta) = F_{gx} / F_g\nSolving for F_{gx}, I get this:\nF_{gx} = F_g \\times \\sin(\\theta)\nI’ll now rename this force F_p for force of the pendulum. In Figure 3.21, I’ve restored the diagram to its original orientation and relabeled the components. I’ve also moved the starting point of F_p from the bottom of the right triangle to the bob’s center, to clarify how this force moves the bob.\nThere it is. The net force of the pendulum that causes the rotation is calculated as follows:\nF_p = F_g \\times \\sin(\\theta)\n\n  \n  Figure 3.21: F_{gx} is now labeled F_p, the net force in the direction of motion.\n\nLest you forget, however, my goal is to determine the angular acceleration of the pendulum. Once I have that, I’ll be able to apply the rules of motion to find a new angle \\theta for each frame of the animation:\n\\text{angular velocity} = \\text{angular velocity} + \\text{angular acceleration}\n\\text{angle} = \\text{angle + angular velocity}\nThe good news is that Newton’s second law establishes a relationship between force and acceleration—namely, F = M \\times A, or A = F / M. So if the force of the pendulum is equal to the force of gravity times the sine of the angle, then I have this:\n\\text{pendulum angular acceleration} = \\text{acceleration due to gravity} \\times \\sin(\\theta)\nThis is a good time for a reminder that the context here is creative coding and not pure physics. Yes, the acceleration due to gravity on Earth is 9.8 meters per second squared. But this number isn’t relevant in our world of pixels. Instead, I’ll use an arbitrary constant (called gravity) as a variable that scales the acceleration (incidentally, angular acceleration is usually written as \\alpha so as to distinguish it from linear acceleration A):\n\\alpha = \\text{gravity} \\times \\sin(\\theta)\nBefore I put everything together, there’s another detail I neglected to mention. Or really, lots of little details. Think about the pendulum arm for a moment. Is it a metal rod? A string? A rubber band? How is it attached to the pivot point? How long is it? What’s its mass? Is it a windy day? I could continue to ask a lot of questions that would affect the simulation. I choose to live, however, in a fantasy world, one where the pendulum’s arm is an idealized rod that never bends and where the mass of the bob is concentrated in a single, infinitesimally small point.\nEven though I prefer not to worry myself with all these questions, a critical piece is still missing, related to the calculation of angular acceleration. To keep the derivation of the pendulum’s angular acceleration simple, I assumed that the length of the pendulum’s arm is 1. In reality, however, the length of the pendulum’s arm affects the acceleration of the pendulum because of the concepts of torque and moment of inertia.\nTorque (or \\tau) is a measure of the rotational force acting on an object. In the case of a pendulum, torque is proportional to both the mass of the bob and the length of the arm (M \\times r). The moment of inertia (or I) of a pendulum is a measure of the amount of difficulty in rotating the pendulum around the pivot point. It’s proportional to the mass of the bob and the square of the length of the arm (Mr^2).\nRemember Newton’s second law, F=M \\times A? Well, it has a rotational counterpart, \\tau = I \\times \\alpha. By rearranging the equation to solve for the angular acceleration \\alpha, I get \\alpha = \\tau/I. Simplifying further, this becomes Mr/Mr^2 or 1/r. The angular acceleration doesn’t depend on the pendulum’s mass!\nThis is just like Galileo’s Leaning Tower of Pisa experiment demonstrating linear acceleration, where different objects fell at the same rate, regardless of their mass. Here, once again, the mass of a bob doesn’t influence its angular acceleration—only the length of its arm does. Thus, the final formula becomes this:\n\\alpha = \\frac{\\text{gravity} \\times \\sin(\\theta)}{r}\nAmazing! In the end, the formula is so simple that you might be wondering why I bothered going through the explanation at all. I mean, learning is great, but I could have easily just said, “Hey, the angular acceleration of a pendulum is a constant times the sine of the angle divided by the length of the arm.” That would be missing the point. The purpose of this book isn’t to learn how pendulums swing or gravity works. The point is to think creatively about how shapes can move around a screen in a computationally based graphics system. The pendulum is just a case study. If you can understand the approach to programming a pendulum, you can apply the same techniques to other scenarios, no matter how you choose to design your p5.js canvas world.\nNow, I’m not finished yet. I may be happy with my simple, elegant formula for angular acceleration, but I still have to apply it in code. This is an excellent opportunity to practice some OOP skills and create a Pendulum class. First, think about all the properties of a pendulum that I’ve mentioned:\n\n  \n    Arm length\n    Angle\n    Angular velocity\n    Angular acceleration\n  \n\nThe Pendulum class needs all these properties too:\n\n  class Pendulum  {\n  constructor() {\n    // Length of arm\n    this.r = ????;\n    // Pendulum arm angle\n    this.angle = ????;\n    // Angular velocity\n    this.angleVelocity = ????;\n    // Angular acceleration\n    this.angleAcceleration = ????;\n  } \n\nNext, I need to write an update() method to update the pendulum’s angle according to the formula:\n\n    update() {\n    // An arbitrary constant\n    let gravity = 0.4;\n    // Calculate acceleration according to the formula.\n    this.angleAcceleration = -1 * gravity * sin(this.angle) / this.r;\n    // Increment the velocity.\n    this.angleVelocity += this.angleAcceleration;\n    // Increment the angle.\n    this.angle += this.angleVelocity;\n  }\n\nNote that the acceleration calculation now includes a multiplication by –1. When the pendulum is to the right of its resting position, the angle is positive, and so the sine of the angle is also positive. However, gravity should pull the bob back toward the resting position. Conversely, when the pendulum is to the left of its resting position, the angle is negative, and so its sine is negative too. In this case, the pulling force should be positive. Multiplying by –1 is necessary in both scenarios.\nNext, I need a show() method to draw the pendulum on the canvas. But where exactly should I draw it? How do I calculate the x- and y-coordinates (Cartesian!) for both the pendulum’s pivot point (let’s call it pivot) and bob position (let’s call it bob)? This may be getting a little tiresome, but the answer, yet again, is trigonometry, as shown in Figure 3.22.\n\n  \n  Figure 3.22: The bob position relative to the pivot in polar and Cartesian coordinates\n\nFirst, I’ll need to add a this.pivot property to the constructor to specify where to draw the pendulum on the canvas:\nthis.pivot = createVector(100, 10);\nI know the bob should be a set distance away from the pivot, as determined by the arm length. That’s my variable r, which I’ll set now:\nthis.r = 125;\nI also know the bob’s current angle relative to the pivot: it’s stored in the variable angle. Between the arm length and the angle, what I have is a polar coordinate for the bob: (r,\\theta). What I really need is a Cartesian coordinate, but luckily I already know how to use sine and cosine to convert from polar to Cartesian. And so:\nthis.bob = createVector(r * sin(this.angle), r * cos(this.angle));\nNotice that I’m using sin(this.angle) for the x value and cos(this.angle) for the y. This is the opposite of what I showed you in “Polar vs. Cartesian Coordinates”. The reason is that I’m now looking for the top angle of a right triangle pointing down, as depicted in Figure 3.21. This angle lives between the y-axis and the hypotenuse, instead of between the x-axis and the hypotenuse, as you saw earlier in Figure 3.9.\nRight now, the value of this.bob is assuming that the pivot is at point (0, 0). To get the bob’s position relative to wherever the pivot actually happens to be, I can just add pivot to the bob vector:\nthis.bob.add(this.pivot);\nNow all that remains is the little matter of drawing a line and a circle (you should be more creative, of course):\nstroke(0);\nfill(127);\nline(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\ncircle(this.bob.x, this.bob.y, 16);\nFinally, a real-world pendulum is going to experience a certain amount of friction (at the pivot point) and air resistance. As it stands, the pendulum would swing forever with the given code. To make it more realistic, I can slow the pendulum with a damping trick. I say trick because rather than model the resistance forces with some degree of accuracy (as I did in Chapter 2), I can achieve a similar result simply by reducing the angular velocity by an arbitrary amount during each cycle. The following code reduces the velocity by 1 percent (or multiplies it by 0.99) for each frame of animation:\nthis.angleVelocity *= 0.99;\nPutting everything together, I have the following example (with the pendulum beginning at a 45-degree angle).\n\n  Example 3.11: Swinging Pendulum\n  \n    \n    \n  \n\nlet pendulum;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Make a new <code>Pendulum</code> object with an origin position and arm length.\n  pendulum = new Pendulum(width / 2, 0, 175);\n}\n\nfunction draw() {\n  background(255);\n  pendulum.update();\n  pendulum.show();\n}\n\nclass Pendulum  {\n  constructor(x, y, r) {\n    //{!8} Many, many variables keep track of the pendulum’s various properties.\n    this.pivot = createVector(x, y); // Position of pivot\n    this.bob = createVector();       // Position of bob\n    this.r = r;                      // Length of arm\n    this.angle = PI / 4;             // Pendulum arm angle\n    this.angleVelocity = 0;          // Angle velocity\n    this.angleAcceleration = 0;      // Angle acceleration\n    this.damping = 0.99;             // Arbitrary damping\n    this.ballr = 24;                 // Arbitrary bob radius\n  }\n\n  update() {\n    let gravity = 0.4;\n    // Formula for angular acceleration\n    this.angleAcceleration = (-1 * gravity / this.r) * sin(this.angle);\n    // Standard angular motion algorithm\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    //{!1} Apply some damping.\n    this.angleVelocity *= this.damping;\n  }\n\n  show() {\n    // Apply polar-to-Cartesian conversion. Instead of creating a new vector each time, I’ll use <code>set()</code> to update the bob’s position.\n    this.bob.set(this.r * sin(this.angle), this.r * cos(this.angle));\n    this.bob.add(this.pivot);\n    // The arm\n    stroke(0);\n    line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\n    // The bob\n    fill(127);\n    circle(this.bob.x, this.bob.y, this.ballr * 2);\n  }\n}\nOn the book’s website, this example has additional code to allow the user to grab the pendulum and swing it with the mouse.\n\n  Exercise 3.15\n  String together a series of pendulums so that the bob of one is the pivot point of another. Note that doing this may produce intriguing results but will be wildly inaccurate physically. Simulating an actual double pendulum requires sophisticated equations. You can read about them in the Wolfram Research article on double pendulums or watch my video on coding a double pendulum.\n  \n    \n    \n  \n\n\n  Exercise 3.16\n  \n    \n    \n  \n  Using trigonometry, how do you calculate the magnitude of the normal force depicted here (the force perpendicular to the incline on which the sled rests)? You can consider the magnitude of F_\\text{gravity} to be a known constant. Look for a right triangle to help get you started. After all, the normal force is equal and opposite to a component of the force of gravity. If it helps to draw over the diagram and make more right triangles, go for it!\n\n\n  Exercise 3.17\n  Create a simulation of a box sliding down an incline with friction. Note that the magnitude of the friction force is proportional to the normal force, as discussed in the previous exercise.\n\n\n  The Ecosystem Project\n  Take one of your creatures and incorporate oscillation into its motion. You can use the Oscillator class from Example 3.7 as a model. The Oscillator object, however, oscillates around a single point (the middle of the window). Try oscillating around a moving point.\n  In other words, design a creature that moves around the screen according to position, velocity, and acceleration. But that creature isn’t just a static shape; it’s an oscillating body. Consider tying the speed of oscillation to the speed of motion. Think of a butterfly’s flapping wings or the legs of an insect. Can you make it appear as though the creature’s internal mechanics (oscillation) drive its locomotion? See the book’s website for an additional example combining attraction from Chapter 2 with oscillation.\n  \n    \n    \n  \n\n\n",
  "htmlContent": "<section data-type=\"chapter\" id=\"section-oscillation\">\n<h1 id=\"chapter-3-oscillation\">Chapter 3. Oscillation</h1>\n<div class=\"chapter-opening-quote\">\n  <blockquote data-type=\"epigraph\">\n    <p>Trigonometry is a sine of the times.</p>\n    <div class=\"chapter-opening-quote-source\">\n      <p>—Anonymous</p>\n    </div>\n  </blockquote>\n</div>\n<div class=\"chapter-opening-figure\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_1.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n  <h3 id=\"gala-by-bridget-riley-1974-acrylic-on-canvas-1597--1597-cm\"><em>Gala</em> by Bridget Riley, 1974; acrylic on canvas, 159.7 × 159.7 cm</h3>\n  <p>Bridget Riley, a celebrated British artist, was a driving force behind the Op Art movement of the 1960s. Her work features geometric patterns that challenge the viewer’s perceptions and evoke feelings of movement or vibration. Her 1974 piece <em>Gala</em> showcases a series of curvilinear forms that ripple across the canvas, evoking the natural rhythm of the sine wave.</p>\n</div>\n<p>In <a href=\"/vectors#section-vectors\">Chapters 1</a> and <a href=\"/forces#section-forces\">2</a>, I carefully worked out an object-oriented structure to animate a shape in a p5.js canvas, using a vector to represent position, velocity, and acceleration driven by forces in the environment. I could move straight from here into topics such as particle systems, steering forces, group behaviors, and more. However, doing so would mean skipping a fundamental aspect of motion in the natural world: <strong>oscillation</strong>, or the back-and-forth movement of an object around a central point or position.</p>\n<p>To model oscillation, you need to understand a little bit about <strong>trigonometry</strong>, the mathematics of triangles. Learning some trig will give you new tools to generate patterns and create new motion behaviors in a p5.js sketch. You’ll learn to harness angular velocity and acceleration to spin objects as they move. You’ll be able to use the sine and cosine functions to model nice ease-in, ease-out wave patterns. You’ll also learn to calculate the more complex forces at play in situations that involve angles, such as a pendulum swinging or a box sliding down an incline.</p>\n<p>I’ll start with the basics of working with angles in p5.js, then cover several aspects of trigonometry. In the end, I’ll connect trigonometry with what you learned about forces in <a href=\"/forces#section-forces\">Chapter 2</a>. This chapter’s content will pave the way for more sophisticated examples that require trig later in this book.</p>\n<h2 id=\"angles\">Angles</h2>\n<div data-type=\"video-link\" data-title=\"Angles and Rotation\" href=\"https://www.youtube.com/watch?time_continue=1&#x26;v=DMg-WRfNB60&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Before going any further, I need to make sure you understand how the concept of an <strong>angle</strong> fits into creative coding in p5.js. If you have experience with p5.js, you’ve undoubtedly encountered this issue while using the <code>rotate()</code> function to rotate and spin objects. You’re most likely to be familiar with the concept of an angle as measured in <strong>degrees</strong> (see Figure 3.1).</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_2.png\" alt=\"Figure 3.1: Angles measured in degrees\">\n  <figcaption>Figure 3.1: Angles measured in degrees</figcaption>\n</figure>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_3.png\" alt=\"Figure 3.2: A square rotated by 45 degrees\">\n    <figcaption>Figure 3.2: A square rotated by 45 degrees</figcaption>\n  </figure>\n</div>\n<p>A full rotation goes from 0 to 360 degrees, and 90 degrees (a right angle) is one-fourth of 360, shown in Figure 3.1 as two perpendicular lines.</p>\n<p>Angles are commonly used in computer graphics to specify a rotation for a shape. For example, the square in Figure 3.2 is rotated 45 degrees around its center.</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_4.png\" alt=\"Figure 3.3: The arc length for an angle of 1 radian is equal to the radius.\">\n    <figcaption>Figure 3.3: The arc length for an angle of 1 radian is equal to the radius.</figcaption>\n  </figure>\n</div>\n<p>The catch is that, by default, p5.js measures angles not in degrees but in <strong>radians</strong>. This alternative unit of measurement is defined by the ratio of the length of the arc of a circle (a segment of the circle’s circumference) to the radius of that circle. One radian is the angle at which that ratio equals 1 (see Figure 3.3). A full circle (360 degrees) is equivalent to <span data-type=\"equation\">2\\pi</span> radians, 180 degrees is equivalent to <span data-type=\"equation\">\\pi</span> radians, and 90 degrees is equivalent to <span data-type=\"equation\">\\pi/2</span> radians.</p>\n<p>The formula to convert from degrees to radians is as follows:</p>\n<div data-type=\"equation\">\\text{radians} = {2\\pi \\times \\text{degrees} \\over 360}</div>\n<p>Thankfully, if you prefer to think of angles in degrees, you can call <code>angleMode(DEGREES)</code>, or you can use the convenience function <code>radians()</code> to convert values from degrees to radians. The constants <code>PI</code>, <code>TWO_PI</code>, and <code>HALF_PI</code> are also available (equivalent to 180, 360, and 90 degrees, respectively). For example, here are two ways in p5.js to rotate a shape by 60 degrees:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let angle = 60;\nrotate(radians(angle));\n\nangleMode(DEGREES);\nrotate(angle);</pre>\n<div data-type=\"note\">\n  <h3 id=\"what-is-pi\">What Is Pi?</h3>\n  <p>The mathematical constant <strong>pi</strong> (or the Greek letter <span data-type=\"equation\">\\pi</span>) is a real number defined as the ratio of a circle’s circumference (the distance around the outside of the circle) to its diameter (a straight line that passes through the circle’s center). It’s equal to approximately 3.14159 and can be accessed in p5.js with the built-in <code>PI</code> variable.</p>\n</div>\n<p>While degrees can be useful, for the purposes of this book, I’ll be working with radians because they’re the standard unit of measurement across many programming languages and graphics environments. If they’re new to you, this is a good opportunity to practice! Additionally, if you aren’t familiar with the way rotation is implemented in p5.js, I recommend watching <a href=\"https://thecodingtrain.com/transformations\">my Coding Train video series on transformations in p5.js</a>.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-31\">Exercise 3.1</h3>\n  <p>Rotate a baton-like object around its center by using <code>translate()</code> and <code>rotate()</code>.</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/KGSjouINj\" data-example-path=\"examples/03_oscillation/exercise_3_1_baton\"><img src=\"/content/examples/03_oscillation/exercise_3_1_baton/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<h2 id=\"angular-motion\">Angular Motion</h2>\n<div data-type=\"video-link\" data-title=\"Angular Motion\" href=\"https://www.youtube.com/watch?v=i2ROE_mAhU0&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Another term for rotation is <strong>angular motion</strong>—that is, motion about an angle. Just as linear motion can be described in terms of velocity—the rate at which an object’s position changes over time—angular motion can be described in terms of <strong>angular velocity</strong>—the rate at which an object’s angle changes over time. By extension, <strong>angular acceleration</strong> describes changes in an object’s angular velocity.</p>\n<p>Luckily, you already have all the math you need to understand angular motion. Remember the stuff I dedicated almost all of <a href=\"/vectors#section-vectors\">Chapters 1</a> and <a href=\"/forces#section-forces\">2</a> to explaining?</p>\n<div class=\"avoid-break\">\n  <div data-type=\"equation\">\\overrightarrow{\\text{velocity}} = \\overrightarrow{\\text{velocity}} + \\overrightarrow{\\text{acceleration}}</div>\n  <div data-type=\"equation\">\\overrightarrow{\\text{position}} = \\overrightarrow{\\text{position}} + \\overrightarrow{\\text{velocity}}</div>\n</div>\n<p>You can apply exactly the same logic to a rotating object:</p>\n<div data-type=\"equation\">\\text{angular velocity} = \\text{angular velocity} + \\text{angular~acceleration}</div>\n<div data-type=\"equation\">\\text{angle} = \\text{angle} + \\text{angular velocity}</div>\n<p>In fact, these angular motion formulas are simpler than their linear motion equivalents since the angle here is a <em>scalar</em> quantity (a single number), not a vector! This is because in 2D space, there’s one axis of rotation; in 3D space, the angle would become a vector. (Note that in most contexts, these formulas would include a multiplication by the change in time, referred to as <em>delta time</em>. I’m assuming a delta time of 1 that corresponds to one frame of animation in p5.js.)</p>\n<p>Using the answer from Exercise 3.1, let’s say you wanted to rotate a baton in p5.js by a certain angle. Originally, the code might have read as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">translate(width / 2, height / 2);\nrotate(angle);\nline(-60, 0, 60, 0);\ncircle(60, 0, 16);\ncircle(-60, 0, 16);\n\nangle = angle + 0.1;</pre>\n<p>Adding in the principles of angular motion, I can instead write the following example (the solution to Exercise 3.1).</p>\n<div data-type=\"example\">\n  <h3 id=\"example-31-angular-motion-using-rotate\">Example 3.1: Angular Motion Using rotate()</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/EFCfyH88E\" data-example-path=\"examples/03_oscillation/example_3_1_angular_motion_using_rotate\"><img src=\"/content/examples/03_oscillation/example_3_1_angular_motion_using_rotate/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div class=\"avoid-break\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">// Position\nlet angle = 0;\n// Velocity\nlet angleVelocity = 0;\n// Acceleration\nlet angleAcceleration = 0.0001;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  translate(width / 2, height / 2);\n  //{!1} Rotate according to that angle.\n  rotate(angle);\n  stroke(0);\n  fill(127);\n  line(-60, 0, 60, 0);\n  circle(60, 0, 16);\n  circle(-60, 0, 16);\n  // Angular equivalent of <code>velocity.add(acceleration)</code>\n  angleVelocity += angleAcceleration;\n  // Angular equivalent of <code>position.add(velocity)</code>\n  angle += angleVelocity;\n}</pre>\n</div>\n<p></p>\n<p></p>\n<p>Instead of incrementing <code>angle</code> by a fixed amount to steadily rotate the baton, for every frame I add <code>angleAcceleration</code> to <code>angleVelocity</code>, then add <code>angleVelocity</code> to <code>angle</code>. As a result, the baton starts with no rotation and then spins faster and faster as the angular velocity accelerates.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-32\">Exercise 3.2</h3>\n  <p>Add an interaction to the spinning baton. How can you control the acceleration with the mouse? Can you introduce the idea of drag, decreasing the angular velocity over time so the baton eventually comes to rest?</p>\n</div>\n<p>The logical next step is to incorporate this idea of angular motion into the <code>Mover</code> class. First, I need to add some variables to the class’s constructor:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    this.mass = 1.0;\n    // Variables for angular motion\n    this.angle = 0;\n    this.angleVelocity = 0;\n    this.angleAcceleration = 0;\n  }</pre>\n</div>\n<p>Then, in <code>update()</code>, the mover’s position and angle are updated according to the algorithm I just demonstrated:</p>\n<div class=\"snip-below snip-above\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    // Regular old-fashioned motion\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!2} Newfangled angular motion\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }</pre>\n</div>\n<p>Of course, for any of this to matter, I also need to rotate the object when drawing it in the <code>show()</code> method. (I’ll add a line from the center to the edge of the circle so that rotation is visible. You could also draw the object as a shape other than a circle.)</p>\n<div class=\"snip-below snip-above\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  show() {\n    stroke(0);\n    fill(175, 200);\n    // Use <code>push()</code> to save the current state so the rotation of this shape doesn’t affect the rest of the world.\n    push();\n    // Set the origin at the shape’s position.\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate by the angle.\n    rotate(this.angle);\n    circle(0, 0, this.radius * 2);\n    line(0, 0, this.radius, 0);\n    // Use <code>pop()</code> to restore the previous state after rotation is complete.\n    pop();\n  }</pre>\n</div>\n<p>At this point, if you were to actually go ahead and create a <code>Mover</code> object, you wouldn’t see it<br>behave any differently. This is because the angular acceleration is initialized to zero (<code>this.angleAcceleration = 0;</code>). For the object to rotate, it needs a nonzero acceleration! Certainly, one option is to hardcode a number in the constructor:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">    this.angleAcceleration = 0.01;</pre>\n<p>You can produce a more interesting result, however, by dynamically assigning an angular acceleration in the <code>update()</code> method according to forces in the environment. This could be my cue to start researching the physics of angular acceleration based on the concepts of <a href=\"https://en.wikipedia.org/wiki/Torque\">torque</a> and <a href=\"https://en.wikipedia.org/wiki/Moment_of_inertia\">moment of inertia</a>, but at this stage, that level of simulation would be a bit of a rabbit hole. (I’ll cover modeling angular acceleration with a pendulum in more detail in <a href=\"#the-pendulum\" class=\"page-reference\">“The Pendulum”</a>, as well as look at how third-party physics libraries realistically model rotational motion in <a href=\"/physics-libraries#section-physics-libraries\">Chapter 6</a>.)</p>\n<p>Instead, a quick-and-dirty solution that yields creative results will suffice. A reasonable approach is to calculate angular acceleration as a function of the object’s linear acceleration, its rate of change of velocity along a path vector, as opposed to its rotation. Here’s an example:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">    // Use the x-component of the object’s linear acceleration to calculate angular acceleration.\n    this.angleAcceleration = this.acceleration.x;</pre>\n<p>Yes, this is arbitrary, but it does do <em>something</em>. If the object is accelerating to the right, its angular rotation accelerates in a clockwise direction; acceleration to the left results in a counterclockwise rotation. Of course, it’s important to think about scale in this case. The value of the acceleration vector’s <code>x</code> component might be too large, causing the object to spin in a way that looks ridiculous or unrealistic. You might even notice a visual illusion called the <em>wagon wheel effect</em>: an object appears to be rotating more slowly or even in the opposite direction because of the large changes between each frame of animation.</p>\n<p>Dividing the <code>x</code> component by a value, or perhaps constraining the angular velocity to a reasonable range, could really help. Here’s the entire <code>update()</code> function with these tweaks added.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-32-forces-with-arbitrary-angular-motion\">Example 3.2: Forces with (Arbitrary) Angular Motion</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/xj2C2Ldbo\" data-example-path=\"examples/03_oscillation/example_3_2_forces_with_arbitrary_angular_motion\"><img src=\"/content/examples/03_oscillation/example_3_2_forces_with_arbitrary_angular_motion/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!1} Calculate angular acceleration according to acceleration’s x-component.\n    this.angleAcceleration = this.acceleration.x / 10.0;\n    this.angleVelocity += this.angleAcceleration;\n    //{!1} Use <code>constrain()</code> to ensure that angular velocity doesn’t spin out of control.\n    this.angleVelocity = constrain(this.angleVelocity, -0.1, 0.1);\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }</pre>\n<p>Notice that I’ve used multiple strategies to keep the object from spinning out of control. First, I divide <code>acceleration.x</code> by <code>10</code> before assigning it to <code>angleAcceleration</code>. Then, for good measure, I also use <code>constrain()</code> to confine <code>angleVelocity</code> to the range <code>(–0.1, 0.1)</code>.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-33\">Exercise 3.3</h3>\n  <p>Step 1: Create a simulation of objects being shot out of a cannon. Each object should experience a sudden force when shot (just once) as well as gravity (always present).</p>\n  <p></p>\n  <p>Step 2: Add rotation to the object to model its spin as it’s shot from the cannon. How realistic can you make it look?</p>\n</div>\n<h2 id=\"trigonometry-functions\">Trigonometry Functions</h2>\n<p>I think I’m ready to reveal the secret of trigonometry. I’ve discussed angles, I’ve spun a baton. Now it’s time for . . . wait for it . . . <em>sohcahtoa</em>. Yes, <em>sohcahtoa</em>! This seemingly nonsensical word is actually the foundation for much of computer graphics work. A basic understanding of trigonometry is essential if you want to calculate angles, figure out distances between points, and work with circles, arcs, or lines. And <em>sohcahtoa</em> is a mnemonic device (albeit a somewhat absurd one) for remembering the meanings of the trigonometric functions sine, cosine, and tangent. It references the sides of a right triangle, as shown in Figure 3.4.</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_5.png\" alt=\"Figure 3.4: A right triangle showing the sides as adjacent, opposite, and hypotenuse\">\n  <figcaption>Figure 3.4: A right triangle showing the sides as adjacent, opposite, and hypotenuse</figcaption>\n</figure>\n<p>Take one of the non-right angles in the triangle. The <em>adjacent</em> side is the one touching that angle, the <em>opposite</em> side is the one not touching that angle, and the <em>hypotenuse</em> is the side opposite the right angle. <em>Sohcahtoa</em> tells you how to calculate the angle’s trigonometric functions in terms of the lengths of these sides:</p>\n<ul>\n  <li><strong>soh:</strong> <span data-type=\"equation\">\\text{\\textbf{s}ine(angle)} = \\text{\\textbf{o}pposite}/\\text{\\textbf{h}ypotenuse}</span></li>\n  <li><strong>cah:</strong> <span data-type=\"equation\">\\text{\\textbf{c}osine(angle)} = \\text{\\textbf{a}djacent} / \\text{\\textbf{h}ypotenuse}</span></li>\n  <li><strong>toa:</strong> <span data-type=\"equation\">\\text{\\textbf{t}angent(angle)} = \\text{\\textbf{o}pposite} / \\text{\\textbf{a}djacent}</span></li>\n</ul>\n<p>Take a look at Figure 3.4 again. You don’t need to memorize it, but see if you feel comfortable with it. Try redrawing it yourself. Next, let’s look at it in a slightly different way (see Figure 3.5).</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_6.png\" alt=\"Figure 3.5: A vector vec{v} with components x, y, and angle\">\n    <figcaption>Figure 3.5: A vector <span data-type=\"equation\">\\vec{v}</span> with components <em>x</em>, <em>y</em>, and <em>angle</em></figcaption>\n  </figure>\n</div>\n<p>See how a right triangle is created from the vector <span data-type=\"equation\">\\vec{v}</span>? The vector arrow is the hypotenuse, and the components of the vector (<em>x</em> and <em>y</em>) are the sides of the triangle. The angle is an additional means for specifying the vector’s direction (or <em>heading</em>). Viewed in this way, the trigonometric functions establish a relationship between the components of a vector and its direction + magnitude. As such, trigonometry will prove very useful throughout this book. To illustrate this, let’s look at an example that requires the tangent function.</p>\n<h2 id=\"pointing-in-the-direction-of-movement\">Pointing in the Direction of Movement</h2>\n<div data-type=\"video-link\" data-title=\"Angles &#x26; Vectors\" href=\"https://www.youtube.com/watch?v=oXwCVDXS2Lg\"></div>\n<p>Think all the way back to Example 1.10, which featured a <code>Mover</code> object accelerating toward the mouse (Figure 3.6).</p>\n<figure>\n  <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/gYJHm1EFL\" data-example-path=\"examples/03_oscillation/example_1_10_accelerating_towards_the_mouse\"><img src=\"/content/examples/03_oscillation/example_1_10_accelerating_towards_the_mouse/screenshot.png\"></div>\n  <figcaption>Figure 3.6: A mover accelerating toward the mouse (from Example 1.10)</figcaption>\n</figure>\n<p>You might notice that almost all the shapes I’ve been drawing so far have been circles. This is convenient for several reasons, one of which is that using circles allows me to avoid the question of rotation. Rotate a circle and, well, it looks exactly the same. Nevertheless, there comes a time in all motion programmers’ lives when they want to move something around onscreen that isn’t shaped like a circle. Perhaps it’s an ant, or a car, or a spaceship. To look realistic, that object should point in its direction of movement.</p>\n<p>When I say “point in its direction of movement,” what I really mean is “rotate according to its velocity vector.” Velocity is a vector, with an x- and y-component, but to rotate in p5.js, you need one number, an angle. Let’s look at the trigonometry diagram once more, this time focused on an object’s velocity vector (Figure 3.7).</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_7.png\" alt=\"Figure 3.7: The tangent of a velocity vector’s angle is y divided by x.\">\n  <figcaption>Figure 3.7: The tangent of a velocity vector’s angle is <em>y</em> divided by <em>x</em>.</figcaption>\n</figure>\n<p>The vector’s x- and y-components are related to its angle through the tangent function. Using the <em>toa</em> in <em>sohcahtoa</em>, I can write the relationship as follows:</p>\n<div data-type=\"equation\">\\text{tangent(angle)} = \\frac{\\text{velocity}_y}{\\text{velocity}_x}</div>\n<p>The problem here is that while I know the x- and y-components of the velocity vector, I don’t know the angle of its direction. I have to solve for that angle. This is where another function known as the <em>inverse tangent</em>, or <em>arctangent</em> (<em>arctan</em> or <em>atan</em>, for short), comes in. (There are also <em>inverse sine</em> and <em>inverse cosine</em> functions, called <em>arcsine</em> and <em>arccosine</em>, respectively.)</p>\n<p>If the tangent of value <em>a</em> equals value <em>b</em>, then the inverse tangent of <em>b</em> equals <em>a</em>. For example:</p>\n<table>\n  <tbody>\n    <tr>\n      <td>If</td>\n      <td><span data-type=\"equation\">\\tan(a) = b</span></td>\n    </tr>\n    <tr>\n      <td>then</td>\n      <td><span data-type=\"equation\">a = \\arctan(b)</span></td>\n    </tr>\n  </tbody>\n</table>\n<p>See how one is the inverse of the other? This allows me to solve for the vector’s angle:</p>\n<table>\n  <tbody>\n    <tr>\n      <td>If</td>\n      <td><span data-type=\"equation\">\\tan(\\text{angle}) = \\frac{\\text{velocity}_y}{\\text{velocity}_x}</span></td>\n    </tr>\n    <tr>\n      <td>then</td>\n      <td><span data-type=\"equation\">\\text{angle} = \\arctan(\\frac{\\text{velocity}_y}{\\text{velocity}_x})</span></td>\n    </tr>\n  </tbody>\n</table>\n<p>Now that I have the formula, let’s see where it should go in the <code>Mover</code> class’s <code>show()</code> method to make the mover (now drawn as a rectangle) point in its direction of motion. Note that in p5.js, the function for inverse tangent is <code>atan()</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  show() {\n    //{!1} Solve for the angle by using <code>atan()</code>.\n    let angle = atan(this.velocity.y / this.velocity.x);\n    stroke(0);\n    fill(175);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }</pre>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_8.png\" alt=\"Figure 3.8: The vectors vec{v}_1 and vec{v}_2 with components (4, –3) and (–4, 3) point in opposite directions.\">\n    <figcaption>Figure 3.8: The vectors <span data-type=\"equation\">\\vec{v}_1</span> and <span data-type=\"equation\">\\vec{v}_2</span> with components (4, –3) and (–4, 3) point in opposite directions.</figcaption>\n  </figure>\n</div>\n<p>This code is pretty darn close and almost works. There’s a big problem, though. Consider the two velocity vectors depicted in Figure 3.8.</p>\n<p>Though superficially similar, the two vectors point in quite different directions—opposite directions, in fact! In spite of this, look at what happens if I apply the inverse tangent formula to solve for the angle of each vector:</p>\n<div data-type=\"equation\">\\vec{v}_1 ⇒ \\text{angle} = \\arctan(3/{-4}) = \\arctan(-0.75) = -0.643501 \\text{ radians} = -37 \\text{ degrees}</div>\n<div data-type=\"equation\">\\vec{v}_2 ⇒ \\text{angle} = \\arctan(-3/4) = \\arctan(-0.75) = -0.643501 \\text{ radians} = -37 \\text{ degrees}</div>\n<p>I get the same angle! That can’t be right, though, since the vectors are pointing in opposite directions. It turns out this is a pretty common problem in computer graphics. I could use <code>atan()</code> along with conditional statements to account for positive/negative scenarios, but p5.js (along with most programming environments) has a helpful function called <code>atan2()</code> that resolves the issue for me.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-33-pointing-in-the-direction-of-motion\">Example 3.3: Pointing in the Direction of Motion</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/bZqHGYbRQ\" data-example-path=\"examples/03_oscillation/example_3_3_pointing_in_the_direction_of_motion\"><img src=\"/content/examples/03_oscillation/example_3_3_pointing_in_the_direction_of_motion/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div class=\"avoid-break\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  show() {\n    //{!1} Use <code>atan2()</code> to account for all possible directions.\n    let angle = atan2(this.velocity.y, this.velocity.x);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }</pre>\n</div>\n<p>To simplify this even further, the <code>p5.Vector</code> class provides a method called <code>heading()</code>, which takes care of calling <code>atan2()</code> and returns the 2D direction angle, in radians, for any <code>p5.Vector</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">    // The easiest way to do this!\n    let angle = this.velocity.heading();</pre>\n<p>With <code>heading()</code>, it turns out you don’t actually need to implement the trigonometry functions in your code, but understanding how they’re all working is still helpful.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-34\">Exercise 3.4</h3>\n  <p>Create a simulation of a vehicle that you can drive around the screen by using the arrow keys: the left arrow accelerates the car to the left, and the right arrow accelerates to the right. The car should point in the direction in which it’s currently moving.</p>\n</div>\n<h2 id=\"polar-vs-cartesian-coordinates\">Polar vs. Cartesian Coordinates</h2>\n<div data-type=\"video-link\" data-title=\"Polar Coordinates\" href=\"https://www.youtube.com/watch?v=O5wjXoFrau4&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Anytime you draw a shape in p5.js, you have to specify a pixel position, a set of x- and y-coordinates. These are known as <strong>Cartesian coordinates</strong>, named for René Descartes, the French mathematician who developed the ideas behind Cartesian space.</p>\n<p>Another useful coordinate system, known as <strong>polar coordinates</strong>, describes a point in space as a distance from the origin (like the radius of a circle) and an angle of rotation around the origin (usually called <span data-type=\"equation\">\\theta</span>, the Greek letter theta). Thinking in terms of vectors, a Cartesian coordinate describes a vector’s x- and y-components, whereas a polar coordinate describes a vector’s magnitude (length) and direction (angle).</p>\n<p>When working in p5.js, you may find it more convenient to think in polar coordinates, especially when creating sketches that involve rotational or circular movements. However, p5.js’s drawing functions understand only (<em>x</em>,<em> y</em>) Cartesian coordinates. Happily for you, trigonometry holds the key to converting back and forth between polar and Cartesian (see Figure 3.9). This allows you to design with whatever coordinate system you have in mind, while always drawing using Cartesian coordinates.</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_9.png\" alt=\"Figure 3.9: The Greek letter \theta (theta) is often used to denote an angle. Since a polar coordinate is conventionally referred to as (r, \theta), I’ll use theta as a variable name when referring to an angle in p5.js.\">\n  <figcaption>Figure 3.9: The Greek letter <span data-type=\"equation\">\\theta</span> (theta) is often used to denote an angle. Since a polar coordinate is conventionally referred to as <span data-type=\"equation\">(r, \\theta)</span>, I’ll use <code>theta</code> as a variable name when referring to an angle in p5.js.</figcaption>\n</figure>\n<p>For example, given a polar coordinate with a radius of 75 pixels and an angle (<span data-type=\"equation\">\\theta</span>) of 45 degrees (or <span data-type=\"equation\">\\pi/4</span> radians), the Cartesian <em>x</em> and <em>y</em> can be computed as follows:</p>\n<div data-type=\"equation\">\\cos(\\theta) = x/r \\Rightarrow x = r \\times \\cos(\\theta)</div>\n<div data-type=\"equation\">\\sin(\\theta) = y / r \\Rightarrow y = r \\times \\sin(\\theta)</div>\n<p>The functions for sine and cosine in p5.js are <code>sin()</code> and <code>cos()</code>, respectively. Each takes one argument, a number representing an angle in radians. These formulas can thus be coded as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let r = 75;\nlet theta = PI / 4;\n// Convert from polar (<em>r</em>, <em>theta</em>) to Cartesian (<em>x</em>, <em>y</em>).\nlet x = r * cos(theta);\nlet y = r * sin(theta);</pre>\n<p>This type of conversion can be useful in certain applications. For instance, moving a shape along a circular path using Cartesian coordinates isn’t so easy. However, with polar coordinates, it’s simple: just increment the angle! Here’s how it’s done with global <code>r</code> and <code>theta</code> variables.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-34-polar-to-cartesian\">Example 3.4: Polar to Cartesian</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/qcnlfvP3q\" data-example-path=\"examples/03_oscillation/example_3_4_polar_to_cartesian\"><img src=\"/content/examples/03_oscillation/example_3_4_polar_to_cartesian/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let r;\nlet theta;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize all values.\n  r = height * 0.45;\n  theta = 0;\n}\n\nfunction draw() {\n  background(255);\n  // Translate the origin point to the center of the screen.\n  translate(width / 2, height / 2);\n  //{!2} Polar coordinates (<em>r</em>, <em>theta</em>) are converted to Cartesian (<em>x</em>, <em>y</em>) for use in the <code>circle()</code> function.\n  let x = r * cos(theta);\n  let y = r * sin(theta);\n  fill(127);\n  stroke(0);\n  line(0, 0, x, y);\n  circle(x, y, 48);\n  //{!1} Increase the angle over time.\n  theta += 0.02;\n}</pre>\n<div class=\"avoid-break\">\n  <p>Polar-to-Cartesian conversion is common enough that p5.js includes a handy function to take care of it for you. It’s included as a static method of the <code>p5.Vector</code> class called <code>fromAngle()</code>. It takes an angle in radians and creates a unit vector in Cartesian space that points in the direction specified by the angle. Here’s how that would look in Example 3.4:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  // Create a unit vector pointing in the direction of an angle.\n  let position = p5.Vector.fromAngle(theta);\n  // To complete polar-to-Cartesian conversion, scale <code>position</code> by <code>r</code>.\n  position.mult(r);\n  // Draw the circle by using the x- and y-components of the vector.\n  circle(position.x, position.y, 48);</pre>\n</div>\n<p>Are you amazed yet? I’ve demonstrated some pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates). I could stop right here and be satisfied. But I’m not going to. This is only the beginning. As I’ll show you next, what sine and cosine can do for you goes beyond mathematical formulas and right triangles.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-35\">Exercise 3.5</h3>\n  <p>Using Example 3.4 as a basis, draw a spiral path. Start in the center and move outward. Note that this can be done by changing only one line of code and adding one line of code!</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/qTs23wBBs\" data-example-path=\"examples/03_oscillation/exercise_3_5_spiral\"><img src=\"/content/examples/03_oscillation/exercise_3_5_spiral/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-36\">Exercise 3.6</h3>\n  <p>Simulate the spaceship in the game <em>Asteroids</em>. In case you aren’t familiar with <em>Asteroids</em>, here’s a brief description: A spaceship (represented as a triangle) floats in 2D space. The left arrow key turns the spaceship counterclockwise; the right arrow key turns it clockwise. The Z key applies a thrust force in the direction the spaceship is pointing. </p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/7jQEBLJhX\" data-example-path=\"examples/03_oscillation/exercise_3_6_asteroids\"><img src=\"/content/examples/03_oscillation/exercise_3_6_asteroids/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<h2 id=\"properties-of-oscillation\">Properties of Oscillation</h2>\n<div data-type=\"video-link\" data-title=\"Harmonic Motion\" href=\"https://www.youtube.com/watch?time_continue=52&#x26;v=m463X1cqV6s&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Take a look at the graph of the sine function in Figure 3.10, where <em>y</em> = sin(<em>x</em>).</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_10.png\" alt=\"Figure 3.10: A graph of y = sin(x)\">\n  <figcaption>Figure 3.10: A graph of <em>y</em> = sin(<em>x</em>)</figcaption>\n</figure>\n<p>The output of the sine function is a smooth curve alternating between –1 and 1, also known as a <strong>sine wave</strong>. This behavior, a periodic movement between two points, is the <strong>oscillation</strong> I mentioned at the start of the chapter. Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—all are examples of oscillating motion that can be modeled using the sine function.</p>\n<p>In a p5.js sketch, you can simulate oscillation by assigning the output of the sine function to an object’s position. I’ll begin with a basic scenario: I want a circle to oscillate between the left side and the right side of a canvas (Figure 3.11).</p>\n<figure>\n  <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/O8LMHH-Df\" data-example-path=\"examples/03_oscillation/example_3_5_simple_harmonic_motion\"><img src=\"/content/examples/03_oscillation/example_3_5_simple_harmonic_motion/screenshot.png\"></div>\n  <figcaption>Figure 3.11: An oscillating circle</figcaption>\n</figure>\n<p>This pattern of oscillating back and forth around a central point is known as <strong>simple harmonic motion</strong> (or, to be fancier, the periodic sinusoidal oscillation of an object). The code to achieve it is remarkably simple, but before I get into it, I’d like to introduce some of the key terminology related to oscillation (and waves).</p>\n<p>When a moving object exhibits simple harmonic motion, its position (in this case, the x-position) can be expressed as a function of time, with the following two elements:</p>\n<ul>\n  <li><strong>Amplitude:</strong> The distance from the center of motion to either extreme</li>\n  <li><strong>Period:</strong> The duration (time) for one complete cycle of motion</li>\n</ul>\n<p>To understand these terms, look again at the graph of the sine function in Figure 3.10. The curve never rises above 1 or below –1 along the y-axis, so the sine function has an amplitude of 1. Meanwhile, the wave pattern of the curve repeats every <span data-type=\"equation\">2\\pi</span> units along the x-axis, so the sine function’s period is <span data-type=\"equation\">2\\pi</span>. (By convention, the units here are radians, since the input value to the sine function is customarily an angle measured in radians.)</p>\n<p>So much for the amplitude and period of an abstract sine function, but what are amplitude and period in the p5.js world of an oscillating circle? Well, amplitude can be measured rather easily in pixels. For example, if the canvas is 200 pixels wide, I might choose to oscillate around the center of the canvas, going between 100 pixels right of center and 100 pixels left of center. In other words, the amplitude is 100 pixels.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The amplitude is measured in pixels.\nlet amplitude = 100;</pre>\n<p>The period is the amount of time for one complete cycle of an oscillation. However, in a p5.js sketch, what does <em>time</em> really mean? In theory, I could say I want the circle to oscillate every three seconds, then come up with an elaborate algorithm for moving the object according to real-world time, using <code>millis()</code> to track the passage of milliseconds. For what I’m trying to accomplish here, however, real-world time isn’t necessary. The more useful measure of time in p5.js is the number of <strong>frames</strong> that have elapsed, available through the built-in <code>frameCount</code> variable. Do I want the oscillating motion to repeat every 30 frames? Every 50 frames? For now, how about a period of 120 frames:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The period is measured in frames (the unit of time for animation).\nlet period = 120;</pre>\n<p>Once I have the amplitude and period, it’s time to write a formula to calculate the circle’s x-position as a function of time (the current frame count):</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// <code>amplitude</code> and <code>period</code> are my own variables; <code>frameCount</code> is built into p5.js.\nlet x = amplitude * sin(TWO_PI * frameCount / period);</pre>\n<p>Think about what’s going on here. First, whatever value the <code>sin()</code> function returns is multiplied by <code>amplitude</code>. As you saw in Figure 3.10, the output of the sine function oscillates between –1 and 1. Multiplying that value by my chosen amplitude—call it <em>a</em>—gives me the desired result: a value that oscillates between –<em>a</em> and <em>a</em>. (This is also a place where you could use p5.js’s <code>map()</code> function to map the output of <code>sin()</code> to a custom range.)</p>\n<p>Now, think about what’s inside the <code>sin()</code> function:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">TWO_PI * frameCount / period</pre>\n<p>What’s going on here? Start with what you know. I’ve explained that sine has a period of <span data-type=\"equation\">2\\pi</span>, meaning it will start at 0 and repeat at <span data-type=\"equation\">2\\pi</span>, <span data-type=\"equation\">4\\pi</span>, <span data-type=\"equation\">6\\pi</span>, and so on. If my desired period of oscillation is 120 frames, I want the circle to be in the same position when <code>frameCount</code> is at 120 frames, 240 frames, 360 frames, and so on. Here, <code>frameCount</code> is the only value changing over time; it starts at 0 and counts upward. Let’s take a look at what the formula yields as <code>frameCount</code> increases.</p>\n<table>\n  <thead>\n    <tr>\n      <th><code>frameCount</code></th>\n      <th><code>frameCount / period</code></th>\n      <th><code>TWO_PI * frameCount / period</code></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>60</td>\n      <td>0.5</td>\n      <td><span data-type=\"equation\">\\pi</span></td>\n    </tr>\n    <tr>\n      <td>120</td>\n      <td>1</td>\n      <td><span data-type=\"equation\">2\\pi</span></td>\n    </tr>\n    <tr>\n      <td>240</td>\n      <td>2</td>\n      <td><span data-type=\"equation\">4\\pi</span></td>\n    </tr>\n    <tr>\n      <td>. . .</td>\n      <td>. . .</td>\n      <td>. . .</td>\n    </tr>\n  </tbody>\n</table>\n<p>Dividing <code>frameCount</code> by <code>period</code> tells me the number of cycles that have been completed. (Is the wave halfway through the first cycle? Have two cycles completed?) Multiplying that number by <code>TWO_PI</code>, I get the desired result, an appropriate input to the <code>sin()</code> function, since <code>TWO_PI</code> is the value required for sine (or cosine) to complete one full cycle.</p>\n<p>Putting it together, here’s an example that oscillates the <code>x</code> position of a circle with an amplitude of 100 pixels and a period of 120 frames.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-35-simple-harmonic-motion-i\">Example 3.5: Simple Harmonic Motion I</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/O8LMHH-Df\" data-example-path=\"examples/03_oscillation/example_3_5_simple_harmonic_motion\"><img src=\"/content/examples/03_oscillation/example_3_5_simple_harmonic_motion/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let period = 120;\n  let amplitude = 200;\n  //{!1} Calculate the horizontal position according to the formula for simple harmonic motion.\n  let x = amplitude * sin(TWO_PI * frameCount / period);\n  stroke(0);\n  fill(127);\n  translate(width / 2, height / 2);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}</pre>\n<p>Before moving on, I would be remiss not to mention <strong>frequency</strong>, the number of cycles of an oscillation per time unit. Frequency is the inverse of the period—that is, 1 divided by the period. For example, if the period is 120 frames, only 1/120th of a cycle is completed in 1 frame, and so the frequency is 1/120. In Example 3.5, I chose to define the rate of oscillation in terms of the period, and therefore I didn’t need a variable for frequency. Sometimes, however, thinking in terms of frequency rather than period is more useful.</p>\n<p></p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-37\">Exercise 3.7</h3>\n  <p>Using the sine function, create a simulation of a weight (sometimes referred to as a <em>bob</em>) that hangs from a spring from the top of the window. Use the <code>map()</code> function to calculate the vertical position of the bob. In <a href=\"#spring-forces\" class=\"page-reference\">“Spring Forces”</a>, I’ll demonstrate how to create this same simulation by modeling the forces of a spring according to Hooke’s law.</p>\n</div>\n<h2 id=\"oscillation-with-angular-velocity\">Oscillation with Angular Velocity</h2>\n<p>An understanding of oscillation, amplitude, and period (or frequency) can be essential in the course of simulating real-world behaviors. However, there’s a slightly easier way to implement the simple harmonic motion from Example 3.5, one that achieves the same result with fewer variables. Take one more look at the oscillation formula:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x = amplitude * sin(TWO_PI * frameCount / period);</pre>\n<p>Now I’ll rewrite it in a slightly different way:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x = amplitude * sin( <strong>some value that increments slowly</strong> );</pre>\n<p>If you care about precisely defining the period of oscillation in terms of frames of animation, you might need the formula as I first wrote it. If you don’t care about the exact period, however—for example, if you’ll be choosing it randomly—all you really need inside the <code>sin()</code> function is a value that increments slowly enough for the object’s motion to appear smooth from one frame to the next. Every time this value ticks past a multiple of <span data-type=\"equation\">2\\pi</span>, the object will have completed one cycle of oscillation.</p>\n<p>This technique mirrors what I did with Perlin noise in <a href=\"/random#section-random\">Chapter 0</a>. In that case, I incremented an offset variable (which I called <code>t</code> or <code>xoff</code>) to sample various outputs from the <code>noise()</code> function, creating a smooth transition of values. Now, I’m going to increment a value (I’ll call it <code>angle</code>) that’s fed into the <code>sin()</code> function. The difference is that the output from <code>sin()</code> is a smoothly repeating sine wave, without any randomness.</p>\n<p>You might be wondering why I refer to the incrementing value as <code>angle</code>, given that the object has no visible rotation. The term <em>angle</em> is used because the value is passed into the <code>sin()</code> function, and angles are the traditional inputs to trigonometric functions. With this in mind, I can reintroduce the concept of angular velocity (and acceleration) to rewrite the example to calculate the <code>x</code> position in terms of a changing angle. I’ll assume these global variables:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let angle = 0;\nlet angleVelocity = 0.05;</pre>\n<p>I can then write this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  angle += angleVelocity;\n  let x = amplitude * sin(angle);\n}</pre>\n<p>Here <code>angle</code> is my “value that increments slowly,” and the amount it slowly increments by is <code>angleVelocity</code>.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-36-simple-harmonic-motion-ii\">Example 3.6: Simple Harmonic Motion II</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/gwdC8X-W-j\" data-example-path=\"examples/03_oscillation/example_3_6_simple_harmonic_motion_ii\"><img src=\"/content/examples/03_oscillation/example_3_6_simple_harmonic_motion_ii/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let angle = 0;\nlet angleVelocity = 0.05;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let amplitude = 200;\n  let x = amplitude * sin(angle);\n  //{!1} Use the concept of angular velocity to increment an angle variable.\n  angle += angleVelocity;\n  translate(width / 2, height / 2);\n  stroke(0);\n  fill(127);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}</pre>\n<p>Just because I’m not referencing the period directly doesn’t mean that I’ve eliminated the concept. After all, the greater the angular velocity, the faster the circle will oscillate (and therefore the shorter the period). In fact, the period is the number of frames it takes for <code>angle</code> to increment by <span data-type=\"equation\">2\\pi</span>. Since the amount <code>angle</code> increments is controlled by the angular velocity, I can calculate the period as follows:</p>\n<div data-type=\"equation\">\\text{period} = 2\\pi / \\text{angular velocity}</div>\n<p>To illustrate the power of thinking of oscillation in terms of angular velocity, I’ll expand the example a bit more by creating an <code>Oscillator</code> class whose objects can oscillate independently along both the x-axis (as before) <em>and</em> the y-axis. The class will need two angles, two angular velocities, and two amplitudes (one for each axis).</p>\n<p>This is a perfect opportunity to use <code>createVector()</code> to package each pair of values together! Unlike previous vectors, the values in these vectors won’t be sets of Cartesian coordinates. Nevertheless, the <code>p5.Vector</code> class provides a convenient way to manage pairs of values—in this case, pairs of angles (and their associated velocities, accelerations, and so on).</p>\n<div data-type=\"example\">\n  <h3 id=\"example-37-oscillator-objects\">Example 3.7: Oscillator Objects</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/b3HpgJa6F\" data-example-path=\"examples/03_oscillation/example_3_7_oscillator_objects\"><img src=\"/content/examples/03_oscillation/example_3_7_oscillator_objects/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Oscillator  {\n  constructor()  {\n    //{!1} Use a <code>p5.Vector</code> to track two angles!\n    this.angle = createVector();\n    //{!1.continue}\n    this.angleVelocity = createVector(random(-0.05, 0.05), random(-0.05, 0.05));\n    // Random velocities and amplitudes\n    this.amplitude = createVector(random(20, width / 2), random(20, height / 2));\n  }\n\n  update()  {\n    this.angle.add(this.angleVelocity);\n  }\n\n  show()  {\n    // Oscillating on the x-axis\n    let x = sin(this.angle.x) * this.amplitude.x;\n    //{!1} Oscillating on the y-axis\n    let y = sin(this.angle.y) * this.amplitude.y;\n    push();\n    translate(width / 2, height / 2);\n    stroke(0);\n    fill(127);\n    // Draw the oscillator as a line connecting a circle.\n    line(0, 0, x, y);\n    circle(x, y, 32);\n    pop();\n  }\n}</pre>\n<p>To better understand the <code>Oscillator</code> class, it might be helpful to focus on the movement of a single oscillator in the animation. First, observe its horizontal movement. You’ll notice that it oscillates regularly back and forth along the x-axis. Switching your focus to its vertical movement, you’ll see it oscillating up and down along the y-axis. Each oscillator has its own distinct rhythm, given the random initialization of its angle, angular velocity, and amplitude.</p>\n<p>The key is to recognize that the <code>x</code> and <code>y</code> properties of the <code>p5.Vector</code> objects <code>this.angle</code>, <code>this.angleVelocity</code>, and <code>this.amplitude</code> aren’t tied to spatial vectors anymore. Instead, they’re used to store the respective properties for two separate oscillations (one along the x-axis, one along the y-axis). Ultimately, these oscillations are manifested spatially when <code>x</code> and <code>y</code> are calculated in the <code>show()</code> method, mapping the oscillations onto the positions of the object.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-38\">Exercise 3.8</h3>\n  <p>Try initializing each <code>Oscillator</code> object with velocities and amplitudes that aren’t random to create some sort of regular pattern. Can you make the oscillators appear to be the legs of an insect-like creature?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-39\">Exercise 3.9</h3>\n  <p>Incorporate angular acceleration into the <code>Oscillator</code> object.</p>\n</div>\n<h2 id=\"waves\">Waves</h2>\n<div data-type=\"video-link\" data-title=\"Graphing Sine Wave\" href=\"https://www.youtube.com/watch?time_continue=218&#x26;v=JLAc9hMtcxk&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Imagine a single circle oscillating up and down according to the sine function. This is the equivalent of simulating a single point along the x-axis of a wave. With a little panache and a <code>for</code> loop, you can animate the entire wave by placing a series of oscillating circles next to one another (Figure 3.12).</p>\n<figure>\n  <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/qe6oK9F1o\" data-example-path=\"examples/03_oscillation/example_3_9_the_wave\"><img src=\"/content/examples/03_oscillation/example_3_9_the_wave/screenshot.png\"></div>\n  <figcaption>Figure 3.12: Animating the sine wave with oscillating circles</figcaption>\n</figure>\n<p>You could use this wavy pattern to design the body or appendages of a creature, or to simulate a soft surface (such as water). Let’s dive into how the code for this sketch works.</p>\n<p>Here, the same concepts of amplitude (the wave’s height) and period (the wave’s duration) come into play. However, when drawing the entire wave, the term <em>period</em> shifts its meaning from representing time to describing the width (in pixels) of a full wave cycle. The term for the spatial period (as opposed to the temporal period) of a wave is <strong>wavelength</strong>—the distance a wave travels to complete one full oscillation cycle. And just as with the previous oscillation example, you have the choice of computing the wave pattern according to a precise wavelength or by arbitrarily incrementing the angle value (<em>delta angle</em>) for each spot on the wave.</p>\n<p>I’ll go with the simpler case, incrementing the angle. I know I need three variables: an angle, a delta angle (analogous to the previous angular velocity), and an amplitude:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;</pre>\n<p>Then I’m going to loop through all the <code>x</code> values for each point on the wave. For now, I’ll put 24 pixels between adjacent <code>x</code> values. For each <code>x</code>, I’ll follow these three steps:</p>\n<ol>\n  <li>Calculate the y-position according to amplitude and the sine of the angle.</li>\n  <li>Draw a circle at the (<em>x</em>, <em>y</em>) position.</li>\n  <li>Increment the angle by the delta angle.</li>\n</ol>\n<p>The following example translates these steps into code.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-38-static-wave\">Example 3.8: Static Wave</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/CQ19Yw0iT\" data-example-path=\"examples/03_oscillation/example_3_8_static_wave\"><img src=\"/content/examples/03_oscillation/example_3_8_static_wave/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;\n\nfunction setup() {\n  createCanvas(640, 240);\n  background(255);\n  stroke(0);\n  fill(127, 127);\n  for (let x = 0; x &#x3C;= width; x += 24) {\n    // Step 1: Calculate the y-position according to the amplitude and sine of the angle.\n    let y = amplitude * sin(angle);\n    // Step 2: Draw a circle at the <code>(x, y)</code> position.\n    circle(x, y + height / 2, 48);\n    // Step 3: Increment the angle according to the delta angle.\n    angle += deltaAngle;\n  }\n}</pre>\n<p>What happens if you try different values for <code>deltaAngle</code>? Figure 3.13 shows some options.</p>\n<figure>\n  <div class=\"col-list\">\n    <div>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/S9l2FSS_M\" data-example-path=\"examples/03_oscillation/example_3_9_the_wave_a\"><img src=\"/content/examples/03_oscillation/example_3_9_the_wave_a/screenshot.png\"></div>\n    </div>\n    <div>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/0oH4O6Y0d\" data-example-path=\"examples/03_oscillation/example_3_9_the_wave_b\"><img src=\"/content/examples/03_oscillation/example_3_9_the_wave_b/screenshot.png\"></div>\n    </div>\n    <div>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/3msqsP8ZD\" data-example-path=\"examples/03_oscillation/example_3_9_the_wave_c\"><img src=\"/content/examples/03_oscillation/example_3_9_the_wave_c/screenshot.png\"></div>\n    </div>\n  </div>\n  <figcaption>Figure 3.13: Three sine waves with varying <code>deltaAngle</code> values (0.05, 0.2, and 0.6 from left to right)</figcaption>\n</figure>\n<p>Although I’m not precisely calculating the wavelength, you can see that the greater the change in angle, the shorter the wavelength. It’s also worth noting that as the wavelength decreases, it becomes more difficult to make out the wave since the vertical distance between the individual points increases.</p>\n<p>Notice that everything in Example 3.8 happens inside <code>setup()</code>, so the result is static. The wave never changes or undulates. Adding motion is a bit tricky. Your first instinct might be to say, “Hey, no problem, I’ll just put the <code>for</code> loop inside the <code>draw()</code> function and let <code>angle</code> continue incrementing from one cycle to the next.”</p>\n<p>That’s a nice thought, but it doesn’t work. If you try it out, the result will appear extremely erratic and glitchy. To understand why, look back at Example 3.8. The right edge of the wave doesn’t match the height of the left edge, so where the wave ends in one cycle of <code>draw()</code> can’t be where it starts in the next. Instead, you need a variable dedicated entirely to tracking the starting <code>angle</code> value in each frame of the animation. This variable (which I’ll call <code>startAngle</code>) increments at its own pace, controlling how much the wave progresses from one frame to the next.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-39-the-wave\">Example 3.9: The Wave</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/qe6oK9F1o\" data-example-path=\"examples/03_oscillation/example_3_9_the_wave\"><img src=\"/content/examples/03_oscillation/example_3_9_the_wave/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} A new global variable tracking the starting angle of the wave\nlet startAngle = 0;\nlet deltaAngle = 0.2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Each time through <code>draw()</code>, the angle that increments is set to <code>startAngle</code>.\n  let angle = startAngle;\n  for (let x = 0; x &#x3C;= width; x += 24) {\n    let y = map(sin(angle), -1, 1, 0, height);\n    stroke(0);\n    fill(127, 127);\n    circle(x, y, 48);\n    angle += deltaAngle;\n  }\n  // Increment the starting angle.\n  startAngle += 0.02;\n}</pre>\n<p>In this code example, the increment of <code>startAngle</code> is hardcoded to be <code>0.02</code>, but you may want to consider reusing <code>deltaAngle</code> or creating a second variable instead. By reusing <code>deltaAngle</code>, the spatial progression of the wave would be tied to the temporal one, possibly creating a more synchronized movement. Introducing a separate variable, perhaps called <code>startAngleVelocity</code>, would allow independent control of the speed of the wave. The term <em>velocity</em> is appropriate here since the start angle is changing over time.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-310\">Exercise 3.10</h3>\n  <p>Try using the Perlin noise function instead of sine or cosine to set the <code>y</code> values in Example 3.9.</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-311\">Exercise 3.11</h3>\n  <p>Encapsulate the wave-generating code into a <code>Wave</code> class, and create a sketch that displays two waves (with different amplitudes/periods), as shown in the following image. Try moving beyond plain circles and lines to visualize the wave in a more creative way. What about connecting the points by using <code>beginShape()</code>, <code>endShape()</code>, and <code>vertex()</code>?</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/pHZjnSDrR\" data-example-path=\"examples/03_oscillation/exercise_3_11_oop_wave\"><img src=\"/content/examples/03_oscillation/exercise_3_11_oop_wave/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-312\">Exercise 3.12</h3>\n  <div data-type=\"video-link\" data-title=\"Additive Waves\" href=\"https://youtu.be/okfZRl4Xw-c?si=Wc5YzC8gH2Z5pl47\"></div>\n  <p>To create more complex waves, you can add multiple waves together. Calculate the height (or <code>y</code>) values for several waves and add those values together to get a single <code>y</code> value. The result is a new wave that incorporates the characteristics of each individual wave.</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/lUxbHeeHLH\" data-example-path=\"examples/03_oscillation/exercise_3_12_additive_wave\"><img src=\"/content/examples/03_oscillation/exercise_3_12_additive_wave/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<h2 id=\"spring-forces\">Spring Forces</h2>\n<div data-type=\"video-link\" data-title=\"Spring Forces\" href=\"https://www.youtube.com/watch?time_continue=1&#x26;v=Rr-5HiXquhw&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_11.png\" alt=\"Figure 3.14: A spring with an anchor and bob\">\n    <figcaption>Figure 3.14: A spring with an anchor and bob</figcaption>\n  </figure>\n</div>\n<p>Exploring the mathematics of triangles and waves has been lovely, but perhaps you’re starting to miss Newton’s laws of motion and vectors. After all, the core of this book is about simulating the physics of moving bodies. In <a href=\"#properties-of-oscillation\" class=\"page-reference\">“Properties of Oscillation”</a>, I modeled simple harmonic motion by mapping a sine wave to a range of pixels on a canvas. Exercise 3.7 asked you to use this technique to create a simulation of a bob hanging from a spring with the <code>sin()</code> function. That kind of quick-and-dirty, one-line-of-code solution won’t do, however, if what you really want is a bob hanging from a spring that responds to other forces in the environment (wind, gravity, and so on). To achieve a simulation like that, you need to model the force of the spring by using vectors.</p>\n<p>I’ll consider a spring to be a connection between a movable<em> </em>bob (or weight) and a fixed anchor point (see Figure 3.14).</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_12.png\" alt=\"Figure 3.15: A spring’s extension (x) is the difference between its current length and its rest length.\">\n    <figcaption>Figure 3.15: A spring’s extension (<em>x</em>) is the difference between its current length and its rest length.</figcaption>\n  </figure>\n</div>\n<p>The force of the spring is a vector calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the formula in 1660. Hooke originally stated the law in Latin: “<em>Ut tensio, sic vis</em>,” or “As the extension, so the force.” Think of it this way:</p>\n<p><span class=\"highlight\">The force of the spring is directly proportional to the extension of the spring.</span></p>\n<p>The extension is a measure of how much the spring has been stretched or compressed: as shown in Figure 3.15, it’s the difference between the current length of the spring and the spring’s resting length (its equilibrium state). Hooke’s law therefore says that if you pull on the bob a lot, the spring’s force will be strong, whereas if you pull on the bob a little, the force will be weak.</p>\n<p>Mathematically, the law is stated as follows:</p>\n<div data-type=\"equation\">F_{spring} = -kx</div>\n<p>Here <em>k</em> is the <em>spring constant</em>. Its value scales the force, setting how elastic or rigid the spring is. Meanwhile, <em>x</em> is the extension, the current length minus the rest length.</p>\n<p>Now remember, force is a vector, so you need to calculate both magnitude and direction. For the code, I’ll start with the following three variables—two vectors for the anchor and bob positions, and one rest length:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Pick arbitrary values for the positions and rest length.\nlet anchor = createVector(0, 0);\nlet bob = createVector(0, 120);\nlet restLength = 100;</pre>\n<p>I’ll then use Hooke’s law to calculate the magnitude of the force. For that, I need <code>k</code> and <code>x</code>. Calculating <code>k</code> is easy; it’s just a constant, so I’ll make something up:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let k = 0.1;</pre>\n<p>Finding <code>x</code> is perhaps a bit more difficult. I need to know the difference between the current length and the rest length. The rest length is defined as the variable <code>restLength</code>. What’s the current length? The distance between the anchor and the bob. And how can I calculate that distance? How about the magnitude of a vector that points from the anchor to the bob? (Note that this is exactly the same process I employed to find the distance between objects for the purposes of calculating gravitational attraction in <a href=\"/forces#section-forces\">Chapter 2</a>.)</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} A vector pointing from the anchor to the bob gives you the current length of the spring.\nlet dir = p5.Vector.sub(bob, anchor);\nlet currentLength = dir.mag();\nlet x = currentLength - restLength;</pre>\n<p>Now that I’ve sorted out the elements necessary for the magnitude of the force (–<em>kx</em>), I need to figure out the direction, a unit vector pointing in the direction of the force. The good news is that I already have this vector. Right? Just a moment ago I asked the question, “How can I calculate that distance?” and I answered, “How about the magnitude of a vector that points from the anchor to the bob?” Well, that vector describes the direction of the force!</p>\n<p>Figure 3.16 shows that if you stretch the spring beyond its rest length, a force should pull it back toward the anchor. And if the spring shrinks below its rest length, the force should push it away from the anchor. The Hooke’s law formula accounts for this reversal of direction with the –1.</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_13.png\" alt=\"Figure 3.16: The spring force points in the opposite direction of the displacement.\">\n  <figcaption>Figure 3.16: The spring force points in the opposite direction of the displacement.</figcaption>\n</figure>\n<p>All I need to do now is set the magnitude of the vector used for the distance calculation. Let’s take a look at the code and rename that vector variable <code>force</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The magnitude of the spring force according to Hooke’s law\nlet k = 0.1;\nlet force = p5.Vector.sub(bob, anchor);\nlet currentLength = force.mag();\nlet x = currentLength - restLength;\n// Put it together: direction and magnitude!\nforce.setMag(-1 * k * x);</pre>\n<p>Now that I have the algorithm for computing the spring force, the question remains: What OOP structure should I use? This is one of those situations that has no one correct answer. Several possibilities exist, and the one I choose depends on my goals and personal coding style.</p>\n<p>Since I’ve been working all along with a <code>Mover</code> class, I’ll stick with this same framework. I’ll think of the <code>Mover</code> class as the spring’s bob. The bob needs <code>position</code>, <code>velocity</code>, and <code>acceleration</code> vectors to move about the canvas. Perfect—I have those already! And perhaps the bob experiences a gravity force via the <code>applyForce()</code> method. This leaves just one more step, applying the spring force:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bob;\n\nfunction setup() {\n  bob = new Bob();\n}\n\nfunction draw()  {\n  //{!2} Chapter 2’s make-up-a-gravity force\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  // Calculate and apply a spring force!\n  <strong>let springForce = _______________????\n  bob.applyForce(</strong><strong>spring</strong><strong>Force);</strong>\n  // The standard <code>update()</code> and <code>show()</code> methods\n  bob.update();\n  bob.show();\n}</pre>\n<p>One option would be to write all the spring-force code in the main <code>draw()</code> loop. But thinking ahead to when you might have multiple bob and spring connections, it would be wise to create an additional class, a <code>Spring</code> class. As shown in Figure 3.17, the <code>Bob</code> class keeps track of the bob’s movements; the <code>Spring</code> class keeps track of the spring’s anchor position and its rest length, and calculates the spring force on the bob.</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_14.png\" alt=\"Figure 3.17: The Spring class has anchor and rest length; the Bob class has position, velocity, and acceleration.\">\n  <figcaption>Figure 3.17: The <code>Spring</code> class has anchor and rest length; the <code>Bob</code> class has position, velocity, and acceleration.</figcaption>\n</figure>\n<p>This allows me to write a lovely sketch as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bob;\n// Add a <code>Spring</code> object.\n<strong>let spring;</strong>\n\nfunction setup() {\n  bob = new Bob();\n  spring = new Spring();\n}\n\nfunction draw()  {\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  //{!1} This new method in the <code>Spring</code> class will take care of computing the force of the spring on the bob.\n  <strong>spring.connect(bob);</strong>\n  bob.update();\n  bob.show();\n  spring.show();\n}</pre>\n<p>Think about how this compares to my first stab at gravitational attraction in Example 2.6, when I had separate <code>Mover</code> and <code>Attractor</code> classes. There, I wrote something like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  let force = attractor.attract(mover);\n  mover.applyForce(force);</pre>\n<p>The analogous situation with a spring might have been as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  let force = spring.connect(bob);\n  bob.applyForce(force);</pre>\n<p>Instead, in this example I have the following:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  spring.connect(bob);</pre>\n<p>What gives? Why don’t I need to call <code>applyForce()</code> on the bob? The answer, of course, is that I <em>do</em> need to call <code>applyForce()</code> on the bob. It’s just that instead of doing it in <code>draw()</code>, I’m demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the <code>connect()</code> method to call <code>applyForce()</code> on the bob internally:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  connect(bob) {\n    let force = <em>some fancy calculations</em>\n    // The <code>connect()</code> method takes care of calling <code>applyForce()</code> and therefore doesn’t have to return a vector to the calling area.\n    bob.applyForce(force);\n  }</pre>\n<p>Why do it one way with the <code>Attractor</code> class and another way with the <code>Spring</code> class? When I first discussed forces, showing all the forces being applied in the <code>draw()</code> loop was a clearer way to help you learn about force accumulation. Now that you’re more comfortable, perhaps it’s simpler to embed some of the details inside the objects themselves.</p>\n<p>Let’s take a look at the rest of the elements in the <code>Spring</code> class.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-310-a-spring-connection\">Example 3.10: A Spring Connection</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/HZOUeCe9p\" data-example-path=\"examples/03_oscillation/example_3_11_a_spring_connection\"><img src=\"/content/examples/03_oscillation/example_3_11_a_spring_connection/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Spring {\n  // The constructor initializes the anchor point and rest length.\n  constructor(x, y, length) {\n    // The spring’s anchor position\n    this.anchor = createVector(x, y);\n    // Rest length and spring constant variables\n    this.restLength = length;\n    this.k = 0.2;\n  }\n\n  // Calculate the spring force as an implementation of Hooke’s law.\n  connect(bob) {\n    // Get a vector pointing from the anchor to the bob position.\n    <strong>let force = p5.Vector.sub(bob.position, this.anchor);</strong>\n    // Calculate the displacement between distance and rest length. I’ll use the variable name <code>stretch</code> instead of <code>x</code> to be more descriptive. \n    <strong>let currentLength = force.mag();\n    let stretch = currentLength - this.restLength;</strong>\n    // Direction and magnitude together!\n    <strong>force.setMag(-1 * this.k * stretch);</strong>\n    // Call <code>applyForce()</code> right here!\n    bob.applyForce(force);\n  }\n\n  // Draw the anchor.\n  show() {\n    fill(127);\n    circle(this.anchor.x, this.anchor.y, 10);\n  }\n\n  //{!2.bottom-align} Draw the spring connection between the bob position and the anchor.\n  showLine(bob) {\n    stroke(0);\n    //{!2.continue}\n    line(bob.position.x, bob.position.y, this.anchor.x, this.anchor.y);\n  }\n}</pre>\n<p>The complete code for this example is available on the book’s website and incorporates two additional features: (1) the <code>Bob</code> class includes methods for mouse interactivity, allowing you to drag the bob around the window, and (2) the <code>Spring</code> class includes a method to constrain the connection’s length between a minimum and a maximum value.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-313\">Exercise 3.13</h3>\n  <p>Before running to see the example online, take a look at this <code>constrainLength</code> method and see if you can fill in the blanks:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">constrainLength(bob, minlen, maxlen) {\n  //{!1} A vector pointing from the bob to the anchor\n  let direction = p5.Vector.sub(<span class=\"blank\">bob.position</span>, <span class=\"blank\">this.anchor</span>);\n  let length = direction.mag();\n  //{!1} Is it too short?\n  if (length &#x3C; minlen) {\n    direction.setMag(<span class=\"blank\">minlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  //{!1} Is it too long?\n  } else if (length<span class=\"blank\"> > maxlen</span>) {\n    direction.setMag(<span class=\"blank\">maxlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  }\n}</pre>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-314\">Exercise 3.14</h3>\n  <p>Create a system of multiple bobs and spring connections. How about connecting a bob to another bob with no fixed anchor?</p>\n</div>\n<h2 id=\"the-pendulum\">The Pendulum</h2>\n<div data-type=\"video-link\" data-title=\"Simple Pendulum Simulation\" href=\"https://www.youtube.com/watch?v=NBWMtlbbOag\"></div>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_15.png\" alt=\"Figure 3.18: A pendulum with a pivot, arm, and bob\">\n    <figcaption>Figure 3.18: A pendulum with a pivot, arm, and bob</figcaption>\n  </figure>\n</div>\n<p>You might have noticed that in Example 3.10’s spring code, I never once used sine or cosine. Before you write off all this trigonometry stuff as a tangent, however, allow me to show an example of how it all fits together. Imagine a bob hanging from an anchor connected by a spring with a fully rigid connection that can be neither compressed nor extended. This idealized scenario describes a pendulum and provides an excellent opportunity to practice combining all that you’ve learned about forces and trigonometry.</p>\n<p>A <strong>pendulum</strong> is a bob suspended by an arm from a pivot (previously called the <em>anchor</em> in the spring). When the pendulum is at rest, it hangs straight down, as in Figure 3.18. If you lift up the pendulum at an angle from its resting state and then release it, however, it starts to swing back and forth, tracing the shape of an arc. A real-world pendulum would live in a 3D space, but I’m going to look at a simpler scenario: a pendulum in the 2D space of a p5.js canvas. Figure 3.19 shows the pendulum in a nonresting position and adds the forces at play: gravity and tension.</p>\n<p>When the pendulum swings, its arm and bob are essentially rotating around the fixed point of the pivot. If no arm connected the bob and the pivot, the bob would simply fall to the ground under the influence of gravity. Obviously, that isn’t what happens. Instead, the fixed length of the arm creates the second force—tension. However, I’m not going to work with this scenario according to these forces, at least not in the way I approached the spring scenario.</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_16.png\" alt=\"Figure 3.19: A pendulum showing \theta as the angle relative to its resting position\">\n    <figcaption>Figure 3.19: A pendulum showing <span data-type=\"equation\">\\theta</span> as the angle relative to its resting position</figcaption>\n  </figure>\n</div>\n<p>Instead of using <em>linear</em> acceleration and velocity, I’m going to describe the motion of the pendulum in terms of <em>angular</em> acceleration and <em>angular </em>velocity, which refer to the change of the arm’s angle <span data-type=\"equation\">\\theta</span> relative to the pendulum’s resting position. I should first warn you, especially if you’re a seasoned physicist, that I’m going to conveniently ignore several important concepts here: conservation of energy, momentum, centripetal force, and more. This isn’t intended to be a comprehensive description of pendulum physics. My goal is to offer you an opportunity to practice your new skills in trigonometry and further explore the relationship between forces and angles through a concrete example.</p>\n<p>To calculate the pendulum’s angular acceleration, I’m going to use Newton’s second law of motion but with a little trigonometric twist. Take a look at Figure 3.19 and tilt your head<br>so that the pendulum’s arm becomes the vertical axis. The force of gravity suddenly points askew, a little to the left—it’s at an angle with respect to your tilted head. If this is starting to hurt your neck, don’t worry. I’ll redraw the tilted figure and relabel the forces <span data-type=\"equation\">F_g</span> for gravity and <span data-type=\"equation\">T</span> for tension (Figure 3.20, left).</p>\n<p>Let’s now take the force of gravity and divide its vector into x- and y-components, with the arm as the new y-axis<em>.</em> These components form a right triangle, with the force of gravity as the hypotenuse (Figure 3.20, right). I’ll call them <span data-type=\"equation\">F_{gx}</span> and <span data-type=\"equation\">F_{gy}</span>, but what do these components mean? Well, the <span data-type=\"equation\">F_{gy}</span> component represents the force that’s opposite to <span data-type=\"equation\">T</span>, the tension force. Remember, the tension force is what keeps the bob from falling off.</p>\n<p>The other component, <span data-type=\"equation\">F_{gx}</span>, is perpendicular to the arm of the pendulum, and it’s the force I’ve been looking for all along! It causes the pendulum to rotate. As the pendulum swings, the y-axis (the arm) will always be perpendicular to the direction of motion. Therefore, I can ignore the tension and <span data-type=\"equation\">F_{gy}</span> forces and focus on <span data-type=\"equation\">F_{gx}</span>, which is the <strong>net force</strong> in the direction of motion. And because this force is part of a right triangle, I can calculate it with . . . you guessed it, trigonometry!</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_17.png\" alt=\"Figure 3.20: On the left, the pendulum is drawn rotated so that the arm is the y-axis. The right shows F_g zoomed in and divided into components F_{gx} and F_{gy}.\">\n  <figcaption>Figure 3.20: On the left, the pendulum is drawn rotated so that the arm is the y-axis. The right shows <span data-type=\"equation\">F_g</span> zoomed in and divided into components <span data-type=\"equation\">F_{gx}</span> and <span data-type=\"equation\">F_{gy}</span>.</figcaption>\n</figure>\n<p>The key here is that the top angle of the right triangle is the same as the angle <span data-type=\"equation\">\\theta</span> between the pendulum’s arm and its resting position. Just as I demonstrated in the discussion of polar coordinates, the sine and cosine functions allow me to separate out the components of the gravity force (the hypotenuse) according to this angle. For <span data-type=\"equation\">F_{gx}</span>, I need to use sine:</p>\n<div data-type=\"equation\">\\sin(\\theta) = F_{gx} / F_g</div>\n<p>Solving for <span data-type=\"equation\">F_{gx}</span>, I get this:</p>\n<div data-type=\"equation\">F_{gx} = F_g \\times \\sin(\\theta)</div>\n<p>I’ll now rename this force <span data-type=\"equation\">F_p</span> for <em>force of the pendulum</em>. In Figure 3.21, I’ve restored the diagram to its original orientation and relabeled the components. I’ve also moved the starting point of <span data-type=\"equation\">F_p</span> from the bottom of the right triangle to the bob’s center, to clarify how this force moves the bob.</p>\n<p>There it is. The net force of the pendulum that causes the rotation is calculated as follows:</p>\n<div data-type=\"equation\">F_p = F_g \\times \\sin(\\theta)</div>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_18.png\" alt=\"Figure 3.21: F_{gx} is now labeled F_p, the net force in the direction of motion.\">\n  <figcaption>Figure 3.21: <span data-type=\"equation\">F_{gx}</span> is now labeled <span data-type=\"equation\">F_p</span>, the net force in the direction of motion.</figcaption>\n</figure>\n<p>Lest you forget, however, my goal is to determine the angular acceleration of the pendulum. Once I have that, I’ll be able to apply the rules of motion to find a new angle <span data-type=\"equation\">\\theta</span> for each frame of the animation:</p>\n<div data-type=\"equation\">\\text{angular velocity} = \\text{angular velocity} + \\text{angular acceleration}</div>\n<div data-type=\"equation\">\\text{angle} = \\text{angle + angular velocity}</div>\n<p>The good news is that Newton’s second law establishes a relationship between force and acceleration—namely, <span data-type=\"equation\">F = M \\times A</span>, or <span data-type=\"equation\">A = F / M</span>. So if the force of the pendulum is equal to the force of gravity times the sine of the angle, then I have this:</p>\n<div data-type=\"equation\">\\text{pendulum angular acceleration} = \\text{acceleration due to gravity} \\times \\sin(\\theta)</div>\n<p>This is a good time for a reminder that the context here is creative coding and not pure physics. Yes, the acceleration due to gravity on Earth is 9.8 meters per second squared. But this number isn’t relevant in our world of pixels. Instead, I’ll use an arbitrary constant (called <code>gravity</code>) as a variable that scales the acceleration (incidentally, angular acceleration is usually written as <span data-type=\"equation\">\\alpha</span> so as to distinguish it from linear acceleration <span data-type=\"equation\">A</span>):</p>\n<div data-type=\"equation\">\\alpha = \\text{gravity} \\times \\sin(\\theta)</div>\n<p>Before I put everything together, there’s another detail I neglected to mention. Or really, lots of little details. Think about the pendulum arm for a moment. Is it a metal rod? A string? A rubber band? How is it attached to the pivot point? How long is it? What’s its mass? Is it a windy day? I could continue to ask a lot of questions that would affect the simulation. I choose to live, however, in a fantasy world, one where the pendulum’s arm is an idealized rod that never bends and where the mass of the bob is concentrated in a single, infinitesimally small point.</p>\n<p>Even though I prefer not to worry myself with all these questions, a critical piece is still missing, related to the calculation of angular acceleration. To keep the derivation of the pendulum’s angular acceleration simple, I assumed that the length of the pendulum’s arm is 1. In reality, however, the length of the pendulum’s arm affects the acceleration of the pendulum because of the concepts of torque and moment of inertia.</p>\n<p><strong>Torque </strong>(or <span data-type=\"equation\">\\tau</span>) is a measure of the rotational force acting on an object. In the case of a pendulum, torque is proportional to both the mass of the bob and the length of the arm (<span data-type=\"equation\">M \\times r</span>). The <strong>moment of inertia </strong>(or<strong> </strong><span data-type=\"equation\">I</span>) of a pendulum is a measure of the amount of difficulty in rotating the pendulum around the pivot point. It’s proportional to the mass of the bob and the <em>square</em> of the length of the arm (<span data-type=\"equation\">Mr^2</span>).</p>\n<p>Remember Newton’s second law, <span data-type=\"equation\">F=M \\times A</span>? Well, it has a rotational counterpart, <span data-type=\"equation\">\\tau = I \\times \\alpha</span>. By rearranging the equation to solve for the angular acceleration <span data-type=\"equation\">\\alpha</span>, I get <span data-type=\"equation\">\\alpha = \\tau/I</span>. Simplifying further, this becomes <span data-type=\"equation\">Mr/Mr^2</span> or <span data-type=\"equation\">1/r</span>. The angular acceleration doesn’t depend on the pendulum’s mass!</p>\n<p>This is just like Galileo’s Leaning Tower of Pisa experiment demonstrating linear acceleration, where different objects fell at the same rate, regardless of their mass. Here, once again, the mass of a bob doesn’t influence its angular acceleration—only the length of its arm does. Thus, the final formula becomes this:</p>\n<div data-type=\"equation\">\\alpha = \\frac{\\text{gravity} \\times \\sin(\\theta)}{r}</div>\n<p>Amazing! In the end, the formula is so simple that you might be wondering why I bothered going through the explanation at all. I mean, learning is great, but I could have easily just said, “Hey, the angular acceleration of a pendulum is a constant times the sine of the angle divided by the length of the arm.” That would be missing the point. The purpose of this book isn’t to learn how pendulums swing or gravity works. The point is to think creatively about how shapes can move around a screen in a computationally based graphics system. The pendulum is just a case study. If you can understand the approach to programming a pendulum, you can apply the same techniques to other scenarios, no matter how you choose to design your p5.js canvas world.</p>\n<p>Now, I’m not finished yet. I may be happy with my simple, elegant formula for angular acceleration, but I still have to apply it in code. This is an excellent opportunity to practice some OOP skills and create a <code>Pendulum</code> class. First, think about all the properties of a pendulum that I’ve mentioned:</p>\n<div class=\"avoid-break\">\n  <ul>\n    <li>Arm length</li>\n    <li>Angle</li>\n    <li>Angular velocity</li>\n    <li>Angular acceleration</li>\n  </ul>\n</div>\n<p>The <code>Pendulum</code> class needs all these properties too:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">class Pendulum  {\n  constructor() {\n    // Length of arm\n    this.r = ????;\n    // Pendulum arm angle\n    this.angle = ????;\n    // Angular velocity\n    this.angleVelocity = ????;\n    // Angular acceleration\n    this.angleAcceleration = ????;\n  } </pre>\n</div>\n<p>Next, I need to write an <code>update()</code> method to update the pendulum’s angle according to the formula:</p>\n<div class=\"snip-above snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    // An arbitrary constant\n    let gravity = 0.4;\n    // Calculate acceleration according to the formula.\n    this.angleAcceleration = -1 * gravity * sin(this.angle) / this.r;\n    // Increment the velocity.\n    this.angleVelocity += this.angleAcceleration;\n    // Increment the angle.\n    this.angle += this.angleVelocity;\n  }</pre>\n</div>\n<p>Note that the acceleration calculation now includes a multiplication by –1. When the pendulum is to the right of its resting position, the angle is positive, and so the sine of the angle is also positive. However, gravity should pull the bob back toward the resting position. Conversely, when the pendulum is to the left of its resting position, the angle is negative, and so its sine is negative too. In this case, the pulling force should be positive. Multiplying by –1 is necessary in both scenarios.</p>\n<p>Next, I need a <code>show()</code> method to draw the pendulum on the canvas. But where exactly should I draw it? How do I calculate the x- and y-coordinates (Cartesian!) for both the pendulum’s pivot point (let’s call it <code>pivot</code>) and bob position (let’s call it <code>bob</code>)? This may be getting a little tiresome, but the answer, yet again, is trigonometry, as shown in Figure 3.22.</p>\n<figure>\n  <img src=\"/content/images/03_oscillation/03_oscillation_19.png\" alt=\"Figure 3.22: The bob position relative to the pivot in polar and Cartesian coordinates\">\n  <figcaption>Figure 3.22: The bob position relative to the pivot in polar and Cartesian coordinates</figcaption>\n</figure>\n<p>First, I’ll need to add a <code>this.pivot</code> property to the constructor to specify where to draw the pendulum on the canvas:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.pivot = createVector(100, 10);</pre>\n<p>I know the bob should be a set distance away from the pivot, as determined by the arm length. That’s my variable <code>r</code>, which I’ll set now:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.r = 125;</pre>\n<p>I also know the bob’s current angle relative to the pivot: it’s stored in the variable <code>angle</code>. Between the arm length and the angle, what I have is a polar coordinate for the bob: <span data-type=\"equation\">(r,\\theta)</span>. What I really need is a Cartesian coordinate, but luckily I already know how to use sine and cosine to convert from polar to Cartesian. And so:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.bob = createVector(r * sin(this.angle), r * cos(this.angle));</pre>\n<p>Notice that I’m using <code>sin(this.angle)</code> for the <em>x</em> value and <code>cos(this.angle)</code> for the <em>y</em>. This is the opposite of what I showed you in <a href=\"#polar-vs-cartesian-coordinates\" class=\"page-reference\">“Polar vs. Cartesian Coordinates”</a>. The reason is that I’m now looking for the top angle of a right triangle pointing down, as depicted in Figure 3.21. This angle lives between the y-axis and the hypotenuse, instead of between the x-axis and the hypotenuse, as you saw earlier in Figure 3.9.</p>\n<p>Right now, the value of <code>this.bob</code> is assuming that the pivot is at point (0, 0). To get the bob’s position relative to wherever the pivot <em>actually</em> happens to be, I can just add <code>pivot</code> to the <code>bob</code> vector:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.bob.add(this.pivot);</pre>\n<p>Now all that remains is the little matter of drawing a line and a circle (you should be more creative, of course):</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">stroke(0);\nfill(127);\nline(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\ncircle(this.bob.x, this.bob.y, 16);</pre>\n<p>Finally, a real-world pendulum is going to experience a certain amount of friction (at the pivot point) and air resistance. As it stands, the pendulum would swing forever with the given code. To make it more realistic, I can slow the pendulum with a damping trick. I say <em>trick</em> because rather than model the resistance forces with some degree of accuracy (as I did in <a href=\"/forces#section-forces\">Chapter 2</a>), I can achieve a similar result simply by reducing the angular velocity by an arbitrary amount during each cycle. The following code reduces the velocity by 1 percent (or multiplies it by 0.99) for each frame of animation:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.angleVelocity *= 0.99;</pre>\n<p>Putting everything together, I have the following example (with the pendulum beginning at a 45-degree angle).</p>\n<div data-type=\"example\">\n  <h3 id=\"example-311-swinging-pendulum\">Example 3.11: Swinging Pendulum</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/MQZWruTlD\" data-example-path=\"examples/03_oscillation/example_3_10_swinging_pendulum\"><img src=\"/content/examples/03_oscillation/example_3_10_swinging_pendulum/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let pendulum;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Make a new <code>Pendulum</code> object with an origin position and arm length.\n  pendulum = new Pendulum(width / 2, 0, 175);\n}\n\nfunction draw() {\n  background(255);\n  pendulum.update();\n  pendulum.show();\n}\n\nclass Pendulum  {\n  constructor(x, y, r) {\n    //{!8} Many, many variables keep track of the pendulum’s various properties.\n    this.pivot = createVector(x, y); // Position of pivot\n    this.bob = createVector();       // Position of bob\n    this.r = r;                      // Length of arm\n    this.angle = PI / 4;             // Pendulum arm angle\n    this.angleVelocity = 0;          // Angle velocity\n    this.angleAcceleration = 0;      // Angle acceleration\n    this.damping = 0.99;             // Arbitrary damping\n    this.ballr = 24;                 // Arbitrary bob radius\n  }\n\n  update() {\n    let gravity = 0.4;\n    // Formula for angular acceleration\n    this.angleAcceleration = (-1 * gravity / this.r) * sin(this.angle);\n    // Standard angular motion algorithm\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    //{!1} Apply some damping.\n    this.angleVelocity *= this.damping;\n  }\n\n  show() {\n    // Apply polar-to-Cartesian conversion. Instead of creating a new vector each time, I’ll use <code>set()</code> to update the bob’s position.\n    this.bob.set(this.r * sin(this.angle), this.r * cos(this.angle));\n    this.bob.add(this.pivot);\n    // The arm\n    stroke(0);\n    line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\n    // The bob\n    fill(127);\n    circle(this.bob.x, this.bob.y, this.ballr * 2);\n  }\n}</pre>\n<p>On the book’s website, this example has additional code to allow the user to grab the pendulum and swing it with the mouse.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-315\">Exercise 3.15</h3>\n  <p>String together a series of pendulums so that the bob of one is the pivot point of another. Note that doing this may produce intriguing results but will be wildly inaccurate physically. Simulating an actual double pendulum requires sophisticated equations. You can read about them in the <a href=\"https://scienceworld.wolfram.com/physics/DoublePendulum.html\">Wolfram Research article on double pendulums</a> or <a href=\"https://thecodingtrain.com/doublependulum\">watch my video on coding a double pendulum</a>.</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/Nlw45LpMN\" data-example-path=\"examples/03_oscillation/exercise_3_15_double_pendulum\"><img src=\"/content/examples/03_oscillation/exercise_3_15_double_pendulum/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-316\">Exercise 3.16</h3>\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_20.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n  <p>Using trigonometry, how do you calculate the magnitude of the <strong>normal force</strong> depicted here (the force perpendicular to the incline on which the sled rests)? You can consider the magnitude of <span data-type=\"equation\">F_\\text{gravity}</span> to be a known constant. Look for a right triangle to help get you started. After all, the normal force is equal and opposite to a component of the force of gravity. If it helps to draw over the diagram and make more right triangles, go for it!</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-317\">Exercise 3.17</h3>\n  <p>Create a simulation of a box sliding down an incline with friction. Note that the magnitude of the friction force is proportional to the normal force, as discussed in the previous exercise.</p>\n</div>\n<div data-type=\"project\">\n  <h3 id=\"the-ecosystem-project-4\">The Ecosystem Project</h3>\n  <p>Take one of your creatures and incorporate oscillation into its motion. You can use the <code>Oscillator</code> class from Example 3.7 as a model. The <code>Oscillator</code> object, however, oscillates around a single point (the middle of the window). Try oscillating around a moving point.</p>\n  <p>In other words, design a creature that moves around the screen according to position, velocity, and acceleration. But that creature isn’t just a static shape; it’s an oscillating body. Consider tying the speed of oscillation to the speed of motion. Think of a butterfly’s flapping wings or the legs of an insect. Can you make it appear as though the creature’s internal mechanics (oscillation) drive its locomotion? See the book’s website for an additional example combining attraction from <a href=\"/forces#section-forces\">Chapter 2</a> with oscillation.</p>\n  <figure>\n    <img src=\"/content/images/03_oscillation/03_oscillation_21.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<p></p>\n</section>",
  "codeBlocks": [
    {
      "id": "code-0",
      "language": "javascript",
      "code": "let angle = 60;\nrotate(radians(angle));\n\nangleMode(DEGREES);\nrotate(angle);",
      "lineNumbers": false
    },
    {
      "id": "code-1",
      "language": "javascript",
      "code": "translate(width / 2, height / 2);\nrotate(angle);\nline(-60, 0, 60, 0);\ncircle(60, 0, 16);\ncircle(-60, 0, 16);\n\nangle = angle + 0.1;",
      "lineNumbers": true
    },
    {
      "id": "code-2",
      "language": "javascript",
      "code": "// Position\nlet angle = 0;\n// Velocity\nlet angleVelocity = 0;\n// Acceleration\nlet angleAcceleration = 0.0001;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  translate(width / 2, height / 2);\n  //{!1} Rotate according to that angle.\n  rotate(angle);\n  stroke(0);\n  fill(127);\n  line(-60, 0, 60, 0);\n  circle(60, 0, 16);\n  circle(-60, 0, 16);\n  // Angular equivalent of <code>velocity.add(acceleration)</code>\n  angleVelocity += angleAcceleration;\n  // Angular equivalent of <code>position.add(velocity)</code>\n  angle += angleVelocity;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-3",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    this.mass = 1.0;\n    // Variables for angular motion\n    this.angle = 0;\n    this.angleVelocity = 0;\n    this.angleAcceleration = 0;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-4",
      "language": "javascript",
      "code": "update() {\n    // Regular old-fashioned motion\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!2} Newfangled angular motion\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-5",
      "language": "javascript",
      "code": "show() {\n    stroke(0);\n    fill(175, 200);\n    // Use <code>push()</code> to save the current state so the rotation of this shape doesn’t affect the rest of the world.\n    push();\n    // Set the origin at the shape’s position.\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate by the angle.\n    rotate(this.angle);\n    circle(0, 0, this.radius * 2);\n    line(0, 0, this.radius, 0);\n    // Use <code>pop()</code> to restore the previous state after rotation is complete.\n    pop();\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-6",
      "language": "javascript",
      "code": "this.angleAcceleration = 0.01;",
      "lineNumbers": false
    },
    {
      "id": "code-7",
      "language": "javascript",
      "code": "// Use the x-component of the object’s linear acceleration to calculate angular acceleration.\n    this.angleAcceleration = this.acceleration.x;",
      "lineNumbers": false
    },
    {
      "id": "code-8",
      "language": "javascript",
      "code": "update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    //{!1} Calculate angular acceleration according to acceleration’s x-component.\n    this.angleAcceleration = this.acceleration.x / 10.0;\n    this.angleVelocity += this.angleAcceleration;\n    //{!1} Use <code>constrain()</code> to ensure that angular velocity doesn’t spin out of control.\n    this.angleVelocity = constrain(this.angleVelocity, -0.1, 0.1);\n    this.angle += this.angleVelocity;\n    this.acceleration.mult(0);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-9",
      "language": "javascript",
      "code": "show() {\n    //{!1} Solve for the angle by using <code>atan()</code>.\n    let angle = atan(this.velocity.y / this.velocity.x);\n    stroke(0);\n    fill(175);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-10",
      "language": "javascript",
      "code": "show() {\n    //{!1} Use <code>atan2()</code> to account for all possible directions.\n    let angle = atan2(this.velocity.y, this.velocity.x);\n    push();\n    rectMode(CENTER);\n    translate(this.position.x, this.position.y);\n    //{!1} Rotate according to that angle.\n    rotate(angle);\n    rect(0, 0, 30, 10);\n    pop();\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-11",
      "language": "javascript",
      "code": "// The easiest way to do this!\n    let angle = this.velocity.heading();",
      "lineNumbers": false
    },
    {
      "id": "code-12",
      "language": "javascript",
      "code": "let r = 75;\nlet theta = PI / 4;\n// Convert from polar (<em>r</em>, <em>theta</em>) to Cartesian (<em>x</em>, <em>y</em>).\nlet x = r * cos(theta);\nlet y = r * sin(theta);",
      "lineNumbers": false
    },
    {
      "id": "code-13",
      "language": "javascript",
      "code": "let r;\nlet theta;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize all values.\n  r = height * 0.45;\n  theta = 0;\n}\n\nfunction draw() {\n  background(255);\n  // Translate the origin point to the center of the screen.\n  translate(width / 2, height / 2);\n  //{!2} Polar coordinates (<em>r</em>, <em>theta</em>) are converted to Cartesian (<em>x</em>, <em>y</em>) for use in the <code>circle()</code> function.\n  let x = r * cos(theta);\n  let y = r * sin(theta);\n  fill(127);\n  stroke(0);\n  line(0, 0, x, y);\n  circle(x, y, 48);\n  //{!1} Increase the angle over time.\n  theta += 0.02;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-14",
      "language": "javascript",
      "code": "// Create a unit vector pointing in the direction of an angle.\n  let position = p5.Vector.fromAngle(theta);\n  // To complete polar-to-Cartesian conversion, scale <code>position</code> by <code>r</code>.\n  position.mult(r);\n  // Draw the circle by using the x- and y-components of the vector.\n  circle(position.x, position.y, 48);",
      "lineNumbers": true
    },
    {
      "id": "code-15",
      "language": "javascript",
      "code": "// The amplitude is measured in pixels.\nlet amplitude = 100;",
      "lineNumbers": false
    },
    {
      "id": "code-16",
      "language": "javascript",
      "code": "// The period is measured in frames (the unit of time for animation).\nlet period = 120;",
      "lineNumbers": false
    },
    {
      "id": "code-17",
      "language": "javascript",
      "code": "// <code>amplitude</code> and <code>period</code> are my own variables; <code>frameCount</code> is built into p5.js.\nlet x = amplitude * sin(TWO_PI * frameCount / period);",
      "lineNumbers": false
    },
    {
      "id": "code-18",
      "language": "javascript",
      "code": "TWO_PI * frameCount / period",
      "lineNumbers": false
    },
    {
      "id": "code-19",
      "language": "javascript",
      "code": "function setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let period = 120;\n  let amplitude = 200;\n  //{!1} Calculate the horizontal position according to the formula for simple harmonic motion.\n  let x = amplitude * sin(TWO_PI * frameCount / period);\n  stroke(0);\n  fill(127);\n  translate(width / 2, height / 2);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-20",
      "language": "javascript",
      "code": "let x = amplitude * sin(TWO_PI * frameCount / period);",
      "lineNumbers": false
    },
    {
      "id": "code-21",
      "language": "javascript",
      "code": "let x = amplitude * sin( <strong>some value that increments slowly</strong> );",
      "lineNumbers": false
    },
    {
      "id": "code-22",
      "language": "javascript",
      "code": "let angle = 0;\nlet angleVelocity = 0.05;",
      "lineNumbers": false
    },
    {
      "id": "code-23",
      "language": "javascript",
      "code": "function draw() {\n  angle += angleVelocity;\n  let x = amplitude * sin(angle);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-24",
      "language": "javascript",
      "code": "let angle = 0;\nlet angleVelocity = 0.05;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  let amplitude = 200;\n  let x = amplitude * sin(angle);\n  //{!1} Use the concept of angular velocity to increment an angle variable.\n  angle += angleVelocity;\n  translate(width / 2, height / 2);\n  stroke(0);\n  fill(127);\n  line(0, 0, x, 0);\n  circle(x, 0, 48);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-25",
      "language": "javascript",
      "code": "class Oscillator  {\n  constructor()  {\n    //{!1} Use a <code>p5.Vector</code> to track two angles!\n    this.angle = createVector();\n    //{!1.continue}\n    this.angleVelocity = createVector(random(-0.05, 0.05), random(-0.05, 0.05));\n    // Random velocities and amplitudes\n    this.amplitude = createVector(random(20, width / 2), random(20, height / 2));\n  }\n\n  update()  {\n    this.angle.add(this.angleVelocity);\n  }\n\n  show()  {\n    // Oscillating on the x-axis\n    let x = sin(this.angle.x) * this.amplitude.x;\n    //{!1} Oscillating on the y-axis\n    let y = sin(this.angle.y) * this.amplitude.y;\n    push();\n    translate(width / 2, height / 2);\n    stroke(0);\n    fill(127);\n    // Draw the oscillator as a line connecting a circle.\n    line(0, 0, x, y);\n    circle(x, y, 32);\n    pop();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-26",
      "language": "javascript",
      "code": "let angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;",
      "lineNumbers": false
    },
    {
      "id": "code-27",
      "language": "javascript",
      "code": "let angle = 0;\nlet deltaAngle = 0.2;\nlet amplitude = 100;\n\nfunction setup() {\n  createCanvas(640, 240);\n  background(255);\n  stroke(0);\n  fill(127, 127);\n  for (let x = 0; x <= width; x += 24) {\n    // Step 1: Calculate the y-position according to the amplitude and sine of the angle.\n    let y = amplitude * sin(angle);\n    // Step 2: Draw a circle at the <code>(x, y)</code> position.\n    circle(x, y + height / 2, 48);\n    // Step 3: Increment the angle according to the delta angle.\n    angle += deltaAngle;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-28",
      "language": "javascript",
      "code": "//{!1} A new global variable tracking the starting angle of the wave\nlet startAngle = 0;\nlet deltaAngle = 0.2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Each time through <code>draw()</code>, the angle that increments is set to <code>startAngle</code>.\n  let angle = startAngle;\n  for (let x = 0; x <= width; x += 24) {\n    let y = map(sin(angle), -1, 1, 0, height);\n    stroke(0);\n    fill(127, 127);\n    circle(x, y, 48);\n    angle += deltaAngle;\n  }\n  // Increment the starting angle.\n  startAngle += 0.02;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-29",
      "language": "javascript",
      "code": "// Pick arbitrary values for the positions and rest length.\nlet anchor = createVector(0, 0);\nlet bob = createVector(0, 120);\nlet restLength = 100;",
      "lineNumbers": false
    },
    {
      "id": "code-30",
      "language": "javascript",
      "code": "let k = 0.1;",
      "lineNumbers": false
    },
    {
      "id": "code-31",
      "language": "javascript",
      "code": "//{!1} A vector pointing from the anchor to the bob gives you the current length of the spring.\nlet dir = p5.Vector.sub(bob, anchor);\nlet currentLength = dir.mag();\nlet x = currentLength - restLength;",
      "lineNumbers": false
    },
    {
      "id": "code-32",
      "language": "javascript",
      "code": "// The magnitude of the spring force according to Hooke’s law\nlet k = 0.1;\nlet force = p5.Vector.sub(bob, anchor);\nlet currentLength = force.mag();\nlet x = currentLength - restLength;\n// Put it together: direction and magnitude!\nforce.setMag(-1 * k * x);",
      "lineNumbers": true
    },
    {
      "id": "code-33",
      "language": "javascript",
      "code": "let bob;\n\nfunction setup() {\n  bob = new Bob();\n}\n\nfunction draw()  {\n  //{!2} Chapter 2’s make-up-a-gravity force\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  // Calculate and apply a spring force!\n  <strong>let springForce = _______________????\n  bob.applyForce(</strong><strong>spring</strong><strong>Force);</strong>\n  // The standard <code>update()</code> and <code>show()</code> methods\n  bob.update();\n  bob.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-34",
      "language": "javascript",
      "code": "let bob;\n// Add a <code>Spring</code> object.\n<strong>let spring;</strong>\n\nfunction setup() {\n  bob = new Bob();\n  spring = new Spring();\n}\n\nfunction draw()  {\n  let gravity = createVector(0, 1);\n  bob.applyForce(gravity);\n  //{!1} This new method in the <code>Spring</code> class will take care of computing the force of the spring on the bob.\n  <strong>spring.connect(bob);</strong>\n  bob.update();\n  bob.show();\n  spring.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-35",
      "language": "javascript",
      "code": "let force = attractor.attract(mover);\n  mover.applyForce(force);",
      "lineNumbers": false
    },
    {
      "id": "code-36",
      "language": "javascript",
      "code": "let force = spring.connect(bob);\n  bob.applyForce(force);",
      "lineNumbers": false
    },
    {
      "id": "code-37",
      "language": "javascript",
      "code": "spring.connect(bob);",
      "lineNumbers": false
    },
    {
      "id": "code-38",
      "language": "javascript",
      "code": "connect(bob) {\n    let force = <em>some fancy calculations</em>\n    // The <code>connect()</code> method takes care of calling <code>applyForce()</code> and therefore doesn’t have to return a vector to the calling area.\n    bob.applyForce(force);\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-39",
      "language": "javascript",
      "code": "class Spring {\n  // The constructor initializes the anchor point and rest length.\n  constructor(x, y, length) {\n    // The spring’s anchor position\n    this.anchor = createVector(x, y);\n    // Rest length and spring constant variables\n    this.restLength = length;\n    this.k = 0.2;\n  }\n\n  // Calculate the spring force as an implementation of Hooke’s law.\n  connect(bob) {\n    // Get a vector pointing from the anchor to the bob position.\n    <strong>let force = p5.Vector.sub(bob.position, this.anchor);</strong>\n    // Calculate the displacement between distance and rest length. I’ll use the variable name <code>stretch</code> instead of <code>x</code> to be more descriptive. \n    <strong>let currentLength = force.mag();\n    let stretch = currentLength - this.restLength;</strong>\n    // Direction and magnitude together!\n    <strong>force.setMag(-1 * this.k * stretch);</strong>\n    // Call <code>applyForce()</code> right here!\n    bob.applyForce(force);\n  }\n\n  // Draw the anchor.\n  show() {\n    fill(127);\n    circle(this.anchor.x, this.anchor.y, 10);\n  }\n\n  //{!2.bottom-align} Draw the spring connection between the bob position and the anchor.\n  showLine(bob) {\n    stroke(0);\n    //{!2.continue}\n    line(bob.position.x, bob.position.y, this.anchor.x, this.anchor.y);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-40",
      "language": "javascript",
      "code": "constrainLength(bob, minlen, maxlen) {\n  //{!1} A vector pointing from the bob to the anchor\n  let direction = p5.Vector.sub(<span class=\"blank\">bob.position</span>, <span class=\"blank\">this.anchor</span>);\n  let length = direction.mag();\n  //{!1} Is it too short?\n  if (length < minlen) {\n    direction.setMag(<span class=\"blank\">minlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  //{!1} Is it too long?\n  } else if (length<span class=\"blank\"> > maxlen</span>) {\n    direction.setMag(<span class=\"blank\">maxlen</span>);\n    //{!1} Keep the position within the constraint.\n    bob.position = p5.Vector.add(<span class=\"blank\">this.anchor</span>, <span class=\"blank\">direction</span>);\n    bob.velocity.mult(0);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-41",
      "language": "javascript",
      "code": "class Pendulum  {\n  constructor() {\n    // Length of arm\n    this.r = ????;\n    // Pendulum arm angle\n    this.angle = ????;\n    // Angular velocity\n    this.angleVelocity = ????;\n    // Angular acceleration\n    this.angleAcceleration = ????;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-42",
      "language": "javascript",
      "code": "update() {\n    // An arbitrary constant\n    let gravity = 0.4;\n    // Calculate acceleration according to the formula.\n    this.angleAcceleration = -1 * gravity * sin(this.angle) / this.r;\n    // Increment the velocity.\n    this.angleVelocity += this.angleAcceleration;\n    // Increment the angle.\n    this.angle += this.angleVelocity;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-43",
      "language": "javascript",
      "code": "this.pivot = createVector(100, 10);",
      "lineNumbers": false
    },
    {
      "id": "code-44",
      "language": "javascript",
      "code": "this.r = 125;",
      "lineNumbers": false
    },
    {
      "id": "code-45",
      "language": "javascript",
      "code": "this.bob = createVector(r * sin(this.angle), r * cos(this.angle));",
      "lineNumbers": false
    },
    {
      "id": "code-46",
      "language": "javascript",
      "code": "this.bob.add(this.pivot);",
      "lineNumbers": false
    },
    {
      "id": "code-47",
      "language": "javascript",
      "code": "stroke(0);\nfill(127);\nline(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\ncircle(this.bob.x, this.bob.y, 16);",
      "lineNumbers": false
    },
    {
      "id": "code-48",
      "language": "javascript",
      "code": "this.angleVelocity *= 0.99;",
      "lineNumbers": false
    },
    {
      "id": "code-49",
      "language": "javascript",
      "code": "let pendulum;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Make a new <code>Pendulum</code> object with an origin position and arm length.\n  pendulum = new Pendulum(width / 2, 0, 175);\n}\n\nfunction draw() {\n  background(255);\n  pendulum.update();\n  pendulum.show();\n}\n\nclass Pendulum  {\n  constructor(x, y, r) {\n    //{!8} Many, many variables keep track of the pendulum’s various properties.\n    this.pivot = createVector(x, y); // Position of pivot\n    this.bob = createVector();       // Position of bob\n    this.r = r;                      // Length of arm\n    this.angle = PI / 4;             // Pendulum arm angle\n    this.angleVelocity = 0;          // Angle velocity\n    this.angleAcceleration = 0;      // Angle acceleration\n    this.damping = 0.99;             // Arbitrary damping\n    this.ballr = 24;                 // Arbitrary bob radius\n  }\n\n  update() {\n    let gravity = 0.4;\n    // Formula for angular acceleration\n    this.angleAcceleration = (-1 * gravity / this.r) * sin(this.angle);\n    // Standard angular motion algorithm\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    //{!1} Apply some damping.\n    this.angleVelocity *= this.damping;\n  }\n\n  show() {\n    // Apply polar-to-Cartesian conversion. Instead of creating a new vector each time, I’ll use <code>set()</code> to update the bob’s position.\n    this.bob.set(this.r * sin(this.angle), this.r * cos(this.angle));\n    this.bob.add(this.pivot);\n    // The arm\n    stroke(0);\n    line(this.pivot.x, this.pivot.y, this.bob.x, this.bob.y);\n    // The bob\n    fill(127);\n    circle(this.bob.x, this.bob.y, this.ballr * 2);\n  }\n}",
      "lineNumbers": true
    }
  ],
  "images": [
    "images/03_oscillation/03_oscillation_1.png",
    "images/03_oscillation/03_oscillation_2.png",
    "images/03_oscillation/03_oscillation_3.png",
    "images/03_oscillation/03_oscillation_4.png",
    "examples/03_oscillation/exercise_3_1_baton/screenshot.png",
    "examples/03_oscillation/example_3_1_angular_motion_using_rotate/screenshot.png",
    "examples/03_oscillation/example_3_2_forces_with_arbitrary_angular_motion/screenshot.png",
    "images/03_oscillation/03_oscillation_5.png",
    "images/03_oscillation/03_oscillation_6.png",
    "examples/03_oscillation/example_1_10_accelerating_towards_the_mouse/screenshot.png",
    "images/03_oscillation/03_oscillation_7.png",
    "images/03_oscillation/03_oscillation_8.png",
    "examples/03_oscillation/example_3_3_pointing_in_the_direction_of_motion/screenshot.png",
    "images/03_oscillation/03_oscillation_9.png",
    "examples/03_oscillation/example_3_4_polar_to_cartesian/screenshot.png",
    "examples/03_oscillation/exercise_3_5_spiral/screenshot.png",
    "examples/03_oscillation/exercise_3_6_asteroids/screenshot.png",
    "images/03_oscillation/03_oscillation_10.png",
    "examples/03_oscillation/example_3_5_simple_harmonic_motion/screenshot.png",
    "examples/03_oscillation/example_3_5_simple_harmonic_motion/screenshot.png",
    "examples/03_oscillation/example_3_6_simple_harmonic_motion_ii/screenshot.png",
    "examples/03_oscillation/example_3_7_oscillator_objects/screenshot.png",
    "examples/03_oscillation/example_3_9_the_wave/screenshot.png",
    "examples/03_oscillation/example_3_8_static_wave/screenshot.png",
    "examples/03_oscillation/example_3_9_the_wave_a/screenshot.png",
    "examples/03_oscillation/example_3_9_the_wave_b/screenshot.png",
    "examples/03_oscillation/example_3_9_the_wave_c/screenshot.png",
    "examples/03_oscillation/example_3_9_the_wave/screenshot.png",
    "examples/03_oscillation/exercise_3_11_oop_wave/screenshot.png",
    "examples/03_oscillation/exercise_3_12_additive_wave/screenshot.png",
    "images/03_oscillation/03_oscillation_11.png",
    "images/03_oscillation/03_oscillation_12.png",
    "images/03_oscillation/03_oscillation_13.png",
    "images/03_oscillation/03_oscillation_14.png",
    "examples/03_oscillation/example_3_11_a_spring_connection/screenshot.png",
    "images/03_oscillation/03_oscillation_15.png",
    "images/03_oscillation/03_oscillation_16.png",
    "images/03_oscillation/03_oscillation_17.png",
    "images/03_oscillation/03_oscillation_18.png",
    "images/03_oscillation/03_oscillation_19.png",
    "examples/03_oscillation/example_3_10_swinging_pendulum/screenshot.png",
    "examples/03_oscillation/exercise_3_15_double_pendulum/screenshot.png",
    "images/03_oscillation/03_oscillation_20.png",
    "images/03_oscillation/03_oscillation_21.png"
  ]
}