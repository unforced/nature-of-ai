{
  "id": "forces",
  "slug": "forces",
  "title": "2. Forces",
  "type": "chapter",
  "content": "\nChapter 2. Forces\n\n  \n    Don’t underestimate the Force.\n    \n      —Darth Vader\n    \n  \n\n\n\n  \n    \n    \n  \n  Calder installation at the New Gallery, Charles Hayden Memorial Library, MIT, Cambridge, MA, 1950 (photo by Ezra Stoller)\n  Alexander Calder was a 20th-century American artist known for his kinetic sculptures that balance form and motion. His “constellations” were sculptures consisting of interconnected shapes and wire that demonstrate tension, balance, and the ever-present pull of gravitational attraction.\n\nIn the final example of Chapter 1, I demonstrated how to calculate a dynamic acceleration based on a vector pointing from a circle on the canvas to the mouse position. The resulting motion resembled a magnetic attraction between shape and mouse, as if a force was pulling the circle in toward the mouse. In this chapter, I’ll detail the concept of a force and its relationship to acceleration. The goal, by the end of this chapter, is to build a simple physics engine and understand how objects move around a canvas, responding to a variety of environmental forces.\nA physics engine is a computer program (or code library) that simulates the behavior of objects in a physical environment. With a p5.js sketch, the objects are 2D shapes, and the environment is a rectangular canvas. Physics engines can be developed to be highly precise (requiring high-performance computing) or real time (using simple and fast algorithms). This chapter focuses on building a rudimentary physics engine, with an emphasis on speed and ease of understanding.\nForces and Newton’s Laws of Motion\n\nLet’s begin by taking a conceptual look at what it means to be a force in the real world. Just like the word vector, the term force can have a variety of meanings. It can indicate a powerful physical intensity, as in “They pushed the boulder with great force,” or a powerful influence, as in “They’re a force to be reckoned with!” The definition of force that I’m interested in for this chapter is more formal and comes from Sir Isaac Newton’s three laws of motion:\nA force is a vector that causes an object with mass to accelerate.\nHopefully, you recognize the first part of the definition: a force is a vector. Thank goodness you just spent a whole chapter learning what vectors are and how to program with them! I’ll start from there by explaining how Newton’s three laws of motion relate to what you already know about vectors; then I’ll illustrate the rest of the force definition as I go.\nNewton’s First Law\nNewton’s first law is commonly stated as follows:\nAn object at rest stays at rest, and an object in motion stays in motion.\nHowever, this is missing an important element related to forces. I could expand the definition by stating:\nAn object at rest stays at rest, and an object in motion stays in motion, at a constant speed and direction unless acted upon by an unbalanced force.\nWhen Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly 2,000 years old. It stated that if an object is moving, some sort of force is required to keep it moving. Unless that moving thing is being pushed or pulled, it will slow down or stop. This theory was borne out through observation of the world. For example, if you toss a ball, it falls to the ground and eventually stops moving, seemingly because the force of the toss is no longer being applied.\nThis older theory, of course, isn’t true. As Newton established, in the absence of any forces, no force is required to keep an object moving. When an object (such as the aforementioned ball) is tossed in Earth’s atmosphere, its velocity changes because of unseen forces such as air resistance and gravity. An object’s velocity will remain constant only in the absence of any forces or only if the forces that act on it cancel each other out, meaning the net force adds up to zero. This is often referred to as equilibrium (see Figure 2.1). The falling ball will reach a terminal velocity (which stays constant) once the force of air resistance equals the force of gravity.\n\n  \n  Figure 2.1: The toy mouse doesn’t move because all the forces cancel one another out (that is, they add up to a net force of zero).\n\nConsidering a p5.js canvas, I could restate Newton’s first law as follows:\nAn object’s velocity vector will remain constant if it’s in a state of equilibrium.\nIn other words, in a Mover class, the update() function shouldn’t apply any mathematical operations on the velocity vector unless a nonzero net force is present.\nNewton’s Third Law\nLet me set aside Newton’s second law (arguably the most important law for the purposes of this book) for a moment and move on to his third law. This law is often stated as follows:\nFor every action, there is an equal and opposite reaction.\nThe way this law is stated frequently causes confusion. For one, it sounds like one force causes another. Yes, if you push someone, that someone may actively decide to push you back. But this isn’t the action and reaction Newton’s third law has in mind.\nLet’s say you push against a wall. The wall doesn’t actively decide to push you back, and yet it still provides resistance with an equal force in the opposite direction. There’s no “origin” force. Your push simply includes both forces, referred to as an action/reaction pair. A better way of stating Newton’s third law might therefore be the following:\nForces always occur in pairs. The two forces are of equal strength but in opposite directions.\nThis still causes confusion because it sounds like these forces would always cancel each other out. This isn’t the case. Remember, the forces act on different objects. And just because the two forces are equal doesn’t mean that the objects’ movements are equal (or that the objects will stop moving).\nConsider pushing on a stationary truck. Although the truck is far more massive than you, a stationary truck (unlike a moving one) will never overpower you and send you flying backward. The force your hands exert on the truck is equal and opposite to the force exerted by the truck on your hands. The outcome depends on a variety of other factors. If the truck is small and parked on an icy street, you’ll probably be able to get it to move. On the other hand, if it’s very large and on a dirt road and you push hard enough (maybe even take a running start), you could injure your hand.\nAnd what if, as in Figure 2.2, you are wearing roller skates when you push on that truck?\n\n  \n  Figure 2.2: Demonstrating Newton’s third law of motion by pushing a heavy truck while wearing roller skates\n\n\n  You’ll accelerate away from the truck, sliding along the road while the truck stays put. Why do you slide but not the truck? For one, the truck has a much larger mass (which I’ll get into with Newton’s second law). Other forces are at work too—namely, the friction of the truck’s tires and your roller skates against the road.\n\nConsidering p5.js again, I could restate Newton’s third law as follows:\nIf you calculate a p5.Vector called f that represents a force of object A on object B, you must also apply the opposite force that object B exerts on object A. You can calculate this other force as p5.Vector.mult(f, -1).\n\n  You’ll soon see that in the world of coding simulation, it’s often not necessary to stay true to Newton’s third law. Sometimes, such as in the case of gravitational attraction between bodies (see Example\n  2.8), I’ll want to model equal and opposite forces in my example code. Other times, such as a scenario where I’ll say, “Hey, there’s some wind in the environment,” I’m not going to bother to model the force that a body exerts back on the air. In fact, I’m not going to bother modeling the air at all! Remember, the examples in this book are taking inspiration from the physics of the natural world for the purposes of creativity and interactivity. They don’t require perfect precision.\n\nNewton’s Second Law\nNow it’s time for the most important law for you, the p5.js coder: Newton’s second law. It’s stated as follows:\nForce equals mass times acceleration.\nOr:\n\\vec{F} = M \\times \\vec{A}\nWhy is this the most important law for this book? Well, let’s write it a different way:\n\\vec{A} = \\vec{F} / M\nAcceleration is directly proportional to force and inversely proportional to mass. Consider what this means if you’re pushed. The harder you’re pushed, the faster you’ll speed up or slow down (accelerate). On the other hand, the bigger you are, the less effective a force is at accelerating you!\n\n  Weight vs. Mass\n  Mass isn’t to be confused with weight. Mass is a measure of the amount of matter in an object (measured in kilograms). An object that has a mass of 1 kilogram on Earth would have a mass of 1 kilogram on the moon.\n  Weight, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, you can calculate weight as mass times the acceleration of gravity (w = m \\times g). Weight is measured in newtons, a unit that indicates the magnitude of the gravitational force. Because weight is tied to gravity, an object on the moon weighs one-sixth as much as it does on Earth.\n  Related to mass is density, which is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).\n\nIn the world of p5.js, what is mass anyway? Aren’t we dealing with pixels? Let’s start simple and say that in a pretend pixel world, all objects have a mass equal to 1. Anything divided by 1 equals itself, and so, in this simple world, we have this:\n\\vec{A} = \\vec{F}\nI’ve effectively removed mass from the equation, making the acceleration of an object equal to force. This is great news. After all, Chapter 1 described acceleration as the key to controlling the movement of objects in a canvas. I said that the position changes according to the velocity, and the velocity according to acceleration. Acceleration seemed to be where it all began. Now you can see that force is truly where it all begins.\nLet’s take the Mover class, with position, velocity, and acceleration:\nclass Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n  }\n}\nNow the goal is to be able to add forces to this object, with code like this:\nmover.applyForce(wind);\nOr like this:\nmover.applyForce(gravity);\nHere wind and gravity are p5.Vector objects. According to Newton’s second law, I could implement this applyForce() method as follows:\napplyForce(force) {\n  // Newton’s second law at its simplest\n  this.acceleration = force;\n}\nThis looks pretty good. After all, acceleration = force is a literal translation of Newton’s second law (in a world without mass). Nevertheless, this code has a pretty big problem, which I’ll quickly encounter when I return to my original goal: creating an object that responds to wind and gravity forces. Consider this code:\nmover.applyForce(wind);\nmover.applyForce(gravity);\nmover.update();\nImagine you’re the computer for a moment. First, you call applyForce() with wind, and so the Mover object’s acceleration is now assigned the wind vector. Second, you call applyForce() with gravity. Now the Mover object’s acceleration is set to the gravity vector. Finally, you call update(). What happens in update()? Acceleration is added to velocity:\nthis.velocity.add(this.acceleration);\nIf you run this code, you won’t see an error in the console, but zoinks! There’s a major problem. What’s the value of acceleration when it’s added to velocity? It’s equal to the gravity vector, meaning wind has been left out! Anytime applyForce() is called, acceleration is overwritten. How can I handle more than one force?\nForce Accumulation\nThe answer is that the forces must accumulate, or be added together. This is stated in the full definition of Newton’s second law itself, which I now confess to having simplified. Here’s a more accurate way to put it:\nNet force equals mass times acceleration.\nIn other words, acceleration is equal to the sum of all forces divided by mass. At any given moment, there might be 1, 2, 6, 12, or 303 forces acting on an object. As long as the object knows how to add them together (accumulate them), it doesn’t matter how many forces there are. The sum total will give you the object’s acceleration (again, ignoring mass). This makes perfect sense. After all, as you saw in Newton’s first law, if all the forces acting on an object add up to zero, the object experiences an equilibrium state (that is, no acceleration).\nI can now revise the applyForce() method to take force accumulation into account:\napplyForce(force) {\n  // Newton’s second law, but with force accumulation, adding all input forces to acceleration\n  this.acceleration.add(force);\n}\nI’m not finished just yet, though. Force accumulation has one more piece. Since I’m adding all the forces together at any given moment, I have to make sure that I clear acceleration (set it to 0) before each time update() is called. Consider a wind force for a moment. Sometimes wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all. For example, you might write code that creates a gust of wind when holding down the mouse:\nif (mouseIsPressed) {\n  let wind = createVector(0.5, 0);\n  mover.applyForce(wind);\n}\nWhen the mouse is released, the wind should stop, and according to Newton’s first law, the object should continue moving at a constant velocity. However, if I forget to reset acceleration to 0, the gust of wind will still be in effect. Even worse, it will add onto itself from the previous frame! Acceleration, in a time-based physics simulation, has no memory; it’s calculated based on the environmental forces present at any given moment (frame) in time. This is different from, say, position. An object must remember its previous location in order to move properly to the next.\nOne way to clear the acceleration for each frame is to multiply the acceleration vector by 0 at the end of update():\nupdate() {\n  this.velocity.add(this.acceleration);\n  this.position.add(this.velocity);\n  // Clear acceleration after it’s been applied.\n  this.acceleration.mult(0);\n}\nBeing able to accumulate and apply forces gets me closer to a working physics engine, but at this point I should note another detail that I’ve been glossing over, besides mass. That’s the time step, the rate at which the simulation updates. The size of the time step affects the accuracy and behavior of a simulation, which is why many physics engines incorporate the time step as a variable (often denoted as dt, which stands for delta time, or the change in time). For simplicity, I’m instead choosing to assume that every cycle through draw() represents one time step. This assumption may not be the most accurate, but it allows me to focus on the key principles of the simulation.\nI’ll let this assumption stand until Chapter 6, when I’ll examine the impact of different time steps while covering third-party physics libraries. Right now, though, I can and should address the massive elephant in the room that I’ve so far been ignoring: mass.\n\n  Exercise 2.1\n  Using forces, simulate a helium-filled balloon floating upward and bouncing off the top of a window. Can you add a wind force that changes over time, perhaps according to Perlin noise?\n  \n    \n      \n      \n    \n  \n\nFactoring In Mass\n\nNewton’s second law is really \\vec{F} = M \\times \\vec{A}, not \\vec{F} = \\vec{A}. How can I incorporate mass into the simulation? To start, it’s as easy as adding a this.mass instance variable to the Mover class, but I need to spend a little more time here because of another impending complication.\nFirst, though, I’ll add mass:\nclass Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    // Add mass as a number.\n    this.mass = ????;\n  }\n}\n\n  Units of Measurement\n  Now that I’m introducing mass, it’s important to make a quick note about units of measurement. In the real world, things are measured in specific units: two objects are 3 meters apart, the baseball is moving at a rate of 90 miles per hour, or this bowling ball\nhas a mass of 6 kilograms. Sometimes you do want to take real-world units into consideration. In this chapter, however, I’m going to stick with units of measurement in pixels (“These two circles are 100 pixels apart”) and frames of animation (“This circle is moving at a rate of 2 pixels per frame,” the aforementioned time step).\n  In the case of mass, p5.js doesn’t have any unit of measurement to use. How much mass is in any given pixel? You might enjoy inventing your own p5.js unit of mass to associate with those values, like “10 pixeloids” or “10 yurkles.”\n  For demonstration purposes, I’ll tie mass to pixels (the larger a circle’s diameter, the larger the mass). This will allow me to visualize the mass of an object, albeit inaccurately. In the real world, size doesn’t indicate mass. A small metal ball could have a much higher mass than a large balloon because of its higher density. And for two circular objects with equal density, I’ll also note that mass should be tied to the formula for the area of a circle: \\pi r^2. (This will be addressed in Exercise 2.11, and I’ll say more about \\pi and circles in Chapter 3.)\n\nMass is a scalar, not a vector, as it’s just one number describing the amount of matter in an object. I could get fancy and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is . . . um, I dunno . . . how about 10?”\nconstructor() {\n  this.position = createVector(random(width), random(height));\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n  this.mass = 10;\n}\nThis isn’t so great, since things become interesting only when I have objects with varying mass, but it’s enough to get us started. Where does mass come in? I need to divide force by mass to apply Newton’s second law to the object:\napplyForce(force) {\n  // Newton’s second law (with force accumulation and mass)\n  force.div(this.mass);\n  this.acceleration.add(force);\n}\nYet again, even though the code looks quite reasonable, it has a major problem. Consider the following scenario with two Mover objects, both being blown away by a wind force:\nlet moverA = new Mover();\nlet moverB = new Mover();\n\nlet wind = createVector(1, 0);\n\nmoverA.applyForce(wind);\nmoverB.applyForce(wind);\nAgain, imagine you’re the computer. Object moverA receives the wind force—(1, 0)—divides it by mass (10), and adds it to acceleration:\n\n  \n    \n      Action\n      Vector Components\n    \n  \n  \n    \n      moverA receives the wind force.\n      (1, 0)\n    \n    \n      moverA divides the wind force by a mass of 10.\n      (0.1, 0)\n    \n  \n\nNow you move on to object moverB. It also receives the wind force—(1, 0). Wait, hold on a second. What’s the value of the wind force? Taking a closer look, it’s actually now (0.1, 0)! Remember that when you pass an object (in this case, p5.Vector) into a function, you’re passing a reference to that object. It’s not a copy! So if a function makes a change to that object (which, in this case, it does by dividing by the mass), that object is permanently changed. But I don’t want moverB to receive a force divided by the mass of object moverA. I want it to receive the force in its original state—(1, 0). And so I must protect the original vector and make a copy of it before dividing by mass.\nFortunately, the p5.Vector class has a convenient method for making a copy: copy(). It returns a new p5.Vector object with the same data. And so I can revise applyForce() as follows:\napplyForce(force) {\n  //{!1} Make a copy of the vector before using it.\n  let f = force.copy();\n  //{!1} Divide the copy by mass.\n  f.div(this.mass);\n  this.acceleration.add(f);\n}\nLet’s take a moment to recap what I’ve covered so far. I’ve defined what a force is (a vector), and I’ve shown how to apply a force to an object (divide it by mass and add it to the object’s acceleration vector). What’s missing? Well, I have yet to figure out how to calculate a force in the first place. Where do forces come from?\n\n  Exercise 2.2\n  You could write applyForce() in another way, using the static method div() instead of copy(). Rewrite applyForce() by using the static method. For help with this exercise, review static methods in “Static vs. Nonstatic Methods”.\n  applyForce(force) {\n  let f = <span class=\"blank\">p5.Vector.div</span>(<span class=\"blank\">force</span>, <span class=\"blank\">this.mass</span>);\n  this.acceleration.add(f);\n}\n\nCreating Forces\nThis section presents two ways to create forces in a p5.js world:\n\n  Make up a force! After all, you’re the programmer, the creator of your world. There’s no reason you can’t just make up a force and apply it.\n  Model a force! Forces exist in the physical world, and physics textbooks often contain formulas for these forces. You can take these formulas and translate them into source code to model real-world forces in JavaScript.\n\nTo begin, I’ll focus on the first approach. The easiest way to make up a force is to just pick a number (or two numbers, really). Let’s start with simulating wind. How about a wind force that points to the right and is fairly weak? Assuming an object mover, the code would read as follows:\nlet wind = createVector(0.01, 0);\nmover.applyForce(wind);\nThe result isn’t terribly interesting but is a good place to start. I create a p5.Vector object, initialize it, and pass it into a Mover object (which in turn will apply it to its own acceleration). To finish off this example, I’ll add one more force, gravity (pointing down), and engage the wind force only when the mouse is pressed.\n\n  Example 2.1: Forces\n  \n    \n    Clicking the mouse applies the wind force.\n  \n\nlet gravity = createVector(0, 0.1);\nmover.applyForce(gravity);\n\nif (mouseIsPressed) {\n  let wind = createVector(0.1, 0);\n  mover.applyForce(wind);\n}\nNow I have two forces, pointing in different directions and with different magnitudes, both applied to the object mover. I’m beginning to get somewhere. I’ve built a world, an environment with forces that act on objects!\nLet’s look at what happens now when I add a second object with a variable mass. To do this, you’ll probably want to do a quick review of OOP. Again, I’m not covering all the basics of programming here (for that, you can check out any of the intro p5.js books or video tutorials listed in “The Coding Train Connection”). However, since the idea of creating a world filled with objects is fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.\nThis is where I left the Mover class. Notice that it’s identical to the Mover class created in Chapter 1, with two additions, mass and a new applyForce() method:\nclass Mover {\n  constructor() {\n    //{!1} For now, set the mass equal to 1 for simplicity.\n    this.mass = 1;\n    this.position = createVector(width / 2, 30);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n  }\n\n  // Newton’s second law\n  applyForce(force) {\n    // Receive a force, divide by mass, and add to acceleration.\n    let f = p5.Vector.div(force, this.mass);\n    this.acceleration.add(f);\n  }\n\n  update() {\n    // Motion 101 from Chapter 1\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    // Now add clearing the acceleration each time!\n    this.acceleration.mult(0);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // Scale the size according to mass. Stay tuned for an improvement on this to come later in the chapter!\n    circle(this.position.x, this.position.y, this.mass * 16);\n  }\n\n  // Somewhat arbitrarily, I’ve decided that an object bounces when it hits the edges of the canvas.\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = width;\n      this.velocity.x *= -1;\n    } else if (this.position.x < 0) {\n      this.velocity.x *= -1;\n      this.position.x = 0;\n    }\n\n    if (this.position.y > height) {\n      // Even though I said not to touch position and velocity directly, exceptions exist. Here, I’m doing so as a quick way to reverse the direction of the object when it reaches the edge.\n      this.velocity.y *= -1;\n      this.position.y = height;\n    }\n  }\n}\n\n  Now that the class is written, I can create more than one Mover object:\n  let moverA = new Mover();\nlet moverB = new Mover();\n\nBut there’s an issue. Look again at the Mover object’s constructor:\nconstructor() {\n  //{!2} Every object has a mass of 1 and a position of (width / 2, 30).\n  this.mass = 1;\n  this.position = createVector(width / 2, 30);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}\nRight now, every Mover object is made exactly the same way. What I want are Mover objects of variable mass that start at variable positions. A nice way to accomplish this is with constructor arguments:\nconstructor(x, y, mass) {\n  //{!2} Now set these variables with arguments.\n  this.mass = mass;\n  this.position = createVector(x, y);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}\nNotice that the mass and position are no longer set to hardcoded numbers, but rather are initialized via the x, y, and mass arguments passed to the constructor. This means I can create a variety of Mover objects—big ones, small ones, ones that start on the left side of the canvas, ones that start on the right, and everywhere in between:\n// A large mover on the left side of the canvas\nlet moverA = new Mover(100, 30, 10);\n// A smaller mover on the right side of the canvas\nlet moverB = new Mover(400, 30, 2);\nI could choose to initialize the values in all sorts of ways (random, Perlin noise, in a grid, and so on). Here I’ve just picked some numbers for demonstration purposes. I’ll introduce other techniques for initializing a simulation throughout this book.\nOnce the objects are declared and initialized, the rest of the code follows as before. For each object, pass the forces in the environment to applyForce() and enjoy the show!\n\n  Example 2.2: Forces Acting on Two Objects\n  \n    \n    Clicking the mouse applies the wind force.\n  \n\nfunction draw() {\n  background(255);\n\n  // Make up a gravity force and apply it.\n  let gravity = createVector(0, 0.1);\n  moverA.applyForce(gravity);\n  moverB.applyForce(gravity);\n  // Make up a wind force and apply it when the mouse is clicked.\n  if (mouseIsPressed) {\n    let wind = createVector(0.1, 0);\n    moverA.applyForce(wind);\n    moverB.applyForce(wind);\n  }\n\n  moverA.checkEdges();\n  moverA.update();\n  moverA.show();\n\n  moverB.checkEdges();\n  moverB.update();\n  moverB.show();\n}\nNotice that every operation in the code is written twice, once for moverA and once for moverB. In practice, an array would make more sense than separate variables to manage multiple Mover objects, particularly as their number increases. That way, I’d have to write each operation only once and use a loop to apply it to each Mover in the array. I’ll demonstrate this later in the chapter and cover arrays in greater detail in Chapter 4.\n\n  Exercise 2.3\n  Instead of objects bouncing off the edge of the wall, create an example that includes an invisible force pushing back on the objects to keep them in the window. Can you weight the force according to the object’s distance from an edge so that the closer it is, the stronger the force?\n\n\n  Exercise 2.4\n  Fix the bouncing off the sides of the canvas so that the circle changes direction when its edge hits the side, rather than its center.\n\n\n  Exercise 2.5\n  Create a wind force that’s variable. Can you make it interactive? For example, think of a fan located where the mouse is and pointed toward the circles.\n\nWhen you run the code in Example 2.2, notice that the small circle responds more dramatically to the forces applied to it than the large one. This is because of the formula acceleration = force divided by mass. Mass is in the denominator, so the larger it is, the smaller the acceleration. This makes sense for the wind force—the more massive an object, the harder it should be for the wind to push it around—but is it accurate for a simulation of Earth’s gravitational pull?\nIf you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one would hit the ground first? According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same time. Why? I’ll dive deeper into this shortly, but the quick answer is that even though the force of gravity is calculated relative to an object’s mass—so that the bigger the object, the stronger the force—that force is canceled out when you divide by the mass to determine the acceleration. Therefore, the acceleration of gravity for different objects is equal.\nA quick fix to the sketch—one that moves a step closer to realistically modeling a force rather than simply making up a force—is to implement this scaling by multiplying the gravity force by mass.\n\n  Example 2.3: Gravity Scaled by Mass\n  \n    \n    Clicking the mouse applies the wind force.\n  \n\n// Made-up gravity force\nlet gravity = createVector(0, 0.1);\n// Scale by mover A’s mass.\nlet gravityA = p5.Vector.mult(gravity, moverA.mass);\nmoverA.applyForce(gravityA);\n// Scale by mover B’s mass.\nlet gravityB = p5.Vector.mult(gravity, moverB.mass);\nmoverB.applyForce(gravityB);\nThe objects now fall at the same rate. I’m still basically making up the gravity force by arbitrarily setting it to 0.1, but by scaling the force according to the object’s mass, I’m making it up in a way that’s a little truer to Earth’s actual force of gravitational attraction. Meanwhile, because the strength of the wind force is independent of mass, the smaller circle still accelerates to the right more quickly when the mouse is pressed. (The online code for this example also includes a solution to Exercise 2.4, with the addition of a radius variable in the Mover class.)\nModeling a Force\nMaking up forces will actually get you quite far—after all, I just made up a pretty good approximation of Earth’s gravity. Ultimately, the world of p5.js is an orchestra of pixels, and you’re the conductor, so whatever you deem appropriate to be a force, well by golly, that’s the force it should be! Nevertheless, there may come a time when you find yourself wondering, “But how does it all really work?” That’s when modeling forces, instead of just making them up, enters the picture.\n\n  Parsing Formulas\n  In a moment, I’m going to write out the formula for friction. This won’t be the first time\nyou’ve seen a formula in this book; I just finished up the discussion of Newton’s second law, \\vec{F} = M \\times \\vec{A} (or force equals mass times acceleration). You hopefully didn’t spend a lot\nof time worrying about that formula, because it’s just a few characters and symbols. Nevertheless, it’s a scary world out there. Just take a look at the equation for a normal distribution, which I covered (without presenting the formula) in “A Normal Distribution of Random Numbers”:\n  \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\n  Formulas are regularly written with many symbols (often with letters from the Greek alphabet). Here’s the formula for friction (as indicated by \\vec{f}):\n  \\vec{f} = -\\mu N \\hat{v}\n  If it’s been a while since you’ve looked at a formula from a math or physics textbook, three key points are important to cover before I move on:\n  \n    Evaluate the right side; assign to the left side. This is just like in code! In the preceding case, the left side represents what I want to calculate—the force of friction—and the right side elaborates on how to do it.\n    Am I talking about a vector or a scalar? It’s important to realize that in some cases, you’ll be calculating a vector; in others, a scalar. For example, in this case, the force of friction is a vector. That is indicated by the arrow above the f. It has a magnitude and direction. The right side of the equation also has a vector, as indicated by the symbol \\hat{v}, which in this case stands for the velocity unit vector.\n    When symbols are placed next to each other, this typically means multiply them. The right side of the friction formula has four elements: –, μ, N, and \\hat{v}. They should be multiplied together, reading the formula as \\vec{f} = -1 \\times \\mu \\times N \\times \\hat{v}.\n  \n\n\n  Open up any high school physics textbook and you’ll find diagrams and formulas describing various forces—gravity, electromagnetism, friction, tension, elasticity, and more. For the rest of this chapter, I’m going to consider three forces—friction, drag, and gravitational attraction—and show how to model them with p5.js. The point I’d like to make here is not that these are fundamental forces that you always need in your simulations. Rather, I want to demonstrate these forces as case studies for the following process:\n  \n    Understanding the concept behind a force\n    Deconstructing the force’s formula into two parts:\n      \n        How do you compute the force’s direction?\n        How do you compute the force’s magnitude?\n      \n    \n    Translating that formula into p5.js code that calculates a vector to be passed through a Mover object’s applyForce() method\n  \n\nIf you can follow these steps with the example forces I’ll provide here, then hopefully when you find yourself googling atomic nuclei weak nuclear force at 3 AM, you’ll have the skills to take what you find and adapt it for p5.js.\nFriction\n\nLet’s begin with friction and follow the preceding steps. Whenever two surfaces come into contact, they experience friction. Friction is a dissipative force, meaning it causes the kinetic energy of an object to be converted into another form, giving the impression of loss, or dissipation.\nLet’s say you’re driving a car. When you press your foot on the brake pedal, the car’s brakes use friction to slow the motion of the tires. Kinetic energy (motion) is converted into thermal energy (heat). A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for simplicity here, I’m going to work through only the kinetic case. Figure 2.3 shows the formula for friction.\nSince friction is a vector, let me separate this formula into two parts that determine the direction of friction as well as its magnitude. Figure 2.3 indicates that friction points in the opposite direction of velocity. In fact, that’s the part of the formula that says -1 \\times \\hat{v}, or –1 times the velocity unit vector. In p5.js, this would mean taking an object’s velocity vector and multiplying it by -1:\nlet friction = this.velocity.copy();\nfriction.normalize();\n// Let’s figure out the direction of the friction force\n// (a unit vector in the opposite direction of velocity).\nfriction.mult(-1);\nNotice two additional steps here. First, it’s important to make a copy of the velocity vector, as I don’t want to reverse the object’s direction by accident. Second, the vector is normalized. This is because the magnitude of friction isn’t associated with the speed of the object, and I want to start with a vector of length 1 so it can easily be scaled.\n\n  \n  Figure 2.3: Friction is a force that points in the opposite direction of the sled’s velocity when the sled is sliding in contact with the hill.\n\nAccording to the formula, the magnitude is \\mu \\times N. The Greek letter mu (\\mu, pronounced mew) is used here to describe the coefficient of friction. The coefficient of friction establishes the strength of a friction force for a particular surface. The higher it is, the stronger the friction; the lower, the weaker. A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper. Since this is a pretend p5.js world, I can arbitrarily set the coefficient to scale the strength of the friction:\nlet c = 0.01;\nNow for the second part. N refers to the normal force, the force perpendicular to the object’s motion along a surface. Think of a vehicle driving along a road. The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road, in turn, pushes back against the vehicle. That’s the normal force. The greater the gravitational force, the greater the normal force.\nAs you’ll see in the next section, gravitational attraction is associated with mass, and so a lightweight sports car would experience less friction than a massive tractor trailer truck. In Figure 2.3, however, because the object is moving along a surface at an angle, computing the magnitude and direction of the normal force is a bit more complex because it doesn’t point in the opposite direction of gravity. You’d need to know something about angles and trigonometry.\nAll of these specifics are important; however, a “good enough” simulation can be achieved without them. I can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1. When I get into trigonometry in the next chapter, you could return to this question and make the friction example more sophisticated. And so:\nlet normal = 1;\nNow that I have the magnitude and direction for friction, I can put it all together in code:\nlet c = 0.1;\nlet normal = 1;\n//{!1} Calculate the magnitude of friction (really just an arbitrary constant).\nlet frictionMag = c * normal;\nlet friction = mover.velocity.copy();\nfriction.mult(-1);\nfriction.normalize();\n// Take the unit vector and multiply it by the magnitude. This is the force vector!\nfriction.mult(frictionMag);\nThis code calculates a friction force but doesn’t answer the question of when to apply it. There’s no answer to this question, of course, given this is all a made-up world visualized in a 2D p5.js canvas! I’ll make the arbitrary, but logical, decision to apply friction when the circle comes into contact with the bottom of the canvas, which I can detect by adding a function to the Mover class, called contactEdge():\ncontactEdge() {\n  // The mover is touching the edge when it’s within 1 pixel.\n  return (this.position.y > height - this.radius - 1);\n}\nThis is a good time for me to also mention that the actual bouncing off the edge here simulates an idealized elastic collision, meaning no kinetic energy is lost when the circle and the edge collide. This is rarely true in the real world; pick up a tennis ball and drop it against any surface, and the height at which it bounces will slowly lower until it rests against the ground. Many factors are at play here (including air resistance, which I’ll cover in the next section), but a quick way to simulate an inelastic collision is to reduce the magnitude of velocity by a percentage with each bounce:\n\n  bounceEdges() {\n  //{!1} A new variable to simulate an inelastic collision: 10% of the velocity’s x- or y-component is lost.\n  let bounce = -0.9;\n  if (this.position.y > height - this.radius) {\n    this.position.y = height - this.radius;\n    this.velocity.y *= bounce;\n  }\n}\n\nFinally, I can add all these pieces to the code from Example 2.3 and simulate the object experiencing three forces: wind (when the mouse is clicked), gravity (always), and now friction (when in contact with the bottom of the canvas).\n\n  Example 2.4: Including Friction\n  \n    \n    Clicking the mouse applies the wind force.\n  \n\nfunction draw() {\n  background(255);\n\n  let gravity = createVector(0, 1);\n  //{!1} I should scale by mass to be more accurate, but this example has only one circle.\n  mover.applyForce(gravity);\n  if (mouseIsPressed) {\n    let wind = createVector(0.5, 0);\n    mover.applyForce(wind);\n  }\n\n  if (mover.contactEdge()) {\n    <strong>let c = 0.1;\n    let friction = mover.velocity.copy();\n    friction.mult(-1);\n    friction.setMag(c);</strong>\n    // Apply the friction force vector to the object.\n    <strong>mover.applyForce(friction);</strong>\n  }\n\n  //{!1} Call the new <code>bounceEdges()</code> method.\n  mover.bounceEdges();\n  mover.update();\n  mover.show();\n\n}\nRunning this example, you’ll notice that the circle eventually comes to rest. You can make this happen more or less quickly by varying the coefficient of friction as well as the percentage of speed lost in the bounceEdges() method.\n\n  Exercise 2.6\n  Add a second object to Example 2.4. How do you handle having two objects of different masses? What if each object has its own coefficient of friction relative to the bottom surface? Does it make sense to encapsulate the friction force calculation into a Mover method?\n\n\n  Exercise 2.7\n  Instead of wind, can you add functionality to this example that allows you to toss the circle via mouse interaction?\n\nAir and Fluid Resistance\n\nFriction also occurs when a body passes through a liquid or gas. The resulting force has many names, all really meaning the same thing: viscous force, drag force, air resistance, or fluid resistance (see Figure 2.4).\nThe effect of a drag force is ultimately the same as the effect in our previous friction examples: the object slows down. The exact behavior and calculation of a drag force is a bit different, however. Here’s the formula:\n\\vec{F_d} = - \\frac{1}{2}\\rho{v}^2 A C_d\\hat{v}\n\n  \n  Figure 2.4: A drag force (air or fluid resistance) is proportional to the speed of an object and its surface area pointing in the opposite direction of the object’s velocity.\n\nLet me break this down to see what’s really necessary for an effective simulation in p5.js, making a simpler formula in the process:\n\n  \\vec{F_d} refers to drag force, the vector to compute and pass into the applyForce() method.\n  –1/2 is a constant: –0.5. While it’s an important factor to scale the force, it’s not terribly relevant here, as I’ll be making up values for other scaling constants. However, the fact that it’s negative is important, as it indicates that the force points in the opposite direction of velocity (just as with friction).\n  \\rho is the Greek letter rho, another constant that refers to the density of the liquid. I’ll choose to ignore this at the moment and consider it to have a constant value of 1.\n  v refers to the speed of the moving object. Okay, you’ve got this one! The object’s speed is the magnitude of the velocity vector: velocity.mag(). And v^2 just means v squared, or v \\times v. (I’ll note that this assumes the liquid or gas is stationary and not moving; if you drop an object into a flowing river, you’d have to also take the relative speed of the water into account.)\n  A refers to the frontal surface area of the object that’s pushing through the liquid or gas. Consider a flat sheet of paper falling through the air and compare it to a sharp pencil pointed straight down. The pencil will experience less drag because it has less surface area pointing in its direction of motion. Again, this is a constant, and to keep the implementation simple, I’ll consider all objects to have a spherical shape and ignore this element.\n  C_d is the coefficient of drag, exactly the same as the coefficient of friction (μ). This constant will determine the relative strength of the drag force.\n  \\hat{v} should look familiar. It’s the velocity unit vector, found with velocity.normalize(). Just like friction, drag is a force that points in the opposite direction of velocity.\n\nNow that I’ve analyzed each of these parts and determined what’s needed for my simulation, I can reduce the formula, as shown in Figure 2.5.\n\n  \n  Figure 2.5: My simplified formula for a drag force\n\nWhile I’ve written the simplified formula with C_d as the lone constant representing the coefficient of drag, I can also think of it as all the constants combined (-1/2, \\rho, A). A more sophisticated simulation might treat these constants separately; you could try factoring them in as an exercise.\nHere’s the p5.js version of the simplified drag formula:\nlet c = 0.1;\nlet speed = this.velocity.mag();\n//{!1} Part 1 of the formula (magnitude)\nlet dragMagnitude = c * speed * speed;\nlet drag = this.velocity.copy();\n// Part 2 of the formula (direction)\ndrag.mult(-1);\n// Magnitude and direction together!\ndrag.setMag(dragMagnitude);\nLet’s implement this force in the Mover example. But when should I apply it? Earlier, I enabled the friction force to slow the mover whenever it came into contact with the bottom edge of the canvas. Now, I’ll introduce a new element to the environment: a Liquid object that exerts a drag force when the mover passes through it. The “liquid” will be drawn as a rectangle, with position, width, and height, and will have a coefficient of drag that sets whether it’s easy for objects to move through it (like air) or difficult (like molasses). In addition, Liquid will include a show() method so we can see the liquid on the canvas:\nclass Liquid {\n  constructor(x, y, w, h, c) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    // The <code>Liquid</code> object includes a variable defining its coefficient of drag.\n    this.c = c;\n  }\n\n  show() {\n    noStroke();\n    fill(175);\n    rect(this.x, this.y, this.w, this.h);\n  }\n}\nNow the sketch needs a liquid variable, initialized in setup(). I’ll place the liquid in the bottom half of the canvas:\nlet liquid;\n\nfunction setup() {\n  // Initialize a <code>Liquid</code> object.  I’m choosing a low coefficient (0.1) for a weaker effect. Try a stronger one!\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}\nNow comes an interesting question: How does the Mover object talk to the Liquid object? I want to implement the following:\n\n  When a mover passes through a liquid, that mover experiences a drag force.\n\nTranslating that into object-oriented speak:\n// If the liquid contains the mover, apply the drag force.\nif (liquid.contains(mover)) {\n  let dragForce = liquid.calculateDrag(mover);\n  mover.applyForce(dragForce);\n} \nThis code serves as instructions for what I need to add to the Liquid class: (1) a contains() method that determines whether a Mover object is inside the Liquid object’s area, and (2) a drag() method that calculates and returns the appropriate drag force to be applied to the Mover.\nThe first is easy; I can use a Boolean expression to determine whether the position vector rests inside the rectangle defined by the liquid:\ncontains(mover) {\n  // Store <code>position</code> in a separate variable to make the code more readable.\n  let pos = mover.position;\n  // This Boolean expression determines whether the position vector is contained within the rectangle defined by the <code>Liquid</code> class.\n  return (pos.x > this.x && pos.x < this.x + this.w && \n          pos.y > this.y && pos.y < this.y + this.h);\n}\nThe calculateDrag() method is pretty easy too: I basically already wrote the code for it when I implemented the simplified drag formula! The drag force is equal to the coefficient of drag multiplied by the speed of the mover squared, in the opposite direction of velocity:\ncalculateDrag(mover) {\n  let speed = mover.velocity.mag();\n  // Calculate the force’s magnitude.\n  let dragMagnitude = this.c * speed * speed;\n  // Calculate the force’s direction.\n  let dragForce = mover.velocity.copy();\n  dragForce.mult(-1);\n  // Finalize the force: set the magnitude and direction together.\n  dragForce.setMag(dragMagnitude);\n  // Return the force.\n  return dragForce;\n}\nWith these two methods added to the Liquid class, I’m ready to put all the code together! In the following example, I’ll expand the code to use an array of evenly spaced Mover objects in order to demonstrate how the drag force behaves with objects of variable mass. This also illustrates an alternate way to initialize a simulation other than randomly. Look for 40 + i * 70 in the code. An initial offset of 40 provides a small margin from the edge of the canvas, and i * 70 uses the index of the object to evenly space the movers. The margin and multiplier are arbitrary; you might try other values or consider other ways to calculate the spacing based on the canvas dimensions.\n\n  Example 2.5: Fluid Resistance\n  \n    \n    Clicking the mouse resets the sketch.\n  \n\nlet movers = [];\nlet liquid;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize an array of <code>Mover</code> objects.\n  for (let i = 0; i < 9; i++) {\n    // Use a random mass for each one.\n    let mass = random(0.1, 5);\n    // The x-values are spaced out evenly according to <code>i</code>.\n    movers[i] = new Mover(40 + i * 70, 0, mass);\n  }\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}\n\nfunction draw() {\n  background(255);\n\n  // Draw the liquid.\n  liquid.show();\n\n  for (let i = 0; i < movers.length; i++) {\n    // Is the mover in the liquid?\n    if (liquid.contains(movers[i])) {\n      // Calculate the drag force.\n      let dragForce = liquid.drag(movers[i]);\n      // Apply the drag force to the mover.\n      movers[i].applyForce(dragForce);\n    }\n\n    // Gravity is scaled by mass here!\n    let gravity = createVector(0, 0.1 * movers[i].mass);\n    // Apply gravity.\n    movers[i].applyForce(gravity);\n    // Update and display the mover.\n    movers[i].update();\n    movers[i].show();\n    movers[i].checkEdges();\n  }\n}\nRunning the example, you may notice that it appears to simulate objects falling into water. The objects slow down only when crossing through the gray area at the bottom of the window (representing the liquid). You’ll also notice that the smaller objects slow down a great deal more than the larger objects. Remember Newton’s second law? Acceleration equals force divided by mass (\\vec{A} = \\vec{F} / M), so a massive object will accelerate less, and a smaller object will accelerate more. In this case, the acceleration is the slowing down due to drag. The smaller objects slow down at a greater rate than the larger ones.\n\n  Exercise 2.8\n  You might notice that if you set the coefficient of drag too high in Example 2.5, the circles may bounce off of the liquid! This is due to the inaccuracy of the large time steps that I mentioned earlier in this chapter. A drag force will cause an object to stop but never to reverse direction. How can you use the vector limit() method to correct this issue? You might also try dropping the objects from variable heights. How does this affect the drag as they hit the liquid?\n\n\n  Exercise 2.9\n  The original formula for drag included surface area. Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?\n\n\n  Exercise 2.10\n  In addition to drag being a force in opposition to the velocity vector, a drag force can be perpendicular. Known as lift-induced drag, this will cause an airplane with an angled wing to rise in altitude. Try creating a simulation of lift.\n\nGravitational Attraction\n\n\n  \n    \n    Figure 2.6: The gravitational force between two bodies is proportional to the mass of those bodies and inversely proportional to the square of the distance between them.\n  \n\nProbably the most famous force of all is gravitational attraction. We humans on Earth think of gravity as stuff falling down, like an apple hitting Sir Isaac Newton on the head. But this is only our experience of gravity. The reality is more complicated.\nIn truth, just as Earth pulls the apple toward it because of a gravitational force, the apple pulls Earth as well (this is Newton’s third law). Earth is just so freaking massive that it overwhelms all the other gravity interactions. In fact, every object with mass exerts a gravitational force on every other object. The formula for calculating the strengths of these forces is depicted in Figure 2.6.\nLet’s examine this formula a bit more closely:\n\n  \\vec{F_g} refers to the gravitational force, the vector to compute and pass into the applyForce() method.\n  G is the universal gravitational constant, which in our world equals 6.67428 \\times 10^{-11} meters cubed per kilogram per second squared. This is a pretty important number if you’re a human being, but it’s not so important if you’re a shape wandering around a p5.js canvas. Again, it’s a constant that can be used to scale the forces in the world, making them stronger or weaker. Just setting it equal to 1 and ignoring it isn’t such a terrible choice either.\n  m_1 and m_2 are the masses of objects 1 and 2. As I initially did with Newton’s second law (\\vec{F} = M \\times \\vec{A}), mass is also something I could choose to ignore. After all, shapes drawn onscreen don’t have a physical mass. However, if you keep track of this value, you can create more interesting simulations in which “bigger” objects exert a stronger gravitational force than “smaller” ones.\n  \\hat{r} refers to the unit vector pointing from object 1 to object 2. As you’ll see in a moment, this direction vector can be computed by subtracting the position of one object from the other.\n  r^2 is the distance between the two objects squared.\n\nTake a moment to think about this formula. With everything on the top of the formula—G, m_1, m_2—the bigger its value, the stronger the force. Big mass, big force. Big G, big force. For r^2 on the bottom, however, it’s the opposite: the bigger the value (the farther away the object), the weaker the force. Mathematically, the strength of the gravitational force is inversely proportional to the distance squared.\nNow it’s time to figure out how to translate this formula into p5.js code. For that, I’ll make the following assumptions:\n\n  There are two objects.\n  Each object has a position: position1 and position2.\n  Each object has a mass: mass1 and mass2.\n  The variable G represents the universal gravitational constant.\n\n\n  \n    \n    Figure 2.7: An acceleration vector pointing toward the mouse position\n  \n\nGiven these assumptions, I want to compute a vector, the force of gravity. I’ll do it in two parts. First, I’ll compute the direction of the force (\\hat{r} in the formula). Second, I’ll calculate the strength of the force according to the masses and distance.\nRemember in Chapter 1, when I created an object accelerating toward the mouse (see Figure 2.7)? As I showed then, a vector can be thought of as the difference between two points, so to calculate a vector pointing from the circle to the mouse, I subtracted one point from another:\nlet direction = p5.Vector.sub(mouse, position);\nNow I can do the same thing to calculate \\hat{r}. The direction of the attraction force that object 1 exerts on object 2 is equal to the following:\nlet direction = p5.Vector.sub(position1, position2);\ndirection.normalize();\nDon’t forget that since I want a unit vector, a vector that indicates direction only, it’s important to normalize the vector after subtracting the positions. (Later, I might skip this step and use setMag() instead.)\nNow that I have the direction of the force, I need to compute its magnitude and scale the vector accordingly:\nlet magnitude = (G * mass1 * mass2) / (distance * distance);\ndir.mult(magnitude);\n\n  \n    \n    Figure 2.8: A vector that points from one position to another is calculated as the difference between positions.\n  \n\nThe only problem is that I don’t know the distance. The values of G, mass1, and mass2 are all givens, but I need to calculate distance before the preceding code will work. But wait, didn’t I just make a vector that points all the way from one object’s position to the other? The length of that vector should be the distance between the two objects (see Figure 2.8).\nIndeed, if I add one more line of code and grab the magnitude of that vector before normalizing it, I’ll have the distance. And this time, I’ll skip the normalize() step and use setMag():\n// The vector that points from one object to another\nlet force = p5.Vector.sub(position2, position1);\n// The length (magnitude) of that vector is the distance between the two objects.\nlet distance = force.mag();\n// Use the formula for gravity to compute the strength of the force.\nlet magnitude = (G * mass1 * mass2) / (distance * distance);\n// Normalize and scale the force vector to the appropriate magnitude.\nforce.setMag(magnitude);\nNote that I also changed the name of the direction vector to force. After all, when the calculations are finished, the vector I started with ends up being the actual force vector I wanted all along.\nNow that I’ve worked out the math and code for calculating an attractive force (emulating gravitational attraction), let’s turn our attention to applying this technique in the context of an actual p5.js sketch. I’ll continue to use the Mover class as a starting point—a template for making objects with position, velocity, and acceleration vectors, as well as an applyForce() method. I’ll take this class and put it in a sketch with the following:\n\n  A single Mover object\n  A single Attractor object (a new class that will have a fixed position)\n\nThe Mover object will experience a gravitational pull toward the Attractor object, as illustrated in Figure 2.9.\n\n  \n  Figure 2.9: One mover and one attractor. The mover experiences a gravitational force toward the attractor.\n\nI’ll start by creating a basic Attractor class, giving it a position and a mass, along with a method to draw itself (tying mass to size):\nclass Attractor {\n  constructor() {\n    // The attractor is an object that doesn’t move. It needs just a mass and a position.\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}\nIn the sketch, I’ll add a variable to hold an object instance of the Attractor:\nlet mover;\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  mover = new Mover(300, 100, 5);\n  // Initialize the <code>Attractor</code> object.\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Draw the <code>Attractor</code> object.\n  attractor.show();\n  mover.update();\n  mover.show();\n}\nThis is a good start: a sketch with a Mover object and an Attractor object, made from classes that handle the variables and behaviors of movers and attractors. The last piece of the puzzle is getting one object to attract the other. How do these two objects communicate? This could be done in various ways. Here are just some of the possibilities:\n\n  \n    \n      Task\n      Function\n    \n  \n  \n    \n      \n        \n          A global function that receives both an Attractor and a Mover.\n        \n      \n      \n        <code>attraction(attractor, mover);</code>\n      \n    \n    \n      \n        \n          A method in the Attractor class that receives a Mover.\n        \n      \n      \n        <code>attractor.attract(mover);</code>\n      \n    \n    \n      \n        \n          A method in the Mover class that receives an Attractor.\n        \n      \n      \n        <code>mover.attractedTo(attractor);</code>\n      \n    \n    \n      \n        \n          A method in the Attractor class that receives a Mover and returns a p5.Vector, which is the attraction force. That attraction force is then passed into the Mover object’s applyForce() method.\n        \n      \n      \n        <code>let force = attractor.attract(mover);\nmover.applyForce(force);</code>\n      \n    \n  \n\nIt’s good to consider a range of options, and you could probably make arguments for each of these approaches. I’d like to at least discard the first one, since I tend to prefer an object-oriented approach rather than an arbitrary function not tied to either the Mover or Attractor class. Whether you pick option 2 or option 3 is the difference between saying, “The attractor attracts the mover” and “The mover is attracted to the attractor.” Option 4 is really my favorite, though. I spent a lot of time working out the applyForce() method, and I think the examples are clearer continuing with the same technique of using this method to apply the forces.\nIn other words, where I once wrote\n// Made-up force\nlet force = createVector(0, 0.1);\nmover.applyForce(force);\n\n  I now have this:\n  //{!1} Attraction force between two objects\n<strong>let force = attractor.attract(mover);</strong>\nmover.applyForce(force);\n\nAnd so the draw() function can be written as shown here:\nfunction draw() {\n  background(255);\n\n  //{!2} Calculate the attraction force and apply it.\n  <strong>let force = attractor.attract(mover);\n  mover.applyForce(force);</strong>\n  mover.update();\n\n  attractor.show();\n  mover.show();\n}\nI’m almost there. Since I decided to put the attract() method inside the Attractor class, I still need to actually write that method. It should receive a Mover object and return a p5.Vector:\n  attract(m) {\n    // All the math\n    return ______________;\n  }\nWhat goes inside the method? All of that nice math for gravitational attraction!\n  attract(mover) {\n    //{!1} What’s the force’s direction?\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    // Calculate the strength of the attraction force.\n    let strength = (this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n\n    // Return the force so it can be applied!\n    return force;\n  }\nAnd I’m done. Sort of. Almost. I need to work out one small kink. Look at the code for the attract() method again. See that slash symbol for division? Whenever you have one of those, you should ask yourself this question: What would happen if the distance happened to be a really, really small number, or (even worse!) 0? You can’t divide a number by 0, and if you were to divide a number by something tiny like 0.0001, that’s the equivalent of multiplying that number by 10,000! That may be a viable outcome of this formula for gravitational attraction in the real world, but p5.js isn’t the real world. In the p5.js world, the mover could end up being very, very close to the attractor, and the resulting force could be so strong that the mover flies way off the canvas.\nConversely, what if the mover were to be, say, 500 pixels from the attractor (not unreasonable in p5.js)? You’re squaring the distance, so this will result in dividing the force by 250,000. That force might end up being so weak that it’s almost as if it’s not applied at all.\nTo avoid both extremes, it’s practical to constrain the range of distance before feeding it into the formula. Maybe, no matter where the Mover actually is, you should never consider it to be less than 5 pixels or more than 25 pixels away from the attractor, for the purposes of calculating the force of gravitational attraction:\n  // Here the <code>constrain()</code> function limits the value of distance between a minimum (5) and maximum (25).\n  distance = constrain(distance, 5, 25);\nUltimately, it’s up to you to choose the behaviors you want from your simulation. But if you decide you want a reasonable-looking attraction that’s never absurdly weak or strong, constraining the distance is a good technique.\nThe Mover class hasn’t changed at all, so let’s just look at the main sketch and the Attractor class as a whole, adding a variable G for the universal gravitational constant. (On the book’s website, you’ll find that this example also has code that allows you to move the Attractor object with the mouse.)\n\n  Example 2.6: Attraction\n  \n    \n    \n  \n\n// A mover and an attractor\nlet mover;\nlet attractor;\n// A gravitational constant (for global scaling)\nlet G = 1.0;\n\nfunction setup() {\n  createCanvas(640, 240);\n  mover = new Mover(300, 50, 2);\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!2} Apply the attraction force from the attractor on the mover.\n  let force = attractor.attract(mover);\n  mover.applyForce(force);\n  mover.update();\n  attractor.show();\n  mover.show();\n}\n\nclass Attractor {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  attract(mover) {\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    //{!1} Remember, you need to constrain the distance so your circle doesn’t spin out of control.\n    distance = constrain(distance, 5, 25);\n    let strength = (G * this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n    return force;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}\nIn this code, the diameter of the mover and attractor is scaled according to the mass of each object. However, this doesn’t accurately reflect how mass and size are related in our physical world. The area of a circle is calculated with the formula \\pi{r^2}, where r represents the radius (half the diameter) of the circle. (More about \\pi to come in Chapter 3!) As such, to represent an object’s mass proportionally with a circle’s area more accurately, I should really take the square root of the mass and scale that as the diameter of the circle.\n\n  Exercise 2.11\n  Adapt Example 2.6 to map the mass of the Attractor and Mover to the area of their respective circles:\n  circle(this.position.x, this.position.y, <span class=\"blank\">sqrt</span>(this.mass) * 2);\n\nYou could, of course, expand the code to include one Attractor and an array of many Mover objects, just as I included an array of Mover objects in Example 2.5 previously.\n\n  Example 2.7: Attraction with Many Movers\n  \n    \n    \n  \n\n// Now you have 10 movers!\nlet movers = [];\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  for (let i = 0; i < 10; i++) {\n    // Each mover is initialized randomly.\n    movers[i] = new Mover(random(width), random(height), random(0.5, 3));\n  }\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  attractor.show();\n  for (let i = 0; i < movers.length; i++) {\n    //{!1} Calculate an attraction force for each <code>Mover</code> object.\n    let force = attractor.attract(movers[i]);\n    movers[i].applyForce(force);\n    movers[i].update();\n    movers[i].show();\n  }\n}\nThis is just a small taste of what’s possible with arrays of objects. Stay tuned for a more in-depth exploration of adding and removing multiple objects from the canvas in Chapter 4, which covers particle systems.\n\n  Exercise 2.12\n  In Example 2.7, there’s a system (an array) of Mover objects and one Attractor object. Build an example that has systems of both movers and attractors. What if you make the attractors invisible? Can you create a pattern/design from the trails of objects moving around attractors?\n\n\n  Exercise 2.13\n  This chapter isn’t suggesting that every good p5.js simulation needs to involve gravitational attraction. Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects, using my approach to simulating gravitational attraction as a model. For example, what happens if you design an attractive force that gets weaker as the objects get closer, and stronger as the objects get farther apart? Or what if you design your attractor to attract faraway objects but repel close ones?\n\nThe n-Body Problem\n\nI started exploring gravitational attraction with a simple scenario, one object attracts another object, then moved on to the slightly more complex one object attracts many objects. A logical next step is to explore what happens when many objects attract many objects!\nTo begin, while having separate Mover and Attractor classes has been helpful so far, this distinction is a bit misleading. After all, according to Newton’s third law, all forces occur in pairs: if an attractor attracts a mover, then that mover should also attract the attractor. Instead of two classes here, what I really want is a single type of thing—called, for example, a Body—with every body attracting every other body.\nThe scenario I’m describing is commonly referred to as the n-body problem. It involves solving for the motion of a group of objects that interact via gravitational forces. The two-body problem is a famously solved problem, meaning the motions can be precisely computed with mathematical equations when only two bodies are involved. However, adding one more body turns the two-body problem into a three-body problem, and suddenly no formal solution exists (see Figure 2.10).\n\n  \n  Figure 2.10: Example paths of the two-body (predictable) versus three-body (complex) problems\n\nAlthough less accurate than using precise equations of motion, the examples built in this chapter can model both the two-body and three-body problems. To begin, I’ll move the attract() method from the Attractor class into the Mover class (which I will now call Body):\n// The mover is now called a body.\nclass Body {\n\n  /* All the other stuff from before */\n\n  // The <code>attract()</code> method is now part of the Body class.\n  attract(body) {\n    let force = p5.Vector.sub(this.position, body.position);\n    let d = constrain(force.mag(), 5, 25);\n    let strength = (G * (this.mass * body.mass)) / (d * d);\n    force.setMag(strength);\n    body.applyForce(force);\n  }\n}\nNow it’s just a matter of creating two Body objects (let’s call them bodyA and bodyB) and ensuring that they both attract each other:\nlet bodyA;\nlet bodyB;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create two <code>Body</code> objects, <code>A</code> and <code>B</code>.\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n}\n\nfunction draw() {\n  background(255);\n  //{!2} <code>A</code> attracts <code>B</code>, and <code>B</code> attracts <code>A</code>.\n  bodyA.attract(bodyB);\n  bodyB.attract(bodyA);\n  bodyA.update();\n  bodyA.show();\n  bodyB.update();\n  bodyB.show();\n}\nFor any n-body problem, the resulting motion and patterns are entirely dependent on the initial conditions. For example, if I were to assign specific velocity vectors for each body in setup(), one pointing to the right and one pointing to the left, the result is a circular orbit.\n\n  Example 2.8: Two-Body Attraction\n  \n    \n    \n  \n\nfunction setup() {\n  createCanvas(640, 240);\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n  // Assign horizontal velocities (in opposite directions) to each body.\n  bodyA.velocity = createVector(1, 0);\n  bodyB.velocity = createVector(-1, 0);\n}\nExample 2.8 could be improved by refactoring the code to include constructor arguments that assign the body velocities. For now, however, this approach serves as a quick way to experiment with patterns based on various initial positions and velocities.\n\n  Exercise 2.14\n  The paper “Classification of Symmetry Groups for Planar n-Body Choreographies” by James Montaldi and Katrina Steckles explores choreographic solutions to the n-body problem (defined as periodic motions of bodies following one another at regular intervals). Educator and artist Dan Gries created an interactive demonstration of these choreographies. Try adding a third (or more!) body to Example 2.8 and experiment with setting initial positions and velocities. What choreographies can you achieve?\n\nI’m now ready to move on to an example with n bodies by incorporating an array:\n// Start with an empty array.\nlet bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Fill the array with <code>Body</code> objects.\n  for (let i = 0; i < 10; i++) {\n    bodies[i] = new Body(random(width), random(height));\n  }\n}\n\nfunction draw() {\n  background(255);\n  // Iterate over the array to update and show all bodies.\n  for (let i = 0; i < bodies.length; i++) {\n    bodies[i].update();\n    bodies[i].show();\n  }\n}\nThe draw() function is where I need to work some magic so that every body exerts a gravitational force on every other body. Right now, the code reads, “For every body i, update and draw.” To attract every other body j with each body i, I need to nest a second loop and adjust the code to say, “For every body i, attract every other body j (and update and draw).”\n  //{!2} For every body, check every body!\n  for (let i = 0; i < bodies.length; i++) {\n    for (let j = 0; j < bodies.length; j++) {\n      let force = bodies[j].attract(bodies[i]);\n      movers[i].applyForce(force);\n    }\n    movers[i].update();\n    movers[i].show();\n  }\nThe code has one small problem, though. When every body i attracts every body j, what happens when i equals j? Should body index 3 attract body index 3? The answer, of course, is no. If you have five bodies, you want body index 3 to attract only bodies 0, 1, 2, and 4, skipping itself. I’ll account for this by adding a conditional statement to skip applying the force when i equals j.\n\n  Example 2.9: n Bodies\n  \n    \n    \n  \n\nlet bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i < 10; i++) {\n    bodies[i] = new Body(random(width), random(height), random(0.1, 2));\n  }\n}\n\nfunction draw() {\n  background(255);\n\n  for (let i = 0; i < bodies.length; i++) {\n    for (let j = 0; j < bodies.length; j++) {\n      //{!1} Do not attract yourself!\n      if (i !== j) {\n        let force = bodies[j].attract(bodies[i]);\n        bodies[i].applyForce(force);\n      }\n    }\n    bodies[i].update();\n    bodies[i].show();\n  }\n}\nThe nested loop solution in Example 2.9 leads to what’s called an n-squared algorithm, meaning the number of calculations is equal to the number of bodies squared. If I were to increase the number of bodies, the simulation would start to slow significantly because of the number of calculations required.\nIn Chapter 5, I’ll explore strategies for optimizing sketches like this one, with a particular focus on spatial subdivision algorithms. Spatial subdivision, in combination with the concept of quadtrees and an algorithm called Barnes-Hut, is particularly effective for improving efficiency in simulations such as the n-body one discussed here.\n\n  Exercise 2.15\n  Change the attraction force in Example 2.9 to a repulsion force. Can you create an example in which all the Body objects are attracted to the mouse but repel one another? Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.\n\n\n  Exercise 2.16\n  Can you arrange the bodies of the n-body simulation to orbit the center of the canvas in a pattern that resembles a spiral galaxy? You may need to include an additional large body in the center to hold everything together. A solution is offered in my “Mutual Attraction” video in the Nature of Code series on the Coding Train website.\n  \n    \n    \n  \n\n\n  The Ecosystem Project\n  Incorporate forces into your ecosystem. How might other environmental factors (for example, water versus mud, or the current of a river) affect the way a character moves through an ecosystem?\n  Try introducing other elements into the environment (food, a predator) for the creature to interact with. Does the creature experience attraction or repulsion to things in its world? Can you think more abstractly and design forces based on the creature’s desires or goals?\n  \n    \n    \n  \n\n",
  "htmlContent": "<section data-type=\"chapter\" id=\"section-forces\">\n<h1 id=\"chapter-2-forces\">Chapter 2. Forces</h1>\n<div class=\"chapter-opening-quote\">\n  <blockquote data-type=\"epigraph\">\n    <p>Don’t underestimate the Force.</p>\n    <div class=\"chapter-opening-quote-source\">\n      <p>—Darth Vader</p>\n    </div>\n  </blockquote>\n</div>\n<p></p>\n<div class=\"chapter-opening-figure\">\n  <figure>\n    <img src=\"/content/images/02_forces/02_forces_1.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n  <h3 id=\"calder-installation-at-the-new-gallery-charles-hayden-memorial-library-mit-cambridge-ma-1950-photo-by-ezra-stoller\"><em>Calder </em>installation at the New Gallery, Charles Hayden Memorial Library, MIT, Cambridge, MA, 1950 (photo by Ezra Stoller)</h3>\n  <p>Alexander Calder was a 20th-century American artist known for his kinetic sculptures that balance form and motion. His “constellations” were sculptures consisting of interconnected shapes and wire that demonstrate tension, balance, and the ever-present pull of gravitational attraction.</p>\n</div>\n<p>In the final example of Chapter 1, I demonstrated how to calculate a dynamic acceleration based on a vector pointing from a circle on the canvas to the mouse position. The resulting motion resembled a magnetic attraction between shape and mouse, as if a <em>force</em> was pulling the circle in toward the mouse. In this chapter, I’ll detail the concept of a force and its relationship to acceleration. The goal, by the end of this chapter, is to build a simple physics engine and understand how objects move around a canvas, responding to a variety of environmental forces.</p>\n<p>A <strong>physics engine </strong>is a computer program (or code library) that simulates the behavior of objects in a physical environment. With a p5.js sketch, the objects are 2D shapes, and the environment is a rectangular canvas. Physics engines can be developed to be highly precise (requiring high-performance computing) or real time (using simple and fast algorithms). This chapter focuses on building a rudimentary physics engine, with an emphasis on speed and ease of understanding.</p>\n<h2 id=\"forces-and-newtons-laws-of-motion\">Forces and Newton’s Laws of Motion</h2>\n<div data-type=\"video-link\" data-title=\"Simulating Forces: Gravity and Wind\" href=\"https://www.youtube.com/watch?time_continue=10&#x26;v=Uibl0UE4VH8&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Let’s begin by taking a conceptual look at what it means to be a force in the real world. Just like the word <em>vector</em>, the term <em>force</em> can have a variety of meanings. It can indicate a powerful physical intensity, as in “They pushed the boulder with great force,” or a powerful influence, as in “They’re a force to be reckoned with!” The definition of <strong>force</strong> that I’m interested in for this chapter is more formal and comes from Sir Isaac Newton’s three laws of motion:</p>\n<p><span class=\"highlight\">A force is a vector that causes an object with mass to accelerate.</span></p>\n<p>Hopefully, you recognize the first part of the definition: <em>a force is a vector</em>. Thank goodness you just spent a whole chapter learning what vectors are and how to program with them! I’ll start from there by explaining how Newton’s three laws of motion relate to what you already know about vectors; then I’ll illustrate the rest of the force definition as I go.</p>\n<h3 id=\"newtons-first-law\">Newton’s First Law</h3>\n<p>Newton’s first law is commonly stated as follows:</p>\n<p><span class=\"highlight\">An object at rest stays at rest, and an object in motion stays in motion.</span></p>\n<p>However, this is missing an important element related to forces. I could expand the definition by stating:</p>\n<p><span class=\"highlight\">An object at rest stays at rest, and an object in motion stays in motion, at a constant speed and direction unless acted upon by an unbalanced force.</span></p>\n<p>When Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly 2,000 years old. It stated that if an object is moving, some sort of force is required to keep it moving. Unless that moving thing is being pushed or pulled, it will slow down or stop. This theory was borne out through observation of the world. For example, if you toss a ball, it falls to the ground and eventually stops moving, seemingly because the force of the toss is no longer being applied.</p>\n<p>This older theory, of course, isn’t true. As Newton established, in the absence of any forces, no force is required to keep an object moving. When an object (such as the aforementioned ball) is tossed in Earth’s atmosphere, its velocity changes because of unseen forces such as air resistance and gravity. An object’s velocity will remain constant only in the absence of any forces or only if the forces that act on it cancel each other out, meaning the net force adds up to zero. This is often referred to as <strong>equilibrium</strong> (see Figure 2.1). The falling ball will reach a terminal velocity (which stays constant) once the force of air resistance equals the force of gravity.</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_2.png\" alt=\"Figure 2.1: The toy mouse doesn’t move because all the forces cancel one another out (that is, they add up to a net force of zero).\">\n  <figcaption>Figure 2.1: The toy mouse doesn’t move because all the forces cancel one another out (that is, they add up to a net force of zero).</figcaption>\n</figure>\n<p>Considering a p5.js canvas, I could restate Newton’s first law as follows:</p>\n<p><span class=\"highlight\">An object’s velocity vector will remain constant if it’s in a state of equilibrium.</span></p>\n<p>In other words, in a <code>Mover</code> class, the <code>update()</code> function shouldn’t apply any mathematical operations on the velocity vector unless a nonzero net force is present.</p>\n<h3 id=\"newtons-third-law\">Newton’s Third Law</h3>\n<p>Let me set aside Newton’s second law (arguably the most important law for the purposes of this book) for a moment and move on to his third law. This law is often stated as follows:</p>\n<p><span class=\"highlight\">For every action, there is an equal and opposite reaction.</span></p>\n<p>The way this law is stated frequently causes confusion. For one, it sounds like one force causes another. Yes, if you push someone, that someone may <em>actively</em> decide to push you back. But this isn’t the action and reaction Newton’s third law has in mind.</p>\n<p>Let’s say you push against a wall. The wall doesn’t actively decide to push you back, and yet it still provides resistance with an equal force in the opposite direction. There’s no “origin” force. Your push simply includes both forces, referred to as an <em>action/reaction pair</em>. A better way of stating Newton’s third law might therefore be the following:</p>\n<p><span class=\"highlight\">Forces always occur in pairs. The two forces are of equal strength but in opposite directions.</span></p>\n<p>This still causes confusion because it sounds like these forces would always cancel each other out. This isn’t the case. Remember, the forces act on different objects. And just because the two forces are equal doesn’t mean that the objects’ movements are equal (or that the objects will stop moving).</p>\n<p>Consider pushing on a stationary truck. Although the truck is far more massive than you, a stationary truck (unlike a moving one) will never overpower you and send you flying backward. The force your hands exert on the truck is equal and opposite to the force exerted by the truck on your hands. The outcome depends on a variety of other factors. If the truck is small and parked on an icy street, you’ll probably be able to get it to move. On the other hand, if it’s very large and on a dirt road and you push hard enough (maybe even take a running start), you could injure your hand.</p>\n<p>And what if, as in Figure 2.2, you are wearing roller skates when you push on that truck?</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_3.png\" alt=\"Figure 2.2: Demonstrating Newton’s third law of motion by pushing a heavy truck while wearing roller skates\">\n  <figcaption>Figure 2.2: Demonstrating Newton’s third law of motion by pushing a heavy truck while wearing roller skates</figcaption>\n</figure>\n<div class=\"avoid-break\">\n  <p>You’ll accelerate away from the truck, sliding along the road while the truck stays put. Why do you slide but not the truck? For one, the truck has a much larger mass (which I’ll get into with Newton’s second law). Other forces are at work too—namely, the friction of the truck’s tires and your roller skates against the road.</p>\n</div>\n<p>Considering p5.js again, I could restate Newton’s third law as follows:</p>\n<p><span class=\"highlight\">If you calculate a <code>p5.Vector</code> called <code>f</code> that represents a force of object A on object B, you must also apply the opposite force that object B exerts on object A. You can calculate this other force as <code>p5.Vector.mult(f, -1)</code>.</span></p>\n<p>\n  You’ll soon see that in the world of coding simulation, it’s often not necessary to stay true to Newton’s third law. Sometimes, such as in the case of gravitational attraction between bodies (see Example\n  2.8), I’ll want to model equal and opposite forces in my example code. Other times, such as a scenario where I’ll say, “Hey, there’s some wind in the environment,” I’m not going to bother to model the force that a body exerts back on the air. In fact, I’m not going to bother modeling the air at all! Remember, the examples in this book are taking inspiration from the physics of the natural world for the purposes of creativity and interactivity. They don’t require perfect precision.\n</p>\n<h3 id=\"newtons-second-law\">Newton’s Second Law</h3>\n<p>Now it’s time for the most important law for you, the p5.js coder: Newton’s second law. It’s stated as follows:</p>\n<p><span class=\"highlight\">Force equals mass times acceleration.</span></p>\n<p>Or:</p>\n<div data-type=\"equation\">\\vec{F} = M \\times \\vec{A}</div>\n<p>Why is this the most important law for this book? Well, let’s write it a different way:</p>\n<div data-type=\"equation\">\\vec{A} = \\vec{F} / M</div>\n<p>Acceleration is directly proportional to force and inversely proportional to mass. Consider what this means if you’re pushed. The harder you’re pushed, the faster you’ll speed up or slow down (accelerate). On the other hand, the bigger you are, the less effective a force is at accelerating you!</p>\n<div data-type=\"note\">\n  <h3 id=\"weight-vs-mass\">Weight vs. Mass</h3>\n  <p>Mass isn’t to be confused with weight. <strong>Mass</strong> is a measure of the amount of matter in an object (measured in kilograms). An object that has a mass of 1 kilogram on Earth would have a mass of 1 kilogram on the moon.</p>\n  <p><strong>Weight</strong>, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, you can calculate weight as mass times the acceleration of gravity (<span data-type=\"equation\">w = m \\times g</span>). Weight is measured in newtons, a unit that indicates the magnitude of the gravitational force. Because weight is tied to gravity, an object on the moon weighs one-sixth as much as it does on Earth.</p>\n  <p>Related to mass is <strong>density</strong>, which is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).</p>\n</div>\n<p>In the world of p5.js, what is mass anyway? Aren’t we dealing with pixels? Let’s start simple and say that in a pretend pixel world, all objects have a mass equal to 1. Anything divided by 1 equals itself, and so, in this simple world, we have this:</p>\n<div data-type=\"equation\">\\vec{A} = \\vec{F}</div>\n<p>I’ve effectively removed mass from the equation, making the acceleration of an object equal to force. This is great news. After all, <a href=\"/vectors#section-vectors\">Chapter 1</a> described acceleration as the key to controlling the movement of objects in a canvas. I said that the position changes according to the velocity, and the velocity according to acceleration. Acceleration seemed to be where it all began. Now you can see that <em>force</em> is truly where it all begins.</p>\n<p>Let’s take the <code>Mover</code> class, with position, velocity, and acceleration:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n  }\n}</pre>\n<p>Now the goal is to be able to add forces to this object, with code like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">mover.applyForce(wind);</pre>\n<p>Or like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">mover.applyForce(gravity);</pre>\n<p>Here <code>wind</code> and <code>gravity</code> are <code>p5.Vector</code> objects. According to Newton’s second law, I could implement this <code>applyForce()</code> method as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">applyForce(force) {\n  // Newton’s second law at its simplest\n  this.acceleration = force;\n}</pre>\n<p>This looks pretty good. After all, <em>acceleration = force</em> is a literal translation of Newton’s second law (in a world without mass). Nevertheless, this code has a pretty big problem, which I’ll quickly encounter when I return to my original goal: creating an object that responds to wind and gravity forces. Consider this code:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">mover.applyForce(wind);\nmover.applyForce(gravity);\nmover.update();</pre>\n<p>Imagine you’re the computer for a moment. First, you call <code>applyForce()</code> with <code>wind</code>, and so the <code>Mover</code> object’s acceleration is now assigned the <code>wind</code> vector. Second, you call <code>applyForce()</code> with <code>gravity</code>. Now the <code>Mover</code> object’s acceleration is set to the <code>gravity</code> vector. Finally, you call <code>update()</code>. What happens in <code>update()</code>? Acceleration is added to velocity:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.velocity.add(this.acceleration);</pre>\n<p>If you run this code, you won’t see an error in the console, but zoinks! There’s a major problem. What’s the value of <code>acceleration</code> when it’s added to <code>velocity</code>? It’s equal to the <code>gravity</code> vector, meaning <code>wind</code> has been left out! Anytime <code>applyForce()</code> is called, <code>acceleration</code> is overwritten. How can I handle more than one force?</p>\n<h2 id=\"force-accumulation\">Force Accumulation</h2>\n<p>The answer is that the forces must <strong>accumulate</strong>, or be added together. This is stated in the full definition of Newton’s second law itself, which I now confess to having simplified. Here’s a more accurate way to put it:</p>\n<p><span class=\"highlight\">Net force equals mass times acceleration.</span></p>\n<p>In other words, acceleration is equal to the <em>sum of all forces</em> divided by mass. At any given moment, there might be 1, 2, 6, 12, or 303 forces acting on an object. As long as the object knows how to add them together (accumulate them), it doesn’t matter how many forces there are. The sum total will give you the object’s acceleration (again, ignoring mass). This makes perfect sense. After all, as you saw in Newton’s first law, if all the forces acting on an object add up to zero, the object experiences an equilibrium state (that is, no acceleration).</p>\n<p>I can now revise the <code>applyForce()</code> method to take force accumulation into account:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">applyForce(force) {\n  // Newton’s second law, but with force accumulation, adding all input forces to acceleration\n  this.acceleration.add(force);\n}</pre>\n<p>I’m not finished just yet, though. Force accumulation has one more piece. Since I’m adding all the forces together at any given moment, I have to make sure that I clear <code>acceleration</code> (set it to <code>0</code>) before each time <code>update()</code> is called. Consider a wind force for a moment. Sometimes wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all. For example, you might write code that creates a gust of wind when holding down the mouse:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">if (mouseIsPressed) {\n  let wind = createVector(0.5, 0);\n  mover.applyForce(wind);\n}</pre>\n<p>When the mouse is released, the wind should stop, and according to Newton’s first law, the object should continue moving at a constant velocity. However, if I forget to reset <code>acceleration</code> to <code>0</code>, the gust of wind will still be in effect. Even worse, it will add onto itself from the previous frame! Acceleration, in a time-based physics simulation, has no memory; it’s calculated based on the environmental forces present at any given moment (frame) in time. This is different from, say, position. An object must remember its previous location in order to move properly to the next.</p>\n<p>One way to clear the acceleration for each frame is to multiply the <code>acceleration</code> vector by <code>0</code> at the end of <code>update()</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">update() {\n  this.velocity.add(this.acceleration);\n  this.position.add(this.velocity);\n  // Clear acceleration after it’s been applied.\n  this.acceleration.mult(0);\n}</pre>\n<p>Being able to accumulate and apply forces gets me closer to a working physics engine, but at this point I should note another detail that I’ve been glossing over, besides mass. That’s the <strong>time step</strong>, the rate at which the simulation updates. The size of the time step affects the accuracy and behavior of a simulation, which is why many physics engines incorporate the time step as a variable (often denoted as <code>dt</code>, which stands for <em>delta time</em>, or the change in time). For simplicity, I’m instead choosing to assume that every cycle through <code>draw()</code> represents one time step. This assumption may not be the most accurate, but it allows me to focus on the key principles of the simulation.</p>\n<p>I’ll let this assumption stand until Chapter 6, when I’ll examine the impact of different time steps while covering third-party physics libraries. Right now, though, I can and should address the massive elephant in the room that I’ve so far been ignoring: mass.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-21\">Exercise 2.1</h3>\n  <p>Using forces, simulate a helium-filled balloon floating upward and bouncing off the top of a window. Can you add a wind force that changes over time, perhaps according to Perlin noise?</p>\n  <div class=\"web-only solution\">\n    <figure>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/AAJ2B7drvB\" data-example-path=\"examples/02_forces/nature_of_code_exercise_2_1_solution\"><img src=\"/content/examples/02_forces/nature_of_code_exercise_2_1_solution/screenshot.png\"></div>\n      <figcaption></figcaption>\n    </figure>\n  </div>\n</div>\n<h2 id=\"factoring-in-mass\">Factoring In Mass</h2>\n<div data-type=\"video-link\" data-title=\"Mass &#x26; Acceleration\" href=\"https://www.youtube.com/watch?v=L7CECWLdTmo&#x26;t=175s\"></div>\n<p>Newton’s second law is really <span data-type=\"equation\">\\vec{F} = M \\times \\vec{A}</span>, not <span data-type=\"equation\">\\vec{F} = \\vec{A}</span>. How can I incorporate mass into the simulation? To start, it’s as easy as adding a <code>this.mass</code> instance variable to the <code>Mover</code> class, but I need to spend a little more time here because of another impending complication.</p>\n<p>First, though, I’ll add mass:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    // Add mass as a number.\n    this.mass = ????;\n  }\n}</pre>\n<div data-type=\"note\">\n  <h3 id=\"units-of-measurement\">Units of Measurement</h3>\n  <p>Now that I’m introducing mass, it’s important to make a quick note about units of measurement. In the real world, things are measured in specific units: two objects are 3 meters apart, the baseball is moving at a rate of 90 miles per hour, or this bowling ball<br>has a mass of 6 kilograms. Sometimes you do want to take real-world units into consideration. In this chapter, however, I’m going to stick with units of measurement in pixels (“These two circles are 100 pixels apart”) and frames of animation (“This circle is moving at a rate of 2 pixels per frame,” the aforementioned time step).</p>\n  <p>In the case of mass, p5.js doesn’t have any unit of measurement to use. How much mass is in any given pixel? You might enjoy inventing your own p5.js unit of mass to associate with those values, like “10 pixeloids” or “10 yurkles.”</p>\n  <p>For demonstration purposes, I’ll tie mass to pixels (the larger a circle’s diameter, the larger the mass). This will allow me to visualize the mass of an object, albeit inaccurately. In the real world, size doesn’t indicate mass. A small metal ball could have a much higher mass than a large balloon because of its higher density. And for two circular objects with equal density, I’ll also note that mass should be tied to the formula for the area of a circle: <span data-type=\"equation\">\\pi r^2</span>. (This will be addressed in Exercise 2.11, and I’ll say more about <span data-type=\"equation\">\\pi</span> and circles in <a href=\"/oscillation#section-oscillation\">Chapter 3</a>.)</p>\n</div>\n<p>Mass is a scalar, not a vector, as it’s just one number describing the amount of matter in an object. I could get fancy and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is . . . um, I dunno . . . how about 10?”</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">constructor() {\n  this.position = createVector(random(width), random(height));\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n  this.mass = 10;\n}</pre>\n<p>This isn’t so great, since things become interesting only when I have objects with varying mass, but it’s enough to get us started. Where does mass come in? I need to divide force by mass to apply Newton’s second law to the object:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">applyForce(force) {\n  // Newton’s second law (with force accumulation and mass)\n  force.div(this.mass);\n  this.acceleration.add(force);\n}</pre>\n<p>Yet again, even though the code looks quite reasonable, it has a major problem. Consider the following scenario with two <code>Mover</code> objects, both being blown away by a wind force:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let moverA = new Mover();\nlet moverB = new Mover();\n\nlet wind = createVector(1, 0);\n\nmoverA.applyForce(wind);\nmoverB.applyForce(wind);</pre>\n<p>Again, imagine you’re the computer. Object <code>moverA</code> receives the wind force—(1, 0)—divides it by <code>mass</code> (10), and adds it to acceleration:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Vector Components</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code>moverA</code> receives the wind force.</td>\n      <td>(1, 0)</td>\n    </tr>\n    <tr>\n      <td><code>moverA</code> divides the wind force by a mass of 10.</td>\n      <td>(0.1, 0)</td>\n    </tr>\n  </tbody>\n</table>\n<p>Now you move on to object <code>moverB</code>. It also receives the wind force—(1, 0). Wait, hold on a second. What’s the value of the wind force? Taking a closer look, it’s actually now (0.1, 0)! Remember that when you pass an object (in this case, <code>p5.Vector</code>) into a function, you’re passing a reference to that object. It’s not a copy! So if a function makes a change to that object (which, in this case, it does by dividing by the mass), that object is permanently changed. But I don’t want <code>moverB</code> to receive a force divided by the mass of object <code>moverA</code>. I want it to receive the force in its original state—(1, 0). And so I must protect the original vector and make a copy of it before dividing by mass.</p>\n<p>Fortunately, the <code>p5.Vector</code> class has a convenient method for making a copy: <code>copy()</code>. It returns a new <code>p5.Vector</code> object with the same data. And so I can revise <code>applyForce()</code> as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">applyForce(force) {\n  //{!1} Make a copy of the vector before using it.\n  let f = force.copy();\n  //{!1} Divide the copy by mass.\n  f.div(this.mass);\n  this.acceleration.add(f);\n}</pre>\n<p>Let’s take a moment to recap what I’ve covered so far. I’ve defined what a force is (a vector), and I’ve shown how to apply a force to an object (divide it by mass and add it to the object’s acceleration vector). What’s missing? Well, I have yet to figure out how to calculate a force in the first place. Where do forces come from?</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-22\">Exercise 2.2</h3>\n  <p>You could write <code>applyForce()</code> in another way, using the static method <code>div()</code> instead of <code>copy()</code>. Rewrite <code>applyForce()</code> by using the static method. For help with this exercise, review static methods in <a href=\"/vectors#static-vs-nonstatic-methods\" class=\"page-reference\">“Static vs. Nonstatic Methods”</a>.</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">applyForce(force) {\n  let f = <span class=\"blank\">p5.Vector.div</span>(<span class=\"blank\">force</span>, <span class=\"blank\">this.mass</span>);\n  this.acceleration.add(f);\n}</pre>\n</div>\n<h2 id=\"creating-forces\">Creating Forces</h2>\n<p>This section presents two ways to create forces in a p5.js world:</p>\n<ul>\n  <li><strong>Make up a force!</strong> After all, you’re the programmer, the creator of your world. There’s no reason you can’t just make up a force and apply it.</li>\n  <li><strong>Model a force!</strong> Forces exist in the physical world, and physics textbooks often contain formulas for these forces. You can take these formulas and translate them into source code to model real-world forces in JavaScript.</li>\n</ul>\n<p>To begin, I’ll focus on the first approach. The easiest way to make up a force is to just pick a number (or two numbers, really). Let’s start with simulating wind. How about a wind force that points to the right and is fairly weak? Assuming an object <code>mover</code>, the code would read as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let wind = createVector(0.01, 0);\nmover.applyForce(wind);</pre>\n<p>The result isn’t terribly interesting but is a good place to start. I create a <code>p5.Vector</code> object, initialize it, and pass it into a <code>Mover</code> object (which in turn will apply it to its own acceleration). To finish off this example, I’ll add one more force, gravity (pointing down), and engage the wind force only when the mouse is pressed.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-21-forces\">Example 2.1: Forces</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/4IRI8BEVE\" data-example-path=\"examples/02_forces/example_2_1_forces\"><img src=\"/content/examples/02_forces/example_2_1_forces/screenshot.png\"></div>\n    <figcaption>Clicking the mouse applies the wind force.</figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let gravity = createVector(0, 0.1);\nmover.applyForce(gravity);\n\nif (mouseIsPressed) {\n  let wind = createVector(0.1, 0);\n  mover.applyForce(wind);\n}</pre>\n<p>Now I have two forces, pointing in different directions and with different magnitudes, both applied to the object <code>mover</code>. I’m beginning to get somewhere. I’ve built a world, an environment with forces that act on objects!</p>\n<p>Let’s look at what happens now when I add a second object with a variable mass. To do this, you’ll probably want to do a quick review of OOP. Again, I’m not covering all the basics of programming here (for that, you can check out any of the intro p5.js books or video tutorials listed in <a href=\"/introduction#the-coding-train-connection\" class=\"page-reference\">“The Coding Train Connection”</a>). However, since the idea of creating a world filled with objects is fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.</p>\n<p>This is where I left the <code>Mover</code> class. Notice that it’s identical to the <code>Mover</code> class created in Chapter 1, with two additions, <code>mass</code> and a new <code>applyForce()</code> method:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    //{!1} For now, set the mass equal to 1 for simplicity.\n    this.mass = 1;\n    this.position = createVector(width / 2, 30);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n  }\n\n  // Newton’s second law\n  applyForce(force) {\n    // Receive a force, divide by mass, and add to acceleration.\n    let f = p5.Vector.div(force, this.mass);\n    this.acceleration.add(f);\n  }\n\n  update() {\n    // Motion 101 from Chapter 1\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    // Now add clearing the acceleration each time!\n    this.acceleration.mult(0);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // Scale the size according to mass. Stay tuned for an improvement on this to come later in the chapter!\n    circle(this.position.x, this.position.y, this.mass * 16);\n  }\n\n  // Somewhat arbitrarily, I’ve decided that an object bounces when it hits the edges of the canvas.\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = width;\n      this.velocity.x *= -1;\n    } else if (this.position.x &#x3C; 0) {\n      this.velocity.x *= -1;\n      this.position.x = 0;\n    }\n\n    if (this.position.y > height) {\n      // Even though I said not to touch position and velocity directly, exceptions exist. Here, I’m doing so as a quick way to reverse the direction of the object when it reaches the edge.\n      this.velocity.y *= -1;\n      this.position.y = height;\n    }\n  }\n}</pre>\n<div class=\"avoid-break\">\n  <p>Now that the class is written, I can create more than one <code>Mover</code> object:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">let moverA = new Mover();\nlet moverB = new Mover();</pre>\n</div>\n<p>But there’s an issue. Look again at the <code>Mover</code> object’s constructor:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">constructor() {\n  //{!2} Every object has a mass of 1 and a position of (width / 2, 30).\n  this.mass = 1;\n  this.position = createVector(width / 2, 30);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}</pre>\n<p>Right now, every <code>Mover</code> object is made exactly the same way. What I want are <code>Mover</code> objects of <em>variable</em> mass that start at <em>variable</em> positions. A nice way to accomplish this is with constructor arguments:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">constructor(x, y, mass) {\n  //{!2} Now set these variables with arguments.\n  this.mass = mass;\n  this.position = createVector(x, y);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}</pre>\n<p>Notice that the mass and position are no longer set to hardcoded numbers, but rather are initialized via the <code>x</code>, <code>y</code>, and <code>mass</code> arguments passed to the constructor. This means I can create a variety of <code>Mover</code> objects—big ones, small ones, ones that start on the left side of the canvas, ones that start on the right, and everywhere in between:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// A large mover on the left side of the canvas\nlet moverA = new Mover(100, 30, 10);\n// A smaller mover on the right side of the canvas\nlet moverB = new Mover(400, 30, 2);</pre>\n<p>I could choose to initialize the values in all sorts of ways (random, Perlin noise, in a grid, and so on). Here I’ve just picked some numbers for demonstration purposes. I’ll introduce other techniques for initializing a simulation throughout this book.</p>\n<p>Once the objects are declared and initialized, the rest of the code follows as before. For each object, pass the forces in the environment to <code>applyForce()</code> and enjoy the show!</p>\n<div data-type=\"example\">\n  <h3 id=\"example-22-forces-acting-on-two-objects\">Example 2.2: Forces Acting on Two Objects</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/ePLfo-OGu\" data-example-path=\"examples/02_forces/example_2_2_forces_acting_on_two_objects\"><img src=\"/content/examples/02_forces/example_2_2_forces_acting_on_two_objects/screenshot.png\"></div>\n    <figcaption>Clicking the mouse applies the wind force.</figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n\n  // Make up a gravity force and apply it.\n  let gravity = createVector(0, 0.1);\n  moverA.applyForce(gravity);\n  moverB.applyForce(gravity);\n  // Make up a wind force and apply it when the mouse is clicked.\n  if (mouseIsPressed) {\n    let wind = createVector(0.1, 0);\n    moverA.applyForce(wind);\n    moverB.applyForce(wind);\n  }\n\n  moverA.checkEdges();\n  moverA.update();\n  moverA.show();\n\n  moverB.checkEdges();\n  moverB.update();\n  moverB.show();\n}</pre>\n<p>Notice that every operation in the code is written twice, once for <code>moverA</code> and once for <code>moverB</code>. In practice, an array would make more sense than separate variables to manage multiple <code>Mover</code> objects, particularly as their number increases. That way, I’d have to write each operation only once and use a loop to apply it to each <code>Mover</code> in the array. I’ll demonstrate this later in the chapter and cover arrays in greater detail in Chapter 4.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-23\">Exercise 2.3</h3>\n  <p>Instead of objects bouncing off the edge of the wall, create an example that includes an invisible force pushing back on the objects to keep them in the window. Can you weight the force according to the object’s distance from an edge so that the closer it is, the stronger the force?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-24\">Exercise 2.4</h3>\n  <p>Fix the bouncing off the sides of the canvas so that the circle changes direction when its edge hits the side, rather than its center.</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-25\">Exercise 2.5</h3>\n  <p>Create a wind force that’s variable. Can you make it interactive? For example, think of a fan located where the mouse is and pointed toward the circles.</p>\n</div>\n<p>When you run the code in Example 2.2, notice that the small circle responds more dramatically to the forces applied to it than the large one. This is because of the formula <em>acceleration = force divided by mass</em>. Mass is in the denominator, so the larger it is, the smaller the acceleration. This makes sense for the wind force—the more massive an object, the harder it should be for the wind to push it around—but is it accurate for a simulation of Earth’s gravitational pull?</p>\n<p>If you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one would hit the ground first? According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same time. Why? I’ll dive deeper into this shortly, but the quick answer is that even though the force of gravity is calculated relative to an object’s mass—so that the bigger the object, the stronger the force—that force is canceled out when you divide by the mass to determine the acceleration. Therefore, the acceleration of gravity for different objects is equal.</p>\n<p>A quick fix to the sketch—one that moves a step closer to realistically modeling a force rather than simply making up a force—is to implement this scaling by multiplying the gravity force by mass.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-23-gravity-scaled-by-mass\">Example 2.3: Gravity Scaled by Mass</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/0RiwMFOQ7\" data-example-path=\"examples/02_forces/example_2_3_gravity_scaled_by_mass\"><img src=\"/content/examples/02_forces/example_2_3_gravity_scaled_by_mass/screenshot.png\"></div>\n    <figcaption>Clicking the mouse applies the wind force.</figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Made-up gravity force\nlet gravity = createVector(0, 0.1);\n// Scale by mover A’s mass.\nlet gravityA = p5.Vector.mult(gravity, moverA.mass);\nmoverA.applyForce(gravityA);\n// Scale by mover B’s mass.\nlet gravityB = p5.Vector.mult(gravity, moverB.mass);\nmoverB.applyForce(gravityB);</pre>\n<p>The objects now fall at the same rate. I’m still basically making up the gravity force by arbitrarily setting it to 0.1, but by scaling the force according to the object’s mass, I’m making it up in a way that’s a little truer to Earth’s actual force of gravitational attraction. Meanwhile, because the strength of the wind force is independent of mass, the smaller circle still accelerates to the right more quickly when the mouse is pressed. (The online code for this example also includes a solution to Exercise 2.4, with the addition of a <code>radius</code> variable in the <code>Mover</code> class.)</p>\n<h2 id=\"modeling-a-force\">Modeling a Force</h2>\n<p>Making up forces will actually get you quite far—after all, I just made up a pretty good approximation of Earth’s gravity. Ultimately, the world of p5.js is an orchestra of pixels, and you’re the conductor, so whatever you deem appropriate to be a force, well by golly, that’s the force it should be! Nevertheless, there may come a time when you find yourself wondering, “But how does it all <em>really</em> work?” That’s when modeling forces, instead of just making them up, enters the picture.</p>\n<div data-type=\"note\">\n  <h3 id=\"parsing-formulas\">Parsing Formulas</h3>\n  <p>In a moment, I’m going to write out the formula for friction. This won’t be the first time<br>you’ve seen a formula in this book; I just finished up the discussion of Newton’s second law, <span data-type=\"equation\">\\vec{F} = M \\times \\vec{A}</span> (or force equals mass times acceleration). You hopefully didn’t spend a lot<br>of time worrying about that formula, because it’s just a few characters and symbols. Nevertheless, it’s a scary world out there. Just take a look at the equation for a normal distribution, which I covered (without presenting the formula) in <a href=\"/random#a-normal-distribution-of-random-numbers\" class=\"page-reference\">“A Normal Distribution of Random Numbers”</a>:</p>\n  <div data-type=\"equation\">\\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</div>\n  <p>Formulas are regularly written with many symbols (often with letters from the Greek alphabet). Here’s the formula for friction (as indicated by <span data-type=\"equation\">\\vec{f}</span>):</p>\n  <div data-type=\"equation\">\\vec{f} = -\\mu N \\hat{v}</div>\n  <p>If it’s been a while since you’ve looked at a formula from a math or physics textbook, three key points are important to cover before I move on:</p>\n  <ul>\n    <li><strong>Evaluate the right side; assign to the left side.</strong> This is just like in code! In the preceding case, the left side represents what I want to calculate—the force of friction—and the right side elaborates on how to do it.</li>\n    <li><strong>Am I talking about a vector or a scalar?</strong> It’s important to realize that in some cases, you’ll be calculating a vector; in others, a scalar. For example, in this case, the force of friction is a vector. That is indicated by the arrow above the <span data-type=\"equation\">f</span>. It has a magnitude and direction. The right side of the equation also has a vector, as indicated by the symbol <span data-type=\"equation\">\\hat{v}</span>, which in this case stands for the velocity unit vector.</li>\n    <li><strong>When symbols are placed next to each other, this typically means multiply them.</strong> The right side of the friction formula has four elements: –, <em>μ</em>, <em>N</em>, and <span data-type=\"equation\">\\hat{v}</span>. They should be multiplied together, reading the formula as <span data-type=\"equation\">\\vec{f} = -1 \\times \\mu \\times N \\times \\hat{v}</span>.</li>\n  </ul>\n</div>\n<div class=\"avoid-break\">\n  <p>Open up any high school physics textbook and you’ll find diagrams and formulas describing various forces—gravity, electromagnetism, friction, tension, elasticity, and more. For the rest of this chapter, I’m going to consider three forces—friction, drag, and gravitational attraction—and show how to model them with p5.js. The point I’d like to make here is not that these are fundamental forces that you always need in your simulations. Rather, I want to demonstrate these forces as case studies for the following process:</p>\n  <ol>\n    <li>Understanding the concept behind a force</li>\n    <li>Deconstructing the force’s formula into two parts:\n      <ol>\n        <li>How do you compute the force’s direction?</li>\n        <li>How do you compute the force’s magnitude?</li>\n      </ol>\n    </li>\n    <li>Translating that formula into p5.js code that calculates a vector to be passed through a <code>Mover</code> object’s <code>applyForce()</code> method</li>\n  </ol>\n</div>\n<p>If you can follow these steps with the example forces I’ll provide here, then hopefully when you find yourself googling <em>atomic nuclei weak nuclear force</em> at 3 AM, you’ll have the skills to take what you find and adapt it for p5.js.</p>\n<h3 id=\"friction\">Friction</h3>\n<div data-type=\"video-link\" data-title=\"Friction Force\" href=\"https://www.youtube.com/watch?v=WBdhAuWS6X8&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>Let’s begin with friction and follow the preceding steps. Whenever two surfaces come into contact, they experience <strong>friction</strong>. Friction is a <strong>dissipative force</strong>, meaning it causes the kinetic energy of an object to be converted into another form, giving the impression of loss, or dissipation.</p>\n<p>Let’s say you’re driving a car. When you press your foot on the brake pedal, the car’s brakes use friction to slow the motion of the tires. Kinetic energy (motion) is converted into thermal energy (heat). A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for simplicity here, I’m going to work through only the kinetic case. Figure 2.3 shows the formula for friction.</p>\n<p>Since friction is a vector, let me separate this formula into two parts that determine the direction of friction as well as its magnitude. Figure 2.3 indicates that <em>friction points in the opposite direction of velocity.</em> In fact, that’s the part of the formula that says <span data-type=\"equation\">-1 \\times \\hat{v}</span>, or –1 times the velocity unit vector. In p5.js, this would mean taking an object’s velocity vector and multiplying it by <code>-1</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let friction = this.velocity.copy();\nfriction.normalize();\n// Let’s figure out the direction of the friction force\n// (a unit vector in the opposite direction of velocity).\nfriction.mult(-1);</pre>\n<p>Notice two additional steps here. First, it’s important to make a copy of the velocity vector, as I don’t want to reverse the object’s direction by accident. Second, the vector is normalized. This is because the magnitude of friction isn’t associated with the speed of the object, and I want to start with a vector of length 1 so it can easily be scaled.</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_4.png\" alt=\"Figure 2.3: Friction is a force that points in the opposite direction of the sled’s velocity when the sled is sliding in contact with the hill.\">\n  <figcaption>Figure 2.3: Friction is a force that points in the opposite direction of the sled’s velocity when the sled is sliding in contact with the hill.</figcaption>\n</figure>\n<p>According to the formula, the magnitude is <span data-type=\"equation\">\\mu \\times N</span>. The Greek letter <em>mu</em> (<span data-type=\"equation\">\\mu</span>, pronounced <em>mew</em>) is used here to describe the <strong>coefficient of friction</strong>. The coefficient of friction establishes the strength of a friction force for a particular surface. The higher it is, the stronger the friction; the lower, the weaker. A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper. Since this is a pretend p5.js world, I can arbitrarily set the coefficient to scale the strength of the friction:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let c = 0.01;</pre>\n<p>Now for the second part. <em>N</em> refers to the <strong>normal force</strong>, the force perpendicular to the object’s motion along a surface. Think of a vehicle driving along a road. The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road, in turn, pushes back against the vehicle. That’s the normal force. The greater the gravitational force, the greater the normal force.</p>\n<p>As you’ll see in the next section, gravitational attraction is associated with mass, and so a lightweight sports car would experience less friction than a massive tractor trailer truck. In Figure 2.3, however, because the object is moving along a surface at an angle, computing the magnitude and direction of the normal force is a bit more complex because it doesn’t point in the opposite direction of gravity. You’d need to know something about angles and trigonometry.</p>\n<p>All of these specifics are important; however, a “good enough” simulation can be achieved without them. I can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1. When I get into trigonometry in the next chapter, you could return to this question and make the friction example more sophisticated. And so:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let normal = 1;</pre>\n<p>Now that I have the magnitude and direction for friction, I can put it all together in code:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let c = 0.1;\nlet normal = 1;\n//{!1} Calculate the magnitude of friction (really just an arbitrary constant).\nlet frictionMag = c * normal;\nlet friction = mover.velocity.copy();\nfriction.mult(-1);\nfriction.normalize();\n// Take the unit vector and multiply it by the magnitude. This is the force vector!\nfriction.mult(frictionMag);</pre>\n<p>This code calculates a friction force but doesn’t answer the question of <em>when</em> to apply it. There’s no answer to this question, of course, given this is all a made-up world visualized in a 2D p5.js canvas! I’ll make the arbitrary, but logical, decision to apply friction when the circle comes into contact with the bottom of the canvas, which I can detect by adding a function to the <code>Mover</code> class, called <code>contactEdge()</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">contactEdge() {\n  // The mover is touching the edge when it’s within 1 pixel.\n  return (this.position.y > height - this.radius - 1);\n}</pre>\n<p>This is a good time for me to also mention that the actual bouncing off the edge here simulates an <em>idealized elastic collision</em>, meaning no kinetic energy is lost when the circle and the edge collide. This is rarely true in the real world; pick up a tennis ball and drop it against any surface, and the height at which it bounces will slowly lower until it rests against the ground. Many factors are at play here (including air resistance, which I’ll cover in the next section), but a quick way to simulate an inelastic collision is to reduce the magnitude of velocity by a percentage with each bounce:</p>\n<div class=\"avoid-break\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">bounceEdges() {\n  //{!1} A new variable to simulate an inelastic collision: 10% of the velocity’s x- or y-component is lost.\n  let bounce = -0.9;\n  if (this.position.y > height - this.radius) {\n    this.position.y = height - this.radius;\n    this.velocity.y *= bounce;\n  }\n}</pre>\n</div>\n<p>Finally, I can add all these pieces to the code from Example 2.3 and simulate the object experiencing three forces: wind (when the mouse is clicked), gravity (always), and now friction (when in contact with the bottom of the canvas).</p>\n<div data-type=\"example\">\n  <h3 id=\"example-24-including-friction\">Example 2.4: Including Friction</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/I4wC4aXd-E\" data-example-path=\"examples/02_forces/example_2_4_including_friction\"><img src=\"/content/examples/02_forces/example_2_4_including_friction/screenshot.png\"></div>\n    <figcaption>Clicking the mouse applies the wind force.</figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n\n  let gravity = createVector(0, 1);\n  //{!1} I should scale by mass to be more accurate, but this example has only one circle.\n  mover.applyForce(gravity);\n  if (mouseIsPressed) {\n    let wind = createVector(0.5, 0);\n    mover.applyForce(wind);\n  }\n\n  if (mover.contactEdge()) {\n    <strong>let c = 0.1;\n    let friction = mover.velocity.copy();\n    friction.mult(-1);\n    friction.setMag(c);</strong>\n    // Apply the friction force vector to the object.\n    <strong>mover.applyForce(friction);</strong>\n  }\n\n  //{!1} Call the new <code>bounceEdges()</code> method.\n  mover.bounceEdges();\n  mover.update();\n  mover.show();\n\n}</pre>\n<p>Running this example, you’ll notice that the circle eventually comes to rest. You can make this happen more or less quickly by varying the coefficient of friction as well as the percentage of speed lost in the <code>bounceEdges()</code> method.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-26\">Exercise 2.6</h3>\n  <p>Add a second object to Example 2.4. How do you handle having two objects of different masses? What if each object has its own coefficient of friction relative to the bottom surface? Does it make sense to encapsulate the friction force calculation into a <code>Mover</code> method?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-27\">Exercise 2.7</h3>\n  <p>Instead of wind, can you add functionality to this example that allows you to toss the circle via mouse interaction?</p>\n</div>\n<h3 id=\"air-and-fluid-resistance\">Air and Fluid Resistance</h3>\n<div data-type=\"video-link\" data-title=\"Drag Force\" href=\"https://www.youtube.com/watch?v=DxFDgOYEoy8\"></div>\n<p>Friction also occurs when a body passes through a liquid or gas. The resulting force has many names, all really meaning the same thing: <em>viscous force</em>, <em>drag force</em>, <em>air resistance</em>, or <em>fluid resistance</em> (see Figure 2.4).</p>\n<p>The effect of a drag force is ultimately the same as the effect in our previous friction examples: the object slows down. The exact behavior and calculation of a drag force is a bit different, however. Here’s the formula:</p>\n<div data-type=\"equation\">\\vec{F_d} = - \\frac{1}{2}\\rho{v}^2 A C_d\\hat{v}</div>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_5.png\" alt=\"Figure 2.4: A drag force (air or fluid resistance) is proportional to the speed of an object and its surface area pointing in the opposite direction of the object’s velocity.\">\n  <figcaption>Figure 2.4: A drag force (air or fluid resistance) is proportional to the speed of an object and its surface area pointing in the opposite direction of the object’s velocity.</figcaption>\n</figure>\n<p>Let me break this down to see what’s really necessary for an effective simulation in p5.js, making a simpler formula in the process:</p>\n<ul>\n  <li><span data-type=\"equation\">\\vec{F_d}</span> refers to <em>drag force</em>, the vector to compute and pass into the <code>applyForce()</code> method.</li>\n  <li>–1/2 is a constant: –0.5. While it’s an important factor to scale the force, it’s not terribly relevant here, as I’ll be making up values for other scaling constants. However, the fact that it’s negative is important, as it indicates that the force points in the opposite direction of velocity (just as with friction).</li>\n  <li><span data-type=\"equation\">\\rho</span> is the Greek letter <em>rho</em>, another constant that refers to the density of the liquid. I’ll choose to ignore this at the moment and consider it to have a constant value of 1.</li>\n  <li><span data-type=\"equation\">v</span> refers to the speed of the moving object. Okay, you’ve got this one! The object’s speed is the magnitude of the velocity vector: <code>velocity.mag()</code>. And <span data-type=\"equation\">v^2</span> just means <span data-type=\"equation\">v</span> squared, or <span data-type=\"equation\">v \\times v</span>. (I’ll note that this assumes the liquid or gas is stationary and not moving; if you drop an object into a flowing river, you’d have to also take the relative speed of the water into account.)</li>\n  <li><span data-type=\"equation\">A</span> refers to the frontal surface area of the object that’s pushing through the liquid or gas. Consider a flat sheet of paper falling through the air and compare it to a sharp pencil pointed straight down. The pencil will experience less drag because it has less surface area pointing in its direction of motion. Again, this is a constant, and to keep the implementation simple, I’ll consider all objects to have a spherical shape and ignore this element.</li>\n  <li><span data-type=\"equation\">C_d</span> is the coefficient of drag, exactly the same as the coefficient of friction (μ). This constant will determine the relative strength of the drag force.</li>\n  <li><span data-type=\"equation\">\\hat{v}</span> should look familiar. It’s the velocity unit vector, found with <code>velocity.normalize()</code>. Just like friction, drag is a force that points in the opposite direction of velocity.</li>\n</ul>\n<p>Now that I’ve analyzed each of these parts and determined what’s needed for my simulation, I can reduce the formula, as shown in Figure 2.5.</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_6.png\" alt=\"Figure 2.5: My simplified formula for a drag force\">\n  <figcaption>Figure 2.5: My simplified formula for a drag force</figcaption>\n</figure>\n<p>While I’ve written the simplified formula with <span data-type=\"equation\">C_d</span> as the lone constant representing the coefficient of drag, I can also think of it as all the constants combined (<span data-type=\"equation\">-1/2</span>, <span data-type=\"equation\">\\rho</span>, <span data-type=\"equation\">A</span>). A more sophisticated simulation might treat these constants separately; you could try factoring them in as an exercise.</p>\n<p>Here’s the p5.js version of the simplified drag formula:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let c = 0.1;\nlet speed = this.velocity.mag();\n//{!1} Part 1 of the formula (magnitude)\nlet dragMagnitude = c * speed * speed;\nlet drag = this.velocity.copy();\n// Part 2 of the formula (direction)\ndrag.mult(-1);\n// Magnitude and direction together!\ndrag.setMag(dragMagnitude);</pre>\n<p>Let’s implement this force in the <code>Mover</code> example. But when should I apply it? Earlier, I enabled the friction force to slow the mover whenever it came into contact with the bottom edge of the canvas. Now, I’ll introduce a new element to the environment: a <code>Liquid</code> object that exerts a drag force when the mover passes through it. The “liquid” will be drawn as a rectangle, with position, width, and height, and will have a coefficient of drag that sets whether it’s easy for objects to move through it (like air) or difficult (like molasses). In addition, <code>Liquid</code> will include a <code>show()</code> method so we can see the liquid on the canvas:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Liquid {\n  constructor(x, y, w, h, c) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    // The <code>Liquid</code> object includes a variable defining its coefficient of drag.\n    this.c = c;\n  }\n\n  show() {\n    noStroke();\n    fill(175);\n    rect(this.x, this.y, this.w, this.h);\n  }\n}</pre>\n<p>Now the sketch needs a <code>liquid</code> variable, initialized in <code>setup()</code>. I’ll place the liquid in the bottom half of the canvas:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let liquid;\n\nfunction setup() {\n  // Initialize a <code>Liquid</code> object.  I’m choosing a low coefficient (0.1) for a weaker effect. Try a stronger one!\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}</pre>\n<p>Now comes an interesting question: How does the <code>Mover</code> object talk to the <code>Liquid</code> object? I want to implement the following:</p>\n<blockquote data-type=\"epigraph\">\n  <p><em>When a mover passes through a liquid, that mover experiences a drag force.</em></p>\n</blockquote>\n<p>Translating that into object-oriented speak:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// If the liquid contains the mover, apply the drag force.\nif (liquid.contains(mover)) {\n  let dragForce = liquid.calculateDrag(mover);\n  mover.applyForce(dragForce);\n} </pre>\n<p>This code serves as instructions for what I need to add to the <code>Liquid</code> class: (1) a <code>contains()</code> method that determines whether a <code>Mover</code> object is inside the <code>Liquid</code> object’s area, and (2) a <code>drag()</code> method that calculates and returns the appropriate drag force to be applied to the <code>Mover</code>.</p>\n<p>The first is easy; I can use a Boolean expression to determine whether the <code>position</code> vector rests inside the rectangle defined by the liquid:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">contains(mover) {\n  // Store <code>position</code> in a separate variable to make the code more readable.\n  let pos = mover.position;\n  // This Boolean expression determines whether the position vector is contained within the rectangle defined by the <code>Liquid</code> class.\n  return (pos.x > this.x &#x26;&#x26; pos.x &#x3C; this.x + this.w &#x26;&#x26; \n          pos.y > this.y &#x26;&#x26; pos.y &#x3C; this.y + this.h);\n}</pre>\n<p>The <code>calculateDrag()</code> method is pretty easy too: I basically already wrote the code for it when I implemented the simplified drag formula! The drag force is equal to <em>the coefficient of drag multiplied by the speed of the mover squared, in the opposite direction of velocity</em>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">calculateDrag(mover) {\n  let speed = mover.velocity.mag();\n  // Calculate the force’s magnitude.\n  let dragMagnitude = this.c * speed * speed;\n  // Calculate the force’s direction.\n  let dragForce = mover.velocity.copy();\n  dragForce.mult(-1);\n  // Finalize the force: set the magnitude and direction together.\n  dragForce.setMag(dragMagnitude);\n  // Return the force.\n  return dragForce;\n}</pre>\n<p>With these two methods added to the <code>Liquid</code> class, I’m ready to put all the code together! In the following example, I’ll expand the code to use an array of evenly spaced <code>Mover</code> objects in order to demonstrate how the drag force behaves with objects of variable mass. This also illustrates an alternate way to initialize a simulation other than randomly. Look for <code>40 + i * 70</code> in the code. An initial offset of <code>40</code> provides a small margin from the edge of the canvas, and <code>i * 70</code> uses the index of the object to evenly space the movers. The margin and multiplier are arbitrary; you might try other values or consider other ways to calculate the spacing based on the canvas dimensions.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-25-fluid-resistance\">Example 2.5: Fluid Resistance</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/FknzcAaVh\" data-example-path=\"examples/02_forces/example_2_5_fluid_resistance\"><img src=\"/content/examples/02_forces/example_2_5_fluid_resistance/screenshot.png\"></div>\n    <figcaption>Clicking the mouse resets the sketch.</figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let movers = [];\nlet liquid;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize an array of <code>Mover</code> objects.\n  for (let i = 0; i &#x3C; 9; i++) {\n    // Use a random mass for each one.\n    let mass = random(0.1, 5);\n    // The x-values are spaced out evenly according to <code>i</code>.\n    movers[i] = new Mover(40 + i * 70, 0, mass);\n  }\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}\n\nfunction draw() {\n  background(255);\n\n  // Draw the liquid.\n  liquid.show();\n\n  for (let i = 0; i &#x3C; movers.length; i++) {\n    // Is the mover in the liquid?\n    if (liquid.contains(movers[i])) {\n      // Calculate the drag force.\n      let dragForce = liquid.drag(movers[i]);\n      // Apply the drag force to the mover.\n      movers[i].applyForce(dragForce);\n    }\n\n    // Gravity is scaled by mass here!\n    let gravity = createVector(0, 0.1 * movers[i].mass);\n    // Apply gravity.\n    movers[i].applyForce(gravity);\n    // Update and display the mover.\n    movers[i].update();\n    movers[i].show();\n    movers[i].checkEdges();\n  }\n}</pre>\n<p>Running the example, you may notice that it appears to simulate objects falling into water. The objects slow down only when crossing through the gray area at the bottom of the window (representing the liquid). You’ll also notice that the smaller objects slow down a great deal more than the larger objects. Remember Newton’s second law? Acceleration equals force <em>divided by mass</em> (<span data-type=\"equation\">\\vec{A} = \\vec{F} / M</span>), so a massive object will accelerate less, and a smaller object will accelerate more. In this case, the acceleration is the slowing down due to drag. The smaller objects slow down at a greater rate than the larger ones.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-28\">Exercise 2.8</h3>\n  <p>You might notice that if you set the coefficient of drag too high in Example 2.5, the circles may bounce off of the liquid! This is due to the inaccuracy of the large time steps that I mentioned earlier in this chapter. A drag force will cause an object to stop but never to reverse direction. How can you use the vector <code>limit()</code> method to correct this issue? You might also try dropping the objects from variable heights. How does this affect the drag as they hit the liquid?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-29\">Exercise 2.9</h3>\n  <p>The original formula for drag included surface area. Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-210\">Exercise 2.10</h3>\n  <p>In addition to drag being a force in opposition to the velocity vector, a drag force can be perpendicular. Known as <strong>lift-induced drag</strong>, this will cause an airplane with an angled wing to rise in altitude. Try creating a simulation of lift.</p>\n</div>\n<h3 id=\"gravitational-attraction\">Gravitational Attraction</h3>\n<div data-type=\"video-link\" data-title=\"Gravitational Attraction\" href=\"https://www.youtube.com/watch?v=EpgB3cNhKPM&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/02_forces/02_forces_7.png\" alt=\"Figure 2.6: The gravitational force between two bodies is proportional to the mass of those bodies and inversely proportional to the square of the distance between them. \">\n    <figcaption>Figure 2.6: The gravitational force between two bodies is proportional to the mass of those bodies and inversely proportional to the square of the distance between them.</figcaption>\n  </figure>\n</div>\n<p>Probably the most famous force of all is gravitational attraction. We humans on Earth think of gravity as stuff falling down, like an apple hitting Sir Isaac Newton on the head. But this is only our <em>experience</em> of gravity. The reality is more complicated.</p>\n<p>In truth, just as Earth pulls the apple toward it because of a gravitational force, the apple pulls Earth as well (this is Newton’s third law). Earth is just so freaking massive that it overwhelms all the other gravity interactions. In fact, every object with mass exerts a gravitational force on every other object. The formula for calculating the strengths of these forces is depicted in Figure 2.6.</p>\n<p>Let’s examine this formula a bit more closely:</p>\n<ul>\n  <li><span data-type=\"equation\">\\vec{F_g}</span> refers to the gravitational force, the vector to compute and pass into the <code>applyForce()</code> method.</li>\n  <li><span data-type=\"equation\">G</span> is the <em>universal gravitational constant</em>, which in our world equals <span data-type=\"equation\">6.67428 \\times 10^{-11}</span> meters cubed per kilogram per second squared. This is a pretty important number if you’re a human being, but it’s not so important if you’re a shape wandering around a p5.js canvas. Again, it’s a constant that can be used to scale the forces in the world, making them stronger or weaker. Just setting it equal to 1 and ignoring it isn’t such a terrible choice either.</li>\n  <li><span data-type=\"equation\">m_1</span> and <span data-type=\"equation\">m_2</span> are the masses of objects 1 and 2. As I initially did with Newton’s second law (<span data-type=\"equation\">\\vec{F} = M \\times \\vec{A}</span>), mass is also something I could choose to ignore. After all, shapes drawn onscreen don’t have a physical mass. However, if you keep track of this value, you can create more interesting simulations in which “bigger” objects exert a stronger gravitational force than “smaller” ones.</li>\n  <li><span data-type=\"equation\">\\hat{r}</span> refers to the unit vector pointing from object 1 to object 2. As you’ll see in a moment, this direction vector can be computed by subtracting the position of one object from the other.</li>\n  <li><span data-type=\"equation\">r^2</span> is the distance between the two objects squared.</li>\n</ul>\n<p>Take a moment to think about this formula. With everything on the top of the formula—<span data-type=\"equation\">G</span>, <span data-type=\"equation\">m_1</span>, <span data-type=\"equation\">m_2</span>—the bigger its value, the stronger the force. Big mass, big force. Big <span data-type=\"equation\">G</span>, big force. For <span data-type=\"equation\">r^2</span> on the bottom, however, it’s the opposite: the bigger the value (the farther away the object), the weaker the force. Mathematically, the strength of the gravitational force is <strong>inversely proportional</strong> to the distance squared.</p>\n<p>Now it’s time to figure out how to translate this formula into p5.js code. For that, I’ll make the following assumptions:</p>\n<ul>\n  <li>There are two objects.</li>\n  <li>Each object has a position: <code>position1</code> and <code>position2</code>.</li>\n  <li>Each object has a mass: <code>mass1</code> and <code>mass2</code>.</li>\n  <li>The variable <code>G</code> represents the universal gravitational constant.</li>\n</ul>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/02_forces/02_forces_8.png\" alt=\"Figure 2.7: An acceleration vector pointing toward the mouse position\">\n    <figcaption>Figure 2.7: An acceleration vector pointing toward the mouse position</figcaption>\n  </figure>\n</div>\n<p>Given these assumptions, I want to compute a vector, the force of gravity. I’ll do it in two parts. First, I’ll compute the direction of the force (<span data-type=\"equation\">\\hat{r}</span> in the formula). Second, I’ll calculate the strength of the force according to the masses and distance.</p>\n<p>Remember in Chapter 1, when I created an object accelerating toward the mouse (see Figure 2.7)? As I showed then, a vector can be thought of as the difference between two points, so to calculate a vector pointing from the circle to the mouse, I subtracted one point from another:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let direction = p5.Vector.sub(mouse, position);</pre>\n<p>Now I can do the same thing to calculate <span data-type=\"equation\">\\hat{r}</span>. The direction of the attraction force that object 1 exerts on object 2 is equal to the following:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let direction = p5.Vector.sub(position1, position2);\ndirection.normalize();</pre>\n<p>Don’t forget that since I want a unit vector, a vector that indicates direction only, it’s important to <em>normalize</em> the vector after subtracting the positions. (Later, I might skip this step and use <code>setMag()</code> instead.)</p>\n<p>Now that I have the direction of the force, I need to compute its magnitude and scale the vector accordingly:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let magnitude = (G * mass1 * mass2) / (distance * distance);\ndir.mult(magnitude);</pre>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/02_forces/02_forces_9.png\" alt=\"Figure 2.8: A vector that points from one position to another is calculated as the difference between positions. \">\n    <figcaption>Figure 2.8: A vector that points from one position to another is calculated as the difference between positions.</figcaption>\n  </figure>\n</div>\n<p>The only problem is that I don’t know the distance. The values of <code>G</code>, <code>mass1</code>, and <code>mass2</code> are all givens, but I need to calculate <code>distance</code> before the preceding code will work. But wait, didn’t I just make a vector that points all the way from one object’s position to the other? The length of that vector should be the distance between the two objects (see Figure 2.8).</p>\n<p>Indeed, if I add one more line of code and grab the magnitude of that vector before normalizing it, I’ll have the distance. And this time, I’ll skip the <code>normalize()</code> step and use <code>setMag()</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The vector that points from one object to another\nlet force = p5.Vector.sub(position2, position1);\n// The length (magnitude) of that vector is the distance between the two objects.\nlet distance = force.mag();\n// Use the formula for gravity to compute the strength of the force.\nlet magnitude = (G * mass1 * mass2) / (distance * distance);\n// Normalize and scale the force vector to the appropriate magnitude.\nforce.setMag(magnitude);</pre>\n<p>Note that I also changed the name of the <code>direction</code> vector to <code>force</code>. After all, when the calculations are finished, the vector I started with ends up being the actual force vector I wanted all along.</p>\n<p>Now that I’ve worked out the math and code for calculating an attractive force (emulating gravitational attraction), let’s turn our attention to applying this technique in the context of an actual p5.js sketch. I’ll continue to use the <code>Mover</code> class as a starting point—a template for making objects with position, velocity, and acceleration vectors, as well as an <code>applyForce()</code> method. I’ll take this class and put it in a sketch with the following:</p>\n<ul>\n  <li>A single <code>Mover</code> object</li>\n  <li>A single <code>Attractor</code> object (a new class that will have a fixed position)</li>\n</ul>\n<p>The <code>Mover</code> object will experience a gravitational pull toward the <code>Attractor</code> object, as illustrated in Figure 2.9.</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_10.png\" alt=\"Figure 2.9: One mover and one attractor. The mover experiences a gravitational force toward the attractor.\">\n  <figcaption>Figure 2.9: One mover and one attractor. The mover experiences a gravitational force toward the attractor.</figcaption>\n</figure>\n<p>I’ll start by creating a basic <code>Attractor</code> class, giving it a position and a mass, along with a method to draw itself (tying mass to size):</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Attractor {\n  constructor() {\n    // The attractor is an object that doesn’t move. It needs just a mass and a position.\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}</pre>\n<p>In the sketch, I’ll add a variable to hold an object instance of the <code>Attractor</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let mover;\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  mover = new Mover(300, 100, 5);\n  // Initialize the <code>Attractor</code> object.\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Draw the <code>Attractor</code> object.\n  attractor.show();\n  mover.update();\n  mover.show();\n}</pre>\n<p>This is a good start: a sketch with a <code>Mover</code> object and an <code>Attractor</code> object, made from classes that handle the variables and behaviors of movers and attractors. The last piece of the puzzle is getting one object to attract the other. How do these two objects communicate? This could be done in various ways. Here are just some of the possibilities:</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"width:300px\">Task</th>\n      <th>Function</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n        <ol start=\"1\">\n          <li>A global function that receives both an <code>Attractor</code> and a <code>Mover</code>.</li>\n        </ol>\n      </td>\n      <td>\n        <pre><code>attraction(attractor, mover);</code></pre>\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <ol start=\"2\">\n          <li>A method in the <code>Attractor</code> class that receives a <code>Mover</code>.</li>\n        </ol>\n      </td>\n      <td>\n        <pre><code>attractor.attract(mover);</code></pre>\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <ol start=\"3\">\n          <li>A method in the <code>Mover</code> class that receives an <code>Attractor</code>.</li>\n        </ol>\n      </td>\n      <td>\n        <pre><code>mover.attractedTo(attractor);</code></pre>\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <ol start=\"4\">\n          <li>A method in the <code>Attractor</code> class that receives a <code>Mover</code> and returns a <code>p5.Vector</code>, which is the attraction force. That attraction force is then passed into the <code>Mover</code> object’s <code>applyForce()</code> method.</li>\n        </ol>\n      </td>\n      <td>\n        <pre><code>let force = attractor.attract(mover);\nmover.applyForce(force);</code></pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<p>It’s good to consider a range of options, and you could probably make arguments for each of these approaches. I’d like to at least discard the first one, since I tend to prefer an object-oriented approach rather than an arbitrary function not tied to either the <code>Mover</code> or <code>Attractor</code> class. Whether you pick option 2 or option 3 is the difference between saying, “The attractor attracts the mover” and “The mover is attracted to the attractor.” Option 4 is really my favorite, though. I spent a lot of time working out the <code>applyForce()</code> method, and I think the examples are clearer continuing with the same technique of using this method to apply the forces.</p>\n<p>In other words, where I once wrote</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Made-up force\nlet force = createVector(0, 0.1);\nmover.applyForce(force);</pre>\n<div class=\"avoid-break\">\n  <p>I now have this:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} Attraction force between two objects\n<strong>let force = attractor.attract(mover);</strong>\nmover.applyForce(force);</pre>\n</div>\n<p>And so the <code>draw()</code> function can be written as shown here:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n\n  //{!2} Calculate the attraction force and apply it.\n  <strong>let force = attractor.attract(mover);\n  mover.applyForce(force);</strong>\n  mover.update();\n\n  attractor.show();\n  mover.show();\n}</pre>\n<p>I’m almost there. Since I decided to put the <code>attract()</code> method inside the <code>Attractor</code> class, I still need to actually write that method. It should receive a <code>Mover</code> object and return a <code>p5.Vector</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  attract(m) {\n    // All the math\n    return ______________;\n  }</pre>\n<p>What goes inside the method? All of that nice math for gravitational attraction!</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  attract(mover) {\n    //{!1} What’s the force’s direction?\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    // Calculate the strength of the attraction force.\n    let strength = (this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n\n    // Return the force so it can be applied!\n    return force;\n  }</pre>\n<p>And I’m done. Sort of. Almost. I need to work out one small kink. Look at the code for the <code>attract()</code> method again. See that slash symbol for division? Whenever you have one of those, you should ask yourself this question: What would happen if the distance happened to be a really, really small number, or (even worse!) 0? You can’t divide a number by 0, and if you were to divide a number by something tiny like 0.0001, that’s the equivalent of multiplying that number by 10,000! That may be a viable outcome of this formula for gravitational attraction in the real world, but p5.js isn’t the real world. In the p5.js world, the mover could end up being very, very close to the attractor, and the resulting force could be so strong that the mover flies way off the canvas.</p>\n<p>Conversely, what if the mover were to be, say, 500 pixels from the attractor (not unreasonable in p5.js)? You’re squaring the distance, so this will result in dividing the force by 250,000. That force might end up being so weak that it’s almost as if it’s not applied at all.</p>\n<p>To avoid both extremes, it’s practical to constrain the range of <code>distance</code> before feeding it into the formula. Maybe, no matter where the <code>Mover</code> <em>actually</em> is, you should never consider it to be less than 5 pixels or more than 25 pixels away from the attractor, for the purposes of calculating the force of gravitational attraction:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  // Here the <code>constrain()</code> function limits the value of distance between a minimum (5) and maximum (25).\n  distance = constrain(distance, 5, 25);</pre>\n<p>Ultimately, it’s up to you to choose the behaviors you want from your simulation. But if you decide you want a reasonable-looking attraction that’s never absurdly weak or strong, constraining the distance is a good technique.</p>\n<p>The <code>Mover</code> class hasn’t changed at all, so let’s just look at the main sketch and the <code>Attractor</code> class as a whole, adding a variable <code>G</code> for the universal gravitational constant. (On the book’s website, you’ll find that this example also has code that allows you to move the <code>Attractor</code> object with the mouse.)</p>\n<div data-type=\"example\">\n  <h3 id=\"example-26-attraction\">Example 2.6: Attraction</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/Cl0Eeaz_V\" data-example-path=\"examples/02_forces/example_2_6_attraction\"><img src=\"/content/examples/02_forces/example_2_6_attraction/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// A mover and an attractor\nlet mover;\nlet attractor;\n// A gravitational constant (for global scaling)\nlet G = 1.0;\n\nfunction setup() {\n  createCanvas(640, 240);\n  mover = new Mover(300, 50, 2);\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!2} Apply the attraction force from the attractor on the mover.\n  let force = attractor.attract(mover);\n  mover.applyForce(force);\n  mover.update();\n  attractor.show();\n  mover.show();\n}\n\nclass Attractor {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  attract(mover) {\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    //{!1} Remember, you need to constrain the distance so your circle doesn’t spin out of control.\n    distance = constrain(distance, 5, 25);\n    let strength = (G * this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n    return force;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}</pre>\n<p>In this code, the diameter of the mover and attractor is scaled according to the mass of each object. However, this doesn’t accurately reflect how mass and size are related in our physical world. The area of a circle is calculated with the formula <span data-type=\"equation\">\\pi{r^2}</span>, where <span data-type=\"equation\">r</span> represents the radius (half the diameter) of the circle. (More about <span data-type=\"equation\">\\pi</span> to come in Chapter 3!) As such, to represent an object’s mass proportionally with a circle’s area more accurately, I should really take the square root of the mass and scale that as the diameter of the circle.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-211\">Exercise 2.11</h3>\n  <p>Adapt Example 2.6 to map the mass of the <code>Attractor</code> and <code>Mover</code> to the area of their respective circles:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">circle(this.position.x, this.position.y, <span class=\"blank\">sqrt</span>(this.mass) * 2);</pre>\n</div>\n<p>You could, of course, expand the code to include one <code>Attractor</code> and an array of many <code>Mover</code> objects, just as I included an array of <code>Mover</code> objects in Example 2.5 previously.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-27-attraction-with-many-movers\">Example 2.7: Attraction with Many Movers</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/LSXJ6-VziJ\" data-example-path=\"examples/02_forces/example_2_7_attraction_with_many_movers\"><img src=\"/content/examples/02_forces/example_2_7_attraction_with_many_movers/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Now you have 10 movers!\nlet movers = [];\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  for (let i = 0; i &#x3C; 10; i++) {\n    // Each mover is initialized randomly.\n    movers[i] = new Mover(random(width), random(height), random(0.5, 3));\n  }\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  attractor.show();\n  for (let i = 0; i &#x3C; movers.length; i++) {\n    //{!1} Calculate an attraction force for each <code>Mover</code> object.\n    let force = attractor.attract(movers[i]);\n    movers[i].applyForce(force);\n    movers[i].update();\n    movers[i].show();\n  }\n}</pre>\n<p>This is just a small taste of what’s possible with arrays of objects. Stay tuned for a more in-depth exploration of adding and removing multiple objects from the canvas in <a href=\"/particles#section-particles\">Chapter 4</a>, which covers particle systems.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-212\">Exercise 2.12</h3>\n  <p>In Example 2.7, there’s a system (an array) of <code>Mover</code> objects and one <code>Attractor</code> object. Build an example that has systems of both movers and attractors. What if you make the attractors invisible? Can you create a pattern/design from the trails of objects moving around attractors?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-213\">Exercise 2.13</h3>\n  <p>This chapter isn’t suggesting that every good p5.js simulation needs to involve gravitational attraction. Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects, using my approach to simulating gravitational attraction as a model. For example, what happens if you design an attractive force that gets weaker as the objects get closer, and stronger as the objects get farther apart? Or what if you design your attractor to attract faraway objects but repel close ones?</p>\n</div>\n<h2 id=\"the-n-body-problem\">The n-Body Problem</h2>\n<div data-type=\"video-link\" data-title=\"Mutual Attraction\" href=\"https://www.youtube.com/watch?time_continue=1&#x26;v=GjbKsOkN1Oc&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p>I started exploring gravitational attraction with a simple scenario, <em>one object attracts another object</em>, then moved on to the slightly more complex <em>one object attracts many objects</em>. A logical next step is to explore what happens when <em>many objects attract many objects</em>!</p>\n<p>To begin, while having separate <code>Mover</code> and <code>Attractor</code> classes has been helpful so far, this distinction is a bit misleading. After all, according to Newton’s third law, all forces occur in pairs: if an attractor attracts a mover, then that mover should also attract the attractor. Instead of two classes here, what I really want is a single type of thing—called, for example, a <code>Body</code>—with every body attracting every other body.</p>\n<p>The scenario I’m describing is commonly referred to as the <strong><em>n</em></strong><strong>-body problem</strong>. It involves solving for the motion of a group of objects that interact via gravitational forces. The <em>two</em>-body problem is a famously solved problem, meaning the motions can be precisely computed with mathematical equations when only two bodies are involved. However, adding one more body turns the <em>two</em>-body problem into a <em>three</em>-body problem, and suddenly no formal solution exists (see Figure 2.10).</p>\n<figure>\n  <img src=\"/content/images/02_forces/02_forces_11.png\" alt=\"Figure 2.10: Example paths of the two-body (predictable) versus three-body (complex) problems\">\n  <figcaption>Figure 2.10: Example paths of the two-body (predictable) versus three-body (complex) problems</figcaption>\n</figure>\n<p>Although less accurate than using precise equations of motion, the examples built in this chapter can model both the two-body and three-body problems. To begin, I’ll move the <code>attract()</code> method from the <code>Attractor</code> class into the <code>Mover</code> class (which I will now call <code>Body</code>):</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The mover is now called a body.\nclass Body {\n\n  /* All the other stuff from before */\n\n  // The <code>attract()</code> method is now part of the Body class.\n  attract(body) {\n    let force = p5.Vector.sub(this.position, body.position);\n    let d = constrain(force.mag(), 5, 25);\n    let strength = (G * (this.mass * body.mass)) / (d * d);\n    force.setMag(strength);\n    body.applyForce(force);\n  }\n}</pre>\n<p>Now it’s just a matter of creating two <code>Body</code> objects (let’s call them <code>bodyA</code> and <code>bodyB</code>) and ensuring that they both attract each other:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bodyA;\nlet bodyB;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create two <code>Body</code> objects, <code>A</code> and <code>B</code>.\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n}\n\nfunction draw() {\n  background(255);\n  //{!2} <code>A</code> attracts <code>B</code>, and <code>B</code> attracts <code>A</code>.\n  bodyA.attract(bodyB);\n  bodyB.attract(bodyA);\n  bodyA.update();\n  bodyA.show();\n  bodyB.update();\n  bodyB.show();\n}</pre>\n<p>For any <em>n</em>-body problem, the resulting motion and patterns are entirely dependent on the initial conditions. For example, if I were to assign specific velocity vectors for each body in <code>setup()</code>, one pointing to the right and one pointing to the left, the result is a circular orbit.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-28-two-body-attraction\">Example 2.8: Two-Body Attraction</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/cmj37xPCM\" data-example-path=\"examples/02_forces/example_2_8_two_body_attraction\"><img src=\"/content/examples/02_forces/example_2_8_two_body_attraction/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function setup() {\n  createCanvas(640, 240);\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n  // Assign horizontal velocities (in opposite directions) to each body.\n  bodyA.velocity = createVector(1, 0);\n  bodyB.velocity = createVector(-1, 0);\n}</pre>\n<p>Example 2.8 could be improved by refactoring the code to include constructor arguments that assign the body velocities. For now, however, this approach serves as a quick way to experiment with patterns based on various initial positions and velocities.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-214\">Exercise 2.14</h3>\n  <p>The paper <a href=\"https://doi.org/10.1017/fms.2013.5\">“Classification of Symmetry Groups for Planar <em>n</em>-Body Choreographies” by James Montaldi and Katrina Steckles</a> explores <em>choreographic</em> solutions to the <em>n</em>-body problem (defined as periodic motions of bodies following one another at regular intervals). Educator and artist Dan Gries created <a href=\"https://dangries.com/rectangleworld/demos/nBody\">an interactive demonstration of these choreographies</a>. Try adding a third (or more!) body to Example 2.8 and experiment with setting initial positions and velocities. What choreographies can you achieve?</p>\n</div>\n<p>I’m now ready to move on to an example with <em>n</em> bodies by incorporating an array:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Start with an empty array.\nlet bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Fill the array with <code>Body</code> objects.\n  for (let i = 0; i &#x3C; 10; i++) {\n    bodies[i] = new Body(random(width), random(height));\n  }\n}\n\nfunction draw() {\n  background(255);\n  // Iterate over the array to update and show all bodies.\n  for (let i = 0; i &#x3C; bodies.length; i++) {\n    bodies[i].update();\n    bodies[i].show();\n  }\n}</pre>\n<p>The <code>draw()</code> function is where I need to work some magic so that every body exerts a gravitational force on every other body. Right now, the code reads, “For every body <code>i</code>, update and draw.” To attract every other body <code>j</code> with each body <code>i</code>, I need to nest a second loop and adjust the code to say, “For every body <code>i</code>, attract every other body <code>j</code> (and update and draw).”</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  //{!2} For every body, check every body!\n  for (let i = 0; i &#x3C; bodies.length; i++) {\n    for (let j = 0; j &#x3C; bodies.length; j++) {\n      let force = bodies[j].attract(bodies[i]);\n      movers[i].applyForce(force);\n    }\n    movers[i].update();\n    movers[i].show();\n  }</pre>\n<p>The code has one small problem, though. When every body <code>i</code> attracts every body <code>j</code>, what happens when <code>i</code> equals <code>j</code>? Should body index 3 attract body index 3? The answer, of course, is no. If you have five bodies, you want body index 3 to attract only bodies 0, 1, 2, and 4, skipping itself. I’ll account for this by adding a conditional statement to skip applying the force when <code>i</code> equals <code>j</code>.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-29-n-bodies\">Example 2.9: n Bodies</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/uT9VpVvCO\" data-example-path=\"examples/02_forces/example_2_9_n_bodies\"><img src=\"/content/examples/02_forces/example_2_9_n_bodies/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i &#x3C; 10; i++) {\n    bodies[i] = new Body(random(width), random(height), random(0.1, 2));\n  }\n}\n\nfunction draw() {\n  background(255);\n\n  for (let i = 0; i &#x3C; bodies.length; i++) {\n    for (let j = 0; j &#x3C; bodies.length; j++) {\n      //{!1} Do not attract yourself!\n      if (i !== j) {\n        let force = bodies[j].attract(bodies[i]);\n        bodies[i].applyForce(force);\n      }\n    }\n    bodies[i].update();\n    bodies[i].show();\n  }\n}</pre>\n<p>The nested loop solution in Example 2.9 leads to what’s called an <em>n</em>-squared algorithm, meaning the number of calculations is equal to the number of bodies squared. If I were to increase the number of bodies, the simulation would start to slow significantly because of the number of calculations required.</p>\n<p>In <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a>, I’ll explore strategies for optimizing sketches like this one, with a particular focus on spatial subdivision algorithms. Spatial subdivision, in combination with the concept of quadtrees and an algorithm called Barnes-Hut, is particularly effective for improving efficiency in simulations such as the <em>n</em>-body one discussed here.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-215\">Exercise 2.15</h3>\n  <p>Change the attraction force in Example 2.9 to a repulsion force. Can you create an example in which all the <code>Body</code> objects are attracted to the mouse but repel one another? Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-216\">Exercise 2.16</h3>\n  <p>Can you arrange the bodies of the <em>n</em>-body simulation to orbit the center of the canvas in a pattern that resembles a spiral galaxy? You may need to include an additional large body in the center to hold everything together. A solution is offered in my <a href=\"https://thecodingtrain.com/nbody\">“Mutual Attraction” video in the Nature of Code series on the Coding Train website</a>.</p>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/Qxahj4k5D\" data-example-path=\"examples/02_forces/exercise_2_16\"><img src=\"/content/examples/02_forces/exercise_2_16/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<div data-type=\"project\">\n  <h3 id=\"the-ecosystem-project-3\">The Ecosystem Project</h3>\n  <p>Incorporate forces into your ecosystem. How might other environmental factors (for example, water versus mud, or the current of a river) affect the way a character moves through an ecosystem?</p>\n  <p>Try introducing other elements into the environment (food, a predator) for the creature to interact with. Does the creature experience attraction or repulsion to things in its world? Can you think more abstractly and design forces based on the creature’s desires or goals?</p>\n  <figure>\n    <img src=\"/content/images/02_forces/02_forces_12.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n</div>\n</section>",
  "codeBlocks": [
    {
      "id": "code-0",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-1",
      "language": "javascript",
      "code": "mover.applyForce(wind);",
      "lineNumbers": false
    },
    {
      "id": "code-2",
      "language": "javascript",
      "code": "mover.applyForce(gravity);",
      "lineNumbers": false
    },
    {
      "id": "code-3",
      "language": "javascript",
      "code": "applyForce(force) {\n  // Newton’s second law at its simplest\n  this.acceleration = force;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-4",
      "language": "javascript",
      "code": "mover.applyForce(wind);\nmover.applyForce(gravity);\nmover.update();",
      "lineNumbers": false
    },
    {
      "id": "code-5",
      "language": "javascript",
      "code": "this.velocity.add(this.acceleration);",
      "lineNumbers": false
    },
    {
      "id": "code-6",
      "language": "javascript",
      "code": "applyForce(force) {\n  // Newton’s second law, but with force accumulation, adding all input forces to acceleration\n  this.acceleration.add(force);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-7",
      "language": "javascript",
      "code": "if (mouseIsPressed) {\n  let wind = createVector(0.5, 0);\n  mover.applyForce(wind);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-8",
      "language": "javascript",
      "code": "update() {\n  this.velocity.add(this.acceleration);\n  this.position.add(this.velocity);\n  // Clear acceleration after it’s been applied.\n  this.acceleration.mult(0);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-9",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    this.position = createVector();\n    this.velocity = createVector();\n    this.acceleration = createVector();\n    // Add mass as a number.\n    this.mass = ????;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-10",
      "language": "javascript",
      "code": "constructor() {\n  this.position = createVector(random(width), random(height));\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n  this.mass = 10;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-11",
      "language": "javascript",
      "code": "applyForce(force) {\n  // Newton’s second law (with force accumulation and mass)\n  force.div(this.mass);\n  this.acceleration.add(force);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-12",
      "language": "javascript",
      "code": "let moverA = new Mover();\nlet moverB = new Mover();\n\nlet wind = createVector(1, 0);\n\nmoverA.applyForce(wind);\nmoverB.applyForce(wind);",
      "lineNumbers": true
    },
    {
      "id": "code-13",
      "language": "javascript",
      "code": "applyForce(force) {\n  //{!1} Make a copy of the vector before using it.\n  let f = force.copy();\n  //{!1} Divide the copy by mass.\n  f.div(this.mass);\n  this.acceleration.add(f);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-14",
      "language": "javascript",
      "code": "applyForce(force) {\n  let f = <span class=\"blank\">p5.Vector.div</span>(<span class=\"blank\">force</span>, <span class=\"blank\">this.mass</span>);\n  this.acceleration.add(f);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-15",
      "language": "javascript",
      "code": "let wind = createVector(0.01, 0);\nmover.applyForce(wind);",
      "lineNumbers": false
    },
    {
      "id": "code-16",
      "language": "javascript",
      "code": "let gravity = createVector(0, 0.1);\nmover.applyForce(gravity);\n\nif (mouseIsPressed) {\n  let wind = createVector(0.1, 0);\n  mover.applyForce(wind);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-17",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    //{!1} For now, set the mass equal to 1 for simplicity.\n    this.mass = 1;\n    this.position = createVector(width / 2, 30);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n  }\n\n  // Newton’s second law\n  applyForce(force) {\n    // Receive a force, divide by mass, and add to acceleration.\n    let f = p5.Vector.div(force, this.mass);\n    this.acceleration.add(f);\n  }\n\n  update() {\n    // Motion 101 from Chapter 1\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    // Now add clearing the acceleration each time!\n    this.acceleration.mult(0);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // Scale the size according to mass. Stay tuned for an improvement on this to come later in the chapter!\n    circle(this.position.x, this.position.y, this.mass * 16);\n  }\n\n  // Somewhat arbitrarily, I’ve decided that an object bounces when it hits the edges of the canvas.\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = width;\n      this.velocity.x *= -1;\n    } else if (this.position.x < 0) {\n      this.velocity.x *= -1;\n      this.position.x = 0;\n    }\n\n    if (this.position.y > height) {\n      // Even though I said not to touch position and velocity directly, exceptions exist. Here, I’m doing so as a quick way to reverse the direction of the object when it reaches the edge.\n      this.velocity.y *= -1;\n      this.position.y = height;\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-18",
      "language": "javascript",
      "code": "let moverA = new Mover();\nlet moverB = new Mover();",
      "lineNumbers": false
    },
    {
      "id": "code-19",
      "language": "javascript",
      "code": "constructor() {\n  //{!2} Every object has a mass of 1 and a position of (width / 2, 30).\n  this.mass = 1;\n  this.position = createVector(width / 2, 30);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-20",
      "language": "javascript",
      "code": "constructor(x, y, mass) {\n  //{!2} Now set these variables with arguments.\n  this.mass = mass;\n  this.position = createVector(x, y);\n  this.velocity = createVector(0, 0);\n  this.acceleration = createVector(0, 0);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-21",
      "language": "javascript",
      "code": "// A large mover on the left side of the canvas\nlet moverA = new Mover(100, 30, 10);\n// A smaller mover on the right side of the canvas\nlet moverB = new Mover(400, 30, 2);",
      "lineNumbers": false
    },
    {
      "id": "code-22",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n\n  // Make up a gravity force and apply it.\n  let gravity = createVector(0, 0.1);\n  moverA.applyForce(gravity);\n  moverB.applyForce(gravity);\n  // Make up a wind force and apply it when the mouse is clicked.\n  if (mouseIsPressed) {\n    let wind = createVector(0.1, 0);\n    moverA.applyForce(wind);\n    moverB.applyForce(wind);\n  }\n\n  moverA.checkEdges();\n  moverA.update();\n  moverA.show();\n\n  moverB.checkEdges();\n  moverB.update();\n  moverB.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-23",
      "language": "javascript",
      "code": "// Made-up gravity force\nlet gravity = createVector(0, 0.1);\n// Scale by mover A’s mass.\nlet gravityA = p5.Vector.mult(gravity, moverA.mass);\nmoverA.applyForce(gravityA);\n// Scale by mover B’s mass.\nlet gravityB = p5.Vector.mult(gravity, moverB.mass);\nmoverB.applyForce(gravityB);",
      "lineNumbers": true
    },
    {
      "id": "code-24",
      "language": "javascript",
      "code": "let friction = this.velocity.copy();\nfriction.normalize();\n// Let’s figure out the direction of the friction force\n// (a unit vector in the opposite direction of velocity).\nfriction.mult(-1);",
      "lineNumbers": false
    },
    {
      "id": "code-25",
      "language": "javascript",
      "code": "let c = 0.01;",
      "lineNumbers": false
    },
    {
      "id": "code-26",
      "language": "javascript",
      "code": "let normal = 1;",
      "lineNumbers": false
    },
    {
      "id": "code-27",
      "language": "javascript",
      "code": "let c = 0.1;\nlet normal = 1;\n//{!1} Calculate the magnitude of friction (really just an arbitrary constant).\nlet frictionMag = c * normal;\nlet friction = mover.velocity.copy();\nfriction.mult(-1);\nfriction.normalize();\n// Take the unit vector and multiply it by the magnitude. This is the force vector!\nfriction.mult(frictionMag);",
      "lineNumbers": true
    },
    {
      "id": "code-28",
      "language": "javascript",
      "code": "contactEdge() {\n  // The mover is touching the edge when it’s within 1 pixel.\n  return (this.position.y > height - this.radius - 1);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-29",
      "language": "javascript",
      "code": "bounceEdges() {\n  //{!1} A new variable to simulate an inelastic collision: 10% of the velocity’s x- or y-component is lost.\n  let bounce = -0.9;\n  if (this.position.y > height - this.radius) {\n    this.position.y = height - this.radius;\n    this.velocity.y *= bounce;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-30",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n\n  let gravity = createVector(0, 1);\n  //{!1} I should scale by mass to be more accurate, but this example has only one circle.\n  mover.applyForce(gravity);\n  if (mouseIsPressed) {\n    let wind = createVector(0.5, 0);\n    mover.applyForce(wind);\n  }\n\n  if (mover.contactEdge()) {\n    <strong>let c = 0.1;\n    let friction = mover.velocity.copy();\n    friction.mult(-1);\n    friction.setMag(c);</strong>\n    // Apply the friction force vector to the object.\n    <strong>mover.applyForce(friction);</strong>\n  }\n\n  //{!1} Call the new <code>bounceEdges()</code> method.\n  mover.bounceEdges();\n  mover.update();\n  mover.show();\n\n}",
      "lineNumbers": true
    },
    {
      "id": "code-31",
      "language": "javascript",
      "code": "let c = 0.1;\nlet speed = this.velocity.mag();\n//{!1} Part 1 of the formula (magnitude)\nlet dragMagnitude = c * speed * speed;\nlet drag = this.velocity.copy();\n// Part 2 of the formula (direction)\ndrag.mult(-1);\n// Magnitude and direction together!\ndrag.setMag(dragMagnitude);",
      "lineNumbers": true
    },
    {
      "id": "code-32",
      "language": "javascript",
      "code": "class Liquid {\n  constructor(x, y, w, h, c) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    // The <code>Liquid</code> object includes a variable defining its coefficient of drag.\n    this.c = c;\n  }\n\n  show() {\n    noStroke();\n    fill(175);\n    rect(this.x, this.y, this.w, this.h);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-33",
      "language": "javascript",
      "code": "let liquid;\n\nfunction setup() {\n  // Initialize a <code>Liquid</code> object.  I’m choosing a low coefficient (0.1) for a weaker effect. Try a stronger one!\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-34",
      "language": "javascript",
      "code": "// If the liquid contains the mover, apply the drag force.\nif (liquid.contains(mover)) {\n  let dragForce = liquid.calculateDrag(mover);\n  mover.applyForce(dragForce);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-35",
      "language": "javascript",
      "code": "contains(mover) {\n  // Store <code>position</code> in a separate variable to make the code more readable.\n  let pos = mover.position;\n  // This Boolean expression determines whether the position vector is contained within the rectangle defined by the <code>Liquid</code> class.\n  return (pos.x > this.x && pos.x < this.x + this.w && \n          pos.y > this.y && pos.y < this.y + this.h);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-36",
      "language": "javascript",
      "code": "calculateDrag(mover) {\n  let speed = mover.velocity.mag();\n  // Calculate the force’s magnitude.\n  let dragMagnitude = this.c * speed * speed;\n  // Calculate the force’s direction.\n  let dragForce = mover.velocity.copy();\n  dragForce.mult(-1);\n  // Finalize the force: set the magnitude and direction together.\n  dragForce.setMag(dragMagnitude);\n  // Return the force.\n  return dragForce;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-37",
      "language": "javascript",
      "code": "let movers = [];\nlet liquid;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Initialize an array of <code>Mover</code> objects.\n  for (let i = 0; i < 9; i++) {\n    // Use a random mass for each one.\n    let mass = random(0.1, 5);\n    // The x-values are spaced out evenly according to <code>i</code>.\n    movers[i] = new Mover(40 + i * 70, 0, mass);\n  }\n  liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n}\n\nfunction draw() {\n  background(255);\n\n  // Draw the liquid.\n  liquid.show();\n\n  for (let i = 0; i < movers.length; i++) {\n    // Is the mover in the liquid?\n    if (liquid.contains(movers[i])) {\n      // Calculate the drag force.\n      let dragForce = liquid.drag(movers[i]);\n      // Apply the drag force to the mover.\n      movers[i].applyForce(dragForce);\n    }\n\n    // Gravity is scaled by mass here!\n    let gravity = createVector(0, 0.1 * movers[i].mass);\n    // Apply gravity.\n    movers[i].applyForce(gravity);\n    // Update and display the mover.\n    movers[i].update();\n    movers[i].show();\n    movers[i].checkEdges();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-38",
      "language": "javascript",
      "code": "let direction = p5.Vector.sub(mouse, position);",
      "lineNumbers": false
    },
    {
      "id": "code-39",
      "language": "javascript",
      "code": "let direction = p5.Vector.sub(position1, position2);\ndirection.normalize();",
      "lineNumbers": false
    },
    {
      "id": "code-40",
      "language": "javascript",
      "code": "let magnitude = (G * mass1 * mass2) / (distance * distance);\ndir.mult(magnitude);",
      "lineNumbers": false
    },
    {
      "id": "code-41",
      "language": "javascript",
      "code": "// The vector that points from one object to another\nlet force = p5.Vector.sub(position2, position1);\n// The length (magnitude) of that vector is the distance between the two objects.\nlet distance = force.mag();\n// Use the formula for gravity to compute the strength of the force.\nlet magnitude = (G * mass1 * mass2) / (distance * distance);\n// Normalize and scale the force vector to the appropriate magnitude.\nforce.setMag(magnitude);",
      "lineNumbers": true
    },
    {
      "id": "code-42",
      "language": "javascript",
      "code": "class Attractor {\n  constructor() {\n    // The attractor is an object that doesn’t move. It needs just a mass and a position.\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-43",
      "language": "javascript",
      "code": "let mover;\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  mover = new Mover(300, 100, 5);\n  // Initialize the <code>Attractor</code> object.\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!1} Draw the <code>Attractor</code> object.\n  attractor.show();\n  mover.update();\n  mover.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-44",
      "language": "javascript",
      "code": "// Made-up force\nlet force = createVector(0, 0.1);\nmover.applyForce(force);",
      "lineNumbers": false
    },
    {
      "id": "code-45",
      "language": "javascript",
      "code": "//{!1} Attraction force between two objects\n<strong>let force = attractor.attract(mover);</strong>\nmover.applyForce(force);",
      "lineNumbers": false
    },
    {
      "id": "code-46",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n\n  //{!2} Calculate the attraction force and apply it.\n  <strong>let force = attractor.attract(mover);\n  mover.applyForce(force);</strong>\n  mover.update();\n\n  attractor.show();\n  mover.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-47",
      "language": "javascript",
      "code": "attract(m) {\n    // All the math\n    return ______________;\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-48",
      "language": "javascript",
      "code": "attract(mover) {\n    //{!1} What’s the force’s direction?\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    // Calculate the strength of the attraction force.\n    let strength = (this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n\n    // Return the force so it can be applied!\n    return force;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-49",
      "language": "javascript",
      "code": "// Here the <code>constrain()</code> function limits the value of distance between a minimum (5) and maximum (25).\n  distance = constrain(distance, 5, 25);",
      "lineNumbers": false
    },
    {
      "id": "code-50",
      "language": "javascript",
      "code": "// A mover and an attractor\nlet mover;\nlet attractor;\n// A gravitational constant (for global scaling)\nlet G = 1.0;\n\nfunction setup() {\n  createCanvas(640, 240);\n  mover = new Mover(300, 50, 2);\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  //{!2} Apply the attraction force from the attractor on the mover.\n  let force = attractor.attract(mover);\n  mover.applyForce(force);\n  mover.update();\n  attractor.show();\n  mover.show();\n}\n\nclass Attractor {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.mass = 20;\n  }\n\n  attract(mover) {\n    let force = p5.Vector.sub(this.position, mover.position);\n    let distance = force.mag();\n    //{!1} Remember, you need to constrain the distance so your circle doesn’t spin out of control.\n    distance = constrain(distance, 5, 25);\n    let strength = (G * this.mass * mover.mass) / (distance * distance);\n    force.setMag(strength);\n    return force;\n  }\n\n  show() {\n    stroke(0);\n    fill(175, 200);\n    circle(this.position.x, this.position.y, this.mass * 2);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-51",
      "language": "javascript",
      "code": "circle(this.position.x, this.position.y, <span class=\"blank\">sqrt</span>(this.mass) * 2);",
      "lineNumbers": false
    },
    {
      "id": "code-52",
      "language": "javascript",
      "code": "// Now you have 10 movers!\nlet movers = [];\nlet attractor;\n\nfunction setup() {\n  createCanvas(640, 360);\n  for (let i = 0; i < 10; i++) {\n    // Each mover is initialized randomly.\n    movers[i] = new Mover(random(width), random(height), random(0.5, 3));\n  }\n  attractor = new Attractor();\n}\n\nfunction draw() {\n  background(255);\n  attractor.show();\n  for (let i = 0; i < movers.length; i++) {\n    //{!1} Calculate an attraction force for each <code>Mover</code> object.\n    let force = attractor.attract(movers[i]);\n    movers[i].applyForce(force);\n    movers[i].update();\n    movers[i].show();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-53",
      "language": "javascript",
      "code": "// The mover is now called a body.\nclass Body {\n\n  /* All the other stuff from before */\n\n  // The <code>attract()</code> method is now part of the Body class.\n  attract(body) {\n    let force = p5.Vector.sub(this.position, body.position);\n    let d = constrain(force.mag(), 5, 25);\n    let strength = (G * (this.mass * body.mass)) / (d * d);\n    force.setMag(strength);\n    body.applyForce(force);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-54",
      "language": "javascript",
      "code": "let bodyA;\nlet bodyB;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create two <code>Body</code> objects, <code>A</code> and <code>B</code>.\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n}\n\nfunction draw() {\n  background(255);\n  //{!2} <code>A</code> attracts <code>B</code>, and <code>B</code> attracts <code>A</code>.\n  bodyA.attract(bodyB);\n  bodyB.attract(bodyA);\n  bodyA.update();\n  bodyA.show();\n  bodyB.update();\n  bodyB.show();\n}",
      "lineNumbers": true
    },
    {
      "id": "code-55",
      "language": "javascript",
      "code": "function setup() {\n  createCanvas(640, 240);\n  bodyA = new Body(320, 40);\n  bodyB = new Body(320, 200);\n  // Assign horizontal velocities (in opposite directions) to each body.\n  bodyA.velocity = createVector(1, 0);\n  bodyB.velocity = createVector(-1, 0);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-56",
      "language": "javascript",
      "code": "// Start with an empty array.\nlet bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Fill the array with <code>Body</code> objects.\n  for (let i = 0; i < 10; i++) {\n    bodies[i] = new Body(random(width), random(height));\n  }\n}\n\nfunction draw() {\n  background(255);\n  // Iterate over the array to update and show all bodies.\n  for (let i = 0; i < bodies.length; i++) {\n    bodies[i].update();\n    bodies[i].show();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-57",
      "language": "javascript",
      "code": "//{!2} For every body, check every body!\n  for (let i = 0; i < bodies.length; i++) {\n    for (let j = 0; j < bodies.length; j++) {\n      let force = bodies[j].attract(bodies[i]);\n      movers[i].applyForce(force);\n    }\n    movers[i].update();\n    movers[i].show();\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-58",
      "language": "javascript",
      "code": "let bodies = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i < 10; i++) {\n    bodies[i] = new Body(random(width), random(height), random(0.1, 2));\n  }\n}\n\nfunction draw() {\n  background(255);\n\n  for (let i = 0; i < bodies.length; i++) {\n    for (let j = 0; j < bodies.length; j++) {\n      //{!1} Do not attract yourself!\n      if (i !== j) {\n        let force = bodies[j].attract(bodies[i]);\n        bodies[i].applyForce(force);\n      }\n    }\n    bodies[i].update();\n    bodies[i].show();\n  }\n}",
      "lineNumbers": true
    }
  ],
  "images": [
    "images/02_forces/02_forces_1.png",
    "images/02_forces/02_forces_2.png",
    "images/02_forces/02_forces_3.png",
    "examples/02_forces/nature_of_code_exercise_2_1_solution/screenshot.png",
    "examples/02_forces/example_2_1_forces/screenshot.png",
    "examples/02_forces/example_2_2_forces_acting_on_two_objects/screenshot.png",
    "examples/02_forces/example_2_3_gravity_scaled_by_mass/screenshot.png",
    "images/02_forces/02_forces_4.png",
    "examples/02_forces/example_2_4_including_friction/screenshot.png",
    "images/02_forces/02_forces_5.png",
    "images/02_forces/02_forces_6.png",
    "examples/02_forces/example_2_5_fluid_resistance/screenshot.png",
    "images/02_forces/02_forces_7.png",
    "images/02_forces/02_forces_8.png",
    "images/02_forces/02_forces_9.png",
    "images/02_forces/02_forces_10.png",
    "examples/02_forces/example_2_6_attraction/screenshot.png",
    "examples/02_forces/example_2_7_attraction_with_many_movers/screenshot.png",
    "images/02_forces/02_forces_11.png",
    "examples/02_forces/example_2_8_two_body_attraction/screenshot.png",
    "examples/02_forces/example_2_9_n_bodies/screenshot.png",
    "examples/02_forces/exercise_2_16/screenshot.png",
    "images/02_forces/02_forces_12.png"
  ]
}