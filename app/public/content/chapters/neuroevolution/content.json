{
  "id": "neuroevolution",
  "slug": "neuroevolution",
  "title": "11. Neuroevolution",
  "type": "chapter",
  "content": "\nChapter 11. Neuroevolution\n\n  \n    Reading about nature is fine, but if\n    a person walks in the woods and listens\n    carefully, they can learn more than\n    what is in books.\n    \n      —George Washington Carver\n    \n  \n\n\n  \n    \n    \n  \n  Star-nosed moles (courtesy of New York Public Library, c. 1826–1828)\n  The star-nosed mole (Condylura cristata), found mainly in the northeastern United States and eastern Canada, has a unique and highly specialized nasal organ. Evolved over numerous generations, its nose consists of 22 tentacles with over 25,000 minute sensory receptors. Despite the moles being functionally blind, these tentacles allow them to create a detailed spatial map of their surroundings. They can navigate their dark underground habitat with astonishing precision and speed, quickly identifying and consuming edible items in a matter of milliseconds.\n\nCongratulations! You’ve made it to the final act of this book. Take a moment to celebrate all that you’ve learned.\n\n  \n  \n\nThroughout this book, you’ve explored the fundamental principles of interactive physics simulations with p5.js, dived into the complexities of agent and other rule-based behaviors, and dipped your toe into the exciting realm of machine learning. You’ve become a natural!\nHowever, Chapter 10 merely scratched the surface of working with data and neural network–based machine learning—a vast landscape that would require countless sequels to this book to cover comprehensively. My goal was never to go deep into neural networks, but simply to establish the core concepts in preparation for a grand finale, where I find a way to integrate machine learning into the world of animated, interactive p5.js sketches and bring together as many of our new Nature of Code friends as possible for one last hurrah.\nThe path forward passes through the field of neuroevolution, a style of machine learning that combines the GAs from Chapter 9 with the neural networks from Chapter 10. A neuroevolutionary system uses Darwinian principles to evolve the weights (and in some cases, the structure itself) of a neural network over generations of trial-and-error learning. In this chapter, I’ll demonstrate how to use neuroevolution with a familiar example from the world of gaming. I’ll then finish off by varying Craig Reynolds’s steering behaviors from Chapter 5 so that they are learned through neuroevolution.\nReinforcement Learning\nNeuroevolution shares many similarities with another machine learning methodology that I briefly referenced in Chapter 10, reinforcement learning, which incorporates machine learning into a simulated environment. A neural network–backed agent learns by interacting with the environment and receiving feedback about its decisions in the form of rewards or penalties. It’s a strategy built around observation.\nThink of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.) Presumably, the mouse will learn over time to turn left. Its biological neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch). If the observation is negative, the network can adjust its weights in order to make a different decision the next time.\nIn the real world, reinforcement learning is commonly used not for tormenting rodents but rather for developing robots. At time t, the robot performs a task and observes the results. Did it crash into a wall or fall off a table, or is it unharmed? As time goes on, the robot learns to interpret the signals from its environment in the optimal way to accomplish its tasks and avoid harm.\nInstead of a mouse or a robot, now think about any of the example objects from earlier in this book (walker, mover, particle, vehicle). Imagine embedding a neural network into one of these objects and using it to calculate a force or another action. The neural network could receive its inputs from the environment (such as distance to an obstacle) and output some kind of decision. Perhaps the network chooses from a set of discrete options (move left or right) or picks a set of continuous values (the magnitude and direction of a steering force).\nIs this starting to sound familiar? It’s no different from the way a neural network performed after training in the Chapter 10 examples, receiving inputs and predicting a classification or regression! Actually training one of these objects to make a good decision is where the reinforcement learning process diverges from the supervised learning approach. To better illustrate, let’s start with a hopefully easy-to-understand and possibly familiar scenario, the game Flappy Bird (see Figure 11.1).\nThe game is deceptively simple. You control a small bird that continually moves horizontally across the screen. With each tap or click, the bird flaps its wings and rises upward. The challenge? A series of vertical pipes spaced apart at irregular intervals emerge from the right. The pipes have gaps, and your primary objective is to navigate the bird safely through these gaps. If you hit a pipe, it’s game over. As you progress, the game’s speed increases, and the more pipes you navigate, the higher your score.\n\n  \n  Figure 11.1: The Flappy Bird game\n\nSuppose you want to automate the gameplay, and instead of a human tapping, a neural network will make the decision of whether to flap. Could machine learning work here? Skipping over the initial data steps in the machine learning life cycle for a moment, let’s think about how to choose a model. What are the inputs and outputs of the neural network?\nThis is quite the intriguing question because, at least in the case of the inputs, there isn’t a definitive answer. If you don’t know much about the game or don’t want to put your thumb on the scale in terms of identifying which aspects of the game are important, it might make the most sense to have the inputs be all the pixels of the game screen. This approach attempts to feed everything about the game into the model and let the model figure out for itself what matters.\nI’ve played Flappy Bird enough that I feel I understand it quite well, however. I can therefore bypass feeding all the pixels to the model and boil down the essence of the game to just a few input data points necessary for making predictions. These data points, often referred to as features in machine learning, represent the distinctive characteristics of the data that are most salient for the prediction. Imagine biting into a mysteriously juicy fruit—features like its taste (sweet!), texture (crisp!), and color (a vibrant red!) help you identify it as an apple. In the case of Flappy Bird, the most crucial features are listed here:\n\n  The y-position of the bird\n  The y-velocity of the bird\n  The y-position of the next top pipe’s opening\n\n\n  \n    The y-position of the next bottom pipe’s opening\n    The x-distance to the next pipe\n  \n\nThese features are illustrated in Figure 11.2.\n\n  \n  Figure 11.2: The Flappy Bird input features for a neural network\n\nThe neural network will have five inputs, one for each feature, but what about the outputs? Is this a classification problem or a regression problem? This may seem like an odd question to ask in the context of a game like Flappy Bird, but it’s actually quite important and relates to the way the game is controlled. Tapping the screen, pressing a button, or using keyboard controls are all examples of classification. After all, the player has only a discrete set of choices: tap or not; press W, A, S, or D on the keyboard. On the other hand, using an analog controller like a joystick leans toward regression. A joystick can be tilted in varying degrees in any direction, translating to continuous output values for both its horizontal and vertical axes.\nFor Flappy Bird, the outputs represent a classification decision with only two choices:\n\n  Flap.\n  Don’t flap.\n\nThis means the network should have two outputs, suggesting an overall network architecture like the one in Figure 11.3.\n\n  \n  Figure 11.3: The neural network for Flappy Bird as ml5.js might design it\n\nI now have all the information necessary to configure a model and let ml5.js build it:\nlet options = {\n  inputs: 5,\n  outputs: [\"flap\", \"no flap\"],\n  task: \"classification\"\n};\nlet birdBrain = ml5.neuralNetwork(options);\nWhat next? If I were following the steps I laid out in Chapter 10, I’d have to go back to steps 1 and 2 of the machine learning process: data collection and preparation. How exactly would that work here? One idea could be to scour the earth for the greatest Flappy Bird player of all time and record them playing for hours. I could log the input features for every moment of gameplay along with whether the player flapped or not. Feed all that data into the model, train it, and I can see the headlines already: “Artificial Intelligence Bot Defeats Flappy Bird.”\nBut wait a second; has a computerized agent really learned to play Flappy Bird on its own, or has it simply learned to mirror the gameplay of a human? What if that human missed a key aspect of Flappy Bird strategy? The automated player would never discover it. Not to mention that collecting all that data would be incredibly tedious.\nThe problem here is that I’ve reverted to a supervised learning scenario like the ones from Chapter 10, but this is supposed to be a section about reinforcement learning. Unlike supervised learning, in which the correct answers are provided by a training dataset, the agent in reinforcement learning learns the answers—the optimal decisions—through trial and error by interacting with the environment and receiving feedback. In the case of Flappy Bird, the agent could receive a positive reward every time it successfully navigates a pipe, but a negative reward if it hits a pipe or the ground. The agent’s goal is to figure out which actions lead to the most cumulative rewards over time.\nAt the start, the Flappy Bird agent won’t know the best time to flap its wings, leading to many crashes. As it accrues more and more feedback from countless play-throughs, however, it will begin to refine its actions and develop the optimal strategy to navigate the pipes without crashing, maximizing its total reward. This process of learning by doing and optimizing based on feedback is the essence of reinforcement learning.\nAs the chapter goes on, I’ll explore the principles I’m outlining here, but with a twist. Traditional techniques in reinforcement learning involve defining a strategy (called a policy) and a corresponding reward function to provide feedback for adjusting the policy. Instead of going down this road, however, I’m going to turn toward the star of this chapter, neuroevolution.\nEvolving Neural Networks Is NEAT!\nInstead of using traditional backpropagation, a policy, and a reward function, neuroevolution applies principles of GAs and natural selection to train the weights in a neural network. This technique unleashes many neural networks on a problem at once. Periodically, the best-performing neural networks are “selected,” and their “genes” (the network connection weights) are combined and mutated to create the next generation of networks. Neuroevolution is especially effective in environments where the learning rules aren’t precisely defined or the task is complex, with numerous potential solutions.\nOne of the first examples of neuroevolution can be found in the 1994 paper “Genetic Lander: An Experiment in Accurate Neuro-genetic Control” by Edmund Ronald and Marc Schoenauer. In the 1990s, traditional neural network training methods were still nascent, and this work explored an alternative approach. The paper describes how a simulated spacecraft—in a game aptly named Lunar Lander—can learn how to safely descend and land on a surface. Rather than use handcrafted rules or labeled datasets, the researchers opted to use GAs to evolve and train neural networks over multiple generations. And it worked!\nIn 2002, Kenneth O. Stanley and Risto Miikkulainen expanded on earlier neuroevolutionary approaches with their paper “Evolving Neural Networks Through Augmenting Topologies”. Unlike the lunar lander method that focused on evolving the weights of a neural network, Stanley and Miikkulainen introduced a method that also evolved the network’s structure itself! Their NEAT algorithm—NeuroEvolution of Augmenting Topologies—starts with simple networks and progressively refines their topology through evolution. As a result, NEAT can discover network architectures tailored to specific tasks, often yielding more optimized and effective solutions.\nA comprehensive NEAT implementation would require going deeper into neural network architectures and working directly with TensorFlow.js. My goal instead is to emulate Ronald and Schoenauer’s original research in the modern context of the web browser with ml5.js. Rather than use the Lunar Lander game, I’ll give this a try with Flappy Bird. And for that, I first need to code a version of Flappy Bird where my neuroevolutionary network can operate.\nCoding Flappy Bird\nFlappy Bird was created by Vietnamese game developer Dong Nguyen in 2013. In January 2014, it became the most downloaded app on the Apple App Store. However, on February 8 of that year, Nguyen announced that he was removing the game because of its addictive nature. Since then, it has become one of the most cloned games in history.\nFlappy Bird is a perfect example of Nolan’s law, an aphorism attributed to the founder of Atari and creator of Pong, Nolan Bushnell: “All the best games are easy to learn and difficult to master.” It’s also a terrific game for beginner coders to re-create as a learning exercise, and it fits perfectly with the concepts in this book.\nTo program the game with p5.js, I’ll start by defining a Bird class. This may shock you, but I’m going to skip using p5.Vector for this demonstration and instead use separate x and y properties for the bird’s position. Since the bird moves only along the vertical axis in the game, x remains constant! Therefore, the velocity (and all the relevant forces) can be a single scalar value for just the y-axis.\nTo simplify the code even further, I’ll add the forces directly to the bird’s velocity instead of accumulating them into an acceleration variable. In addition to the usual update(), I’ll include a flap() method for the bird to fly upward. The show() method isn’t included here as it only draws a circle. Here’s the code:\nclass Bird {\n  constructor() {\n    // The bird’s position (<code>x</code> will be constant)\n    this.x = 50\n    this.y = 120;\n    // Velocity and forces are scalar since the bird moves only along the y-axis.\n    this.velocity = 0;\n    this.gravity = 0.5;\n    this.flapForce = -10;\n  }\n\n  // The bird flaps its wings.\n  flap() {\n    this.velocity += this.flapForce;\n  }\n\n  update() {\n    // Add gravity.\n    this.velocity += this.gravity;\n    this.y += this.velocity;\n    // Dampen velocity.\n    this.velocity *= 0.95;\n    // Handle the floor.\n    if (this.y > height) {\n      this.y = height;\n      this.velocity = 0;\n    }\n  }\n}\nThe other primary elements of the game are the pipes that the bird must navigate through. I’ll create a Pipe class to describe a pair of rectangles, one that emanates from the top of the canvas and one from the bottom. Just as the bird moves only vertically, the pipes slide along only the horizontal axis, so the properties can also be scalar values rather than vectors. The pipes move at a constant speed and don’t experience any other forces.\nclass Pipe {\n  constructor() {\n    // The size of the opening between the two parts of the pipe\n    this.spacing = 100;\n    // A random height for the top of the pipe\n    this.top = random(height - this.spacing);\n    // The starting position of the bottom pipe (based on the top)\n    this.bottom = this.top + this.spacing;\n    // The pipe starts at the edge of the canvas.\n    this.x = width;\n    // The width of the pipe\n    this.w = 20;\n    // The horizontal speed of the pipe\n    this.velocity = 2;\n  }\n\n  // Draw the two pipes.\n  show() {\n    fill(0);\n    noStroke();\n    rect(this.x, 0, this.w, this.top);\n    rect(this.x, this.bottom, this.w, height - this.bottom);\n  }\n\n  // Update the horizontal position.\n  update() {\n    this.x -= this.velocity;\n  }\n}\nTo be clear, the game depicts a bird flying through pipes—the bird is moving along two dimensions while the pipes remain stationary. However, it’s simpler to code the game as if the bird is stationary in its horizontal position and the pipes are moving.\nWith a Bird and Pipe class written, I’m almost set to run the game. However, a key piece is missing: collisions. The whole game rides on the bird attempting to avoid the pipes! Fortunately, this is nothing new. You’ve seen many examples of objects checking their positions against others throughout this book. I have a design choice to make, though. A method to check collisions could logically be placed in either the Bird class (to check whether the bird hits a pipe) or the Pipe class (to check whether a pipe hits the bird). Either can be justified, depending on your point of view.\nI’ll place the method in the Pipe class and call it collides(). The code itself is a little trickier than you might think at first glance, as the method needs to check both the top and bottom rectangles of a pipe against the position of the bird. I could approach this in a variety of ways. One way is to first check whether the bird is vertically within the bounds of either rectangle (either above the bottom of the top pipe or below the top of the bottom one). But the bird is colliding with the pipe only if the bird is also horizontally within the boundaries of the pipe’s width. An elegant way to write this is to combine each of these checks with a logical and:\n  collides(bird) {\n    // Is the bird within the vertical range of the top or bottom pipe?\n    let verticalCollision = bird.y < this.top || bird.y > this.bottom;\n    // Is the bird within the horizontal range of the pipes?\n    let horizontalCollision = bird.x > this.x && bird.x < this.x + this.w;\n    //{!1} If it’s both a vertical and horizontal hit, it’s a hit!\n    return verticalCollision && horizontalCollision;\n  }\nThe algorithm currently treats the bird as a single point and doesn’t take into account its size. This detail should be improved for a more realistic version of the game.\nAll that’s left is to write setup() and draw(). I need a single variable for the bird and an array for a list of pipes. The interaction is just a single click of the mouse, which triggers the bird’s flap() method. Rather than build a fully functional game with a score, end screen, and other usual elements, I’ll just make sure that the game mechanics are working by drawing the text OOPS! near any pipe when a collision occurs. The code also assumes an additional offscreen() method on the Pipe class for when a pipe has moved beyond the left edge of the canvas.\n\n  Example 11.1: Flappy Bird Clone\n  \n    \n    \n  \n\nlet bird;\nlet pipes = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} Create a bird and start with one pipe.\n  bird = new Bird();\n  pipes.push(new Pipe());\n}\n\n//{!3} The bird flaps its wings when the mouse is clicked.\nfunction mousePressed() {\n  bird.flap();\n}\n\nfunction draw() {\n  background(255);\n  // Handle all the pipes.\n  for (let i = pipes.length - 1; i >= 0; i--) {\n    pipes[i].show();\n    pipes[i].update();\n    if (pipes[i].collides(bird)) {\n      text(\"OOPS!\", pipes[i].x, pipes[i].top + 20);\n    }\n    if (pipes[i].offscreen()) {\n      pipes.splice(i, 1);\n    }\n  }\n  // Update and show the bird.\n  bird.update();\n  bird.show();\n  //{!3} Add a new pipe every 100 frames.\n  if (frameCount % 100 === 0) {\n    pipes.push(new Pipe());\n  }\n}\nThe trickiest aspect of this code lies in spawning the pipes at regular intervals with the frameCount variable and modulo operator. In p5.js, frameCount is a system variable that tracks the number of frames rendered since the sketch began, incrementing with each cycle of the draw() loop. The modulo operator, denoted by %, returns the remainder of a division operation. For example, 7 % 3 yields 1 because when dividing 7 by 3, the result is 2 with a remainder of 1. The Boolean expression frameCount % 100 === 0 therefore checks whether the current frameCount value, when divided by 100, has a remainder of 0. This condition is true every 100 frames, and at those frames, a new pipe is spawned and added to the pipes array.\n\n  Exercise 11.1\n  Implement a scoring system that awards points for successfully navigating through each set of pipes. Feel free to also add your own visual design elements for the bird, pipes, and environment!\n\nNeuroevolutionary Flappy Bird\nMy Flappy Bird clone, as it currently stands, is controlled by mouse clicks. Now I want to cede control of the game to the computer and use neuroevolution to teach it how to play. Luckily, the process of neuroevolution is already baked into ml5.js, so making this switch will be relatively straightforward. The first step is to give the bird a brain so it can decide on its own whether to flap its wings.\nThe Bird Brain\nWhen I introduced reinforcement learning, I established a list of input features that should make up the bird’s decision-making process. I’m going to use that same list but with one simplification. Since the size of the opening between the pipes is constant, there’s no need to include the y-positions of both the top and bottom; one or the other will suffice. The input features are therefore as follows:\n\n  The y-position of the bird\n  The y-velocity of the bird\n  The y-position of the next pipe’s top (or bottom!) opening\n  The x-distance to the next pipe\n\nThe two outputs represent the bird’s two options: to flap or not to flap. With the inputs and outputs set, I can add a brain property to the bird’s constructor to hold an ml5.js neural network with the appropriate configuration. Just to demonstrate a different coding style here, I’ll skip including a separate options variable and pass the properties as an object literal directly into the ml5.neuralNetwork() function. Note the addition of a neuroEvolution property set to true. This is necessary to enable some of the features I’ll be using later in the code.\n  constructor() {\n    this.brain = ml5.neuralNetwork({\n      // A bird’s brain receives four inputs and classifies them into one of two labels.\n      inputs: 4,\n      outputs: [\"flap\", \"no flap\"],\n      task: \"classification\",\n      //{!1} A new property necessary to enable neuroevolution functionality\n      neuroEvolution: true\n    });\n  }\nNext, I’ll add a new method called think() to the Bird class to calculate all the necessary inputs for the bird at each moment in time. The first two inputs are easy—they’re simply the y and velocity properties of the bird. However, for inputs 3 and 4, I need to determine which pipe is the next pipe.\nAt first glance, it might seem that the next pipe is always the first one in the array, since the pipes are added one at a time to the end of the array. However, after a pipe passes the bird, it’s no longer relevant, and there’s still some time between when this happens and when that pipe exits the canvas and is removed from the beginning of the array. I therefore need to find the first pipe in the array whose right edge (x-position plus width) is greater than the bird’s x-position:\n\n    think(pipes) {\n    let nextPipe = null;\n    for (let pipe of pipes) {\n      //{!4} The next pipe is the one that hasn’t passed the bird yet.\n      if (pipe.x + pipe.w > this.x) {\n        nextPipe = pipe;\n        break;\n      }\n    }\n\nOnce I have the next pipe, I can create the four inputs:\n\n      let inputs = [\n      // y-position of the bird\n      this.y,\n      // y-velocity of the bird\n      this.velocity,\n      // Top opening of the next pipe\n      nextPipe.top,\n      //{!1} Distance to the next pipe\n      nextPipe.x - this.x,\n    ];\n\nThis is close, but I’ve forgotten a critical step. The range of all input values is determined by the dimensions of the canvas, but a neural network expects values in a standardized range, such as 0 to 1. One method to normalize these values is to divide the inputs related to vertical properties by height, and those related to horizontal ones by width:\n\n      let inputs = [\n      //{!4} All the inputs are now normalized by width and height.\n      this.y / height,\n      this.velocity / height,\n      nextPipe.top / height,\n      (nextPipe.x - this.x) / width,\n    ];\n\nWith the inputs in hand, I’m ready to pass them to the neural network’s classify() method. I have another small problem, however: classify() is asynchronous, meaning I’d have to implement a callback inside the Bird class to process the model’s decision. This would add a significant level of complexity to the code, but luckily, it’s entirely unnecessary in this case. Asynchronous callbacks with ml5.js’s machine learning functions are typically needed because of the time required to process the large amount of data in the model. Without a callback, the code might have to wait a long time to get a result, and if the model is running as part of a p5.js sketch, that delay could severely impact the smoothness of the animation. The neural network here, however, has only four floating-point\ninputs and two output labels! It’s tiny and can run fast enough that there’s no reason to use asynchronous code.\n\n  For completeness, I include a version of the example on the book’s website that implements neuroevolution with asynchronous callbacks. For this discussion, however, I’m going to use a feature of ml5.js that allows me to take a shortcut. The method classifySync() is identical to classify(), but it runs synchronously, meaning the code stops and waits for the results before moving on. You should be very careful when using this version of the method as it can cause problems in other contexts, but it will work well for this simple scenario. Here’s the end of the think() method with classifySync():\n\n\n      let results = this.brain.classifySync(inputs);\n    if (results[0].label === \"flap\") {\n      this.flap();\n    }\n  }\n\nThe neural network’s prediction is in the same format as the gesture classifier from Chapter 10, and the decision can be made by checking the first element of the results array. If the output label is \"flap\", then call flap().\nNow that I’ve finished the think() method, the real challenge can begin: teaching the bird to win the game by consistently flapping its wings at the right moment. This is where the GA comes back into the picture. Recalling the discussion from Chapter 9, three key principles underpin Darwinian evolution: variation, selection, and heredity. I’ll revisit each of these principles in turn as I implement the steps of the GA in this new context of neural networks.\nVariation: A Flock of Flappy Birds\nA single bird with a randomly initialized neural network isn’t likely to have any success at all. That lone bird will most likely jump incessantly and fly way off-screen, or sit perched at the bottom of the canvas awaiting collision after collision with the pipes. This erratic and nonsensical behavior is a reminder: a randomly initialized neural network lacks any knowledge or experience. The bird is essentially making wild guesses for its actions, so success is going to be rare.\nThis is where the first key principle of GAs comes in: variation. The hope is that by introducing as many different neural network configurations as possible, a few might perform slightly better than the rest. The first step toward variation is to add an array of many birds (Figure 11.4).\n\n  \n  Figure 11.4: A population of birds, each with unique neural networks, navigating through the pipes in the neuroevolution process\n\n// Population size\nlet populationSize = 200;\n// Array of birds\nlet birds = [];\n\nfunction setup() {\n  //{!3} Create the bird population.\n  for (let i = 0; i < populationSize; i++) {\n    birds[i] = new Bird();\n  }\n  //{!1} Run the computations on the CPU for better performance.\n  ml5.setBackend(\"cpu\");\n}\n\nfunction draw() {\n  for (let bird of birds) {\n    //{!1} This is the new method for the bird to make a decision to flap or not.\n    bird.think(pipes);\n    bird.update();\n    bird.show();\n  }\n}\nYou might notice a peculiar line of code that’s crept into the setup() function: ml5.setBackend(\"cpu\"). When running neural networks, a lot of the heavy computational lifting is often offloaded to the GPU. This is the default behavior, and it’s especially critical for the larger pretrained models included with ml5.js.\n\n  GPU vs. CPU\n  \n    Graphics processing unit (GPU): Originally designed for rendering graphics, GPUs are adept at handling a massive number of operations in parallel. This makes them excellent for the kinds of math operations and computations that machine learning models frequently perform.\n    Central processing unit (CPU): Often considered the brain or general-purpose heart of a computer, a CPU handles a wider variety of tasks than the specialized GPU, but it isn’t built to do as many tasks simultaneously.\n  \n\nBut there’s a catch! Transferring data to and from the GPU introduces overhead. In most cases,\nthe gains from the GPU’s parallel processing more than offset this overhead, but for a tiny model\nlike the one here, copying data to the GPU and back actually slows the neural network. Calling ml5.setBackend(\"cpu\") tells ml5.js to run the neural network computations on the CPU instead. At least in this simple case of tiny bird brains, this is the more efficient choice.\nSelection: Flappy Bird Fitness\nOnce I have a diverse population of birds, each with its own neural network, the next step in the GA is selection. Which birds should pass on their genes (in this case, neural network weights) to the next generation? In the world of Flappy Bird, the measure of success is the ability to stay alive the longest by avoiding the pipes. This is the bird’s fitness. A bird that dodges many pipes is considered more fit than one that crashes into the first pipe it encounters.\nTo track each bird’s fitness, I’ll add two properties to the Bird class, fitness and alive:\n  constructor() {\n    // The bird’s fitness\n    this.fitness = 0;\n    //{!1} Is the bird alive or not?\n    this.alive = true;\n  }\nI’ll assign the fitness a numeric value that increases by one every cycle through draw(), as long as the bird remains alive. The birds that survive longer should have a higher fitness value. This mechanism mirrors the reinforcement learning technique of rewarding good decisions. In reinforcement learning, however, an agent receives immediate feedback for every decision it makes, allowing it to adjust its policy accordingly. Here, the bird’s fitness is a cumulative measure of its overall success and will be applied only during the selection step of the GA.\n  update() {\n    //{!1} Increment the fitness each time through <code>update()</code>.\n    this.fitness++;\n  }\nThe alive property is a Boolean flag that’s initially set to true. When a bird collides with a pipe, this property is set to false. Only birds that are still alive are updated and drawn to the canvas.\nfunction draw() {\n  // There’s now an array of birds!\n  for (let bird of birds) {\n    //{!1} Operate only on the birds that are still alive.\n    if (bird.alive) {\n      // Make a decision based on the pipes.\n      bird.think(pipes);\n      // Update and show the bird.\n      bird.update();\n      bird.show();\n      //{!4} Has the bird hit a pipe? If so, it’s no longer alive.\n      for (let pipe of pipes) {  \n        if (pipe.collides(bird)) {\n          bird.alive = false;\n        }\n      }\n    }\n  }\n}\nIn Chapter 9, I demonstrated two techniques for running an evolutionary simulation. In the smart rockets example, the population lived for a fixed amount of time each generation. The same approach could likely work here as well, but I want to allow the birds to accumulate the highest fitness value possible and not arbitrarily stop them based on a time limit. The second technique, demonstrated with the bloops example, eliminated the fitness score entirely and set a random probability for cloning any living creature. For Flappy Bird, this approach could become messy and risks overpopulation or all the birds dying out completely.\nI propose combining elements of both approaches. I’ll allow a generation to continue as long as at least one bird is still alive. When all the birds have died, I’ll select parents for the reproduction step and start anew. I’ll begin by writing a function to check whether all the birds have died:\nfunction allBirdsDead() {\n  for (let bird of birds) {\n    //{!3} If a single bird is alive, they are not all dead!\n    if (bird.alive) {\n      return false;\n    }\n  }\n  //{!1} If the loop completes without finding a living bird, all the birds are dead.\n  return true;\n}\nWhen all the birds have died, it’s time for selection! In the previous GA examples, I demonstrated a relay-race technique for giving a fair shot to all members of a population, while still increasing the chances of selection for those with higher fitness scores. I’ll use that same weightedSelection() function here:\n//{!1} See Chapter 9 for a detailed explanation of this algorithm.\nfunction weightedSelection() {\n  let index = 0;\n  let start = random(1);\n  while (start > 0) {\n    start = start - birds[index].fitness;\n    index++;\n  }\n  index--;\n  //{!1} Instead of returning the entire <code>Bird</code> object, just the brain is returned.\n  return birds[index].brain;\n}\nFor this algorithm to function properly, I need to first normalize the fitness values of the birds so that they collectively add up to 1:\nfunction normalizeFitness() {\n  // Sum the total fitness of all birds.\n  let sum = 0;\n  for (let bird of birds) {\n    sum += bird.fitness;\n  }\n  //{!3} Divide each bird’s fitness by the sum.\n  for (let bird of birds) {\n    bird.fitness = bird.fitness / sum;\n  }\n}\nOnce normalized, each bird’s fitness is equal to its probability of being selected.\nHeredity: Baby Birds\nOnly one step is left in the GA—reproduction. In Chapter 9, I explored in great detail the two-step process for generating a child element: crossover and mutation. Crossover is where the third key principle of heredity arrives: the DNA from the two selected parents is combined to form the\nchild’s DNA.\nAt first glance, the idea of inventing a crossover algorithm for two neural networks might seem daunting, and yet it’s quite straightforward. Think of the individual “genes” of a bird’s brain as the weights within the neural network. Mixing two such brains boils down to creating a new neural network with each weight chosen by a virtual coin flip—the weight comes from either the first or the second parent:\n// Pick two parents and create a child with crossover.\nlet parentA = weightedSelection();\nlet parentB = weightedSelection();\nlet child = parentA.crossover(parentB);\nWow, today’s my lucky day! It turns out ml5.js includes a crossover() method that manages the algorithm for mixing the two neural networks. I can happily move on to the mutation step:\n// Mutate the child.\nchild.mutate(0.01);\nMy luck continues! The ml5.js library also provides a mutate() method that accepts a mutation rate as its primary argument. The rate determines how often a weight will be altered. For example, a rate of 0.01 indicates a 1 percent chance that any given weight will mutate. During mutation, ml5.js adjusts the weight slightly by adding a small random number to it, rather than selecting a completely new random value. This behavior mimics real-world genetic mutations, which typically introduce minor changes rather than entirely new traits. Although this default approach works for many cases, ml5.js offers more control over the process by allowing the use of a custom mutation function as an optional second argument to mutate().\nThe crossover and mutation steps need to be repeated for the size of the population to create an entirely new generation of birds. This is accomplished by populating an empty local array nextBirds with the new birds. Once the population is full, the global birds array is then updated to this fresh generation:\nfunction reproduction() {\n  //{!1} Start with a new empty array.\n  let nextBirds = [];\n  for (let i = 0; i < populationSize; i++) {\n    // Pick two parents.\n    let parentA = weightedSelection();\n    let parentB = weightedSelection();\n    // Create a child with crossover.\n    let child = parentA.crossover(parentB);\n    // Apply mutation.\n    child.mutate(0.01);\n    //{!1} Create the new bird object.\n    nextBirds[i] = new Bird(child);\n  }\n  //{!1} The next generation is now the current one!\n  birds = nextBirds;\n}\nIf you look closely at the reproduction() function, you may notice that I’ve slipped in another new feature of the Bird class: an argument to the constructor. When I first introduced the idea of a bird brain, each new Bird object was created with a brand-new brain—a fresh neural network courtesy of ml5.js. However, I now want the new birds to inherit a child brain that was generated through the processes of crossover and mutation. To make this possible, I’ll subtly change the Bird constructor to look for an optional argument named, of course, brain:\n  constructor(brain) {\n    //{!1} Check whether a brain was passed in.\n    if (brain) {\n      this.brain = brain;\n    //{!1} If not, make a new one.\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 4,\n        outputs: [\"flap\", \"no flap\"],\n        task: \"classification\",\n        neuroEvolution: true,\n      });\n    }\n  }\nIf no brain is provided when a new bird is created, the brain argument remains undefined. In JavaScript, undefined is treated as false. The if (brain) test will therefore fail, so the code will move on to the else statement and call ml5.neuralNetwork(). On the other hand, if an existing neural network is passed in, brain evaluates to true and is assigned directly to this.brain. This elegant trick allows a single constructor to handle multiple scenarios.\nWith that, the example is complete. All that’s left to do is call normalizeFitness() and reproduction() in draw() at the end of each generation, when all the birds have died out.\n\n  Example 11.2: Flappy Bird with Neuroevolution\n  \n    \n    \n  \n\nfunction draw() {\n  /* All the rest of draw */\n\n  //{!4} Create the next generation when all the birds have died.\n  if (allBirdsDead()) {\n    normalizeFitness();\n    reproduction();\n    resetPipes();\n  }\n}\n\nfunction resetPipes() {\n  // Remove all the pipes but the very latest one.\n  pipes.splice(0, pipes.length - 1);\n}\nNote the addition of a new resetPipes() function. If I don’t remove the pipes before starting a new generation, the birds may immediately restart at a position colliding with a pipe, in which case even the best bird won’t have a chance to fly! The full online code for Example 11.2 also adjusts the behavior of the birds so that they die when they leave the canvas, either by crashing into the ground or soaring too high above the top.\n\n  Exercise 11.2\n  It takes a very long time for Example 11.2 to produce any results. Could you “speed up time” by skipping the drawing of every single frame of the game to reach an optimal bird faster? (A solution is presented in “Speeding Up Time”.) Additionally, could you add an overlay that displays information about the simulation’s status, such as the number of birds still in play, the current generation, and the life span of the best bird?\n\n\n  Exercise 11.3\n  To avoid starting the neuroevolution process from scratch every time, try using ml5.js’s neural network save() and load() methods. How might you add a feature that saves the best bird model as well as an option to load a previously saved model?\n\nSteering the Neuroevolutionary Way\nHaving explored neuroevolution with Flappy Bird, I’d like to shift the focus back to the realm of simulation, specifically the steering agents introduced in Chapter 5. What if, instead of me dictating the rules for an algorithm to calculate a steering force, a simulated creature could evolve its own strategy? Drawing inspiration from Reynolds’s aim of lifelike and improvisational behaviors, my goal isn’t to use neuroevolution to engineer the perfect creature that can flawlessly execute a task. Instead, I hope to create a captivating world of simulated life, where the quirks, nuances, and happy accidents of evolution unfold in the canvas.\nI’ll begin by adapting the smart rockets example from Chapter 9. In that example, the genes for each rocket were an array of vectors:\nthis.genes = [];\nfor (let i = 0; i < lifeSpan; i++) {\n  //{!2} Each gene is a vector with random direction and magnitude.\n  this.genes[i] = p5.Vector.random2D();\n  this.genes[i].mult(random(0, this.maxforce));\n}\nI propose adapting this code to instead use a neural network to predict the vector or steering force, transforming the genes into a brain. Vectors can have a continuous range of values, so this is a regression task:\nthis.brain = ml5.neuralNetwork({\n  inputs: 2,\n  outputs: 2,\n  task: \"regression\",\n  neuroEvolution: true,\n});\nIn the original example, the vectors from the genes array were applied sequentially, querying the array with a counter variable:\nthis.applyForce(this.genes[this.counter]);\nNow, instead of an array lookup, I want the neural network to return a new vector for each frame of the animation. For regression tasks with ml5.js, the output of the neural network is received from the predict() method rather than classify(). And here, I’ll use the predictSync() variant to keep the code simple and allow for synchronous output data from the model in the rocket’s run() method:\nrun() {\n  // Get the outputs from the neural network.\n  let outputs = this.brain.predictSync(inputs);\n  // Use one output for an angle.\n  let angle = outputs[0].value * TWO_PI;\n  // Use another output for the magnitude.\n  let magnitude = outputs[1].value * this.maxforce;\n  // Create and apply the force.\n  let force = p5.Vector.fromAngle(angle)\n  force.setMag(magnitude);\n  this.applyForce(force);\n}\nThe neural network brain outputs two values: one for the angle of the vector and one for the magnitude. You might think to instead use these outputs for the vector’s x- and y-components. The default output range for an ml5.js neural network is from 0 to 1, however, and I want the forces to be capable of pointing in both positive and negative directions. Mapping the first output to an angle by multiplying it by TWO_PI offers the full range.\nYou may have noticed that the code includes a variable called inputs that I have yet to declare or initialize. Defining the inputs to the neural network is where you, as the designer of the system, can be the most creative. You have to consider the nature of the environment and the simulated biology and capabilities of your creatures, and then decide which features are most important.\nAs a first try, I’ll assign something basic for the inputs and see if it works. Since the smart rockets’ environment is static, with fixed obstacles and targets, what if the brain could learn and estimate a flow field to navigate toward its goal? As I demonstrated in Chapter 5, a flow field receives a position and returns a vector, so the neural network can mirror this functionality and use the rocket’s current x- and y-position as input. I just have to normalize the values according to the canvas dimensions:\nlet inputs = [this.position.x / width, this.position.y / height];\nThat’s it! Virtually everything else from the original example can remain unchanged: the population, the fitness function, and the selection process.\n\n  Example 11.3: Smart Rockets with Neuroevolution\n  \n    \n    \n  \n\n  reproduction() {\n    let nextPopulation = [];\n    // Create the next population.\n    for (let i = 0; i < this.population.length; i++) {\n      // Spin the wheel of fortune to pick two parents.\n      let parentA = this.weightedSelection();\n      let parentB = this.weightedSelection();\n      let child = parentA.crossover(parentB);\n      //{!1} Apply mutation.\n      child.mutate(this.mutationRate);\n      nextPopulation[i] = new Rocket(320, 220, child);\n    }\n    //{!1} Replace the old population.\n    this.population = nextPopulation;\n    this.generations++;\n  }\nNow that I’m using ml5.js, notice that I no longer need a separate DNA class with implementations of crossover() and mutate(). Instead, those methods are built into ml5.neuralNetwork and can be called directly.\n\n  Exercise 11.4\n  A steering force, as defined by Reynolds, is the difference between an agent’s desired velocity and its current velocity. How might this evolutionary system mirror that methodology? Instead of using only the position as an input to the neural network, what if you feed in the rocket’s current velocity? You could try using the x- and y-components or the direction and magnitude of the vector. Remember to normalize these values!\n\nResponding to Change\nIn the previous example, the environment was static, with a stationary target and obstacle. This made the rocket’s task of finding the target easy to accomplish using only its position as input. However, what if the target and the obstacles in the rocket’s path were moving? To handle a more complex and changing environment, I need to expand the neural network’s inputs and consider additional features of the environment. This is similar to what I did with Flappy Bird, as I identified the key data points of the environment to guide the bird’s decision-making process.\nI’ll begin with the simplest version of this scenario, almost identical to the original smart rockets example, but removing obstacles and replacing the fixed target with a random walker controlled by Perlin noise. In this world, I’ll rename the Rocket to Creature and recast the walker as a Glow class that represents a gentle, drifting orb. Imagine that the creature’s goal is to reach the light source and dance in its radiant embrace as long as it can:\nclass Glow {\n  constructor() {\n    //{!2} Two Perlin noise offsets\n    this.xoff = 0;\n    this.yoff = 1000;\n    this.position = createVector();\n    this.r = 24;\n  }\n\n  update() {\n    //{!2} Assign the position according to the Perlin noise.\n    this.position.x = noise(this.xoff) * width;\n    this.position.y = noise(this.yoff) * height;\n    //{!2} Move along the Perlin noise space.\n    this.xoff += 0.01;\n    this.yoff += 0.01;\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(200);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}\nAs the glow moves, the creature should take the glow’s position into account in its decision-making process, as an input to its brain. However, it isn’t sufficient to know only the light’s position; it’s the position relative to the creature’s own that’s key. A nice way to synthesize this information as an input feature is to calculate a vector that points from the creature to the glow. Essentially, I’m reinventing the seek() method from Chapter 5, using a neural network to estimate the steering force:\n\n    seek(target) {\n    //{!1} Calculate a vector from the position to the target.\n    let v = p5.Vector.sub(target.position, this.position);\n\nThis is a good start, but the components of the vector don’t fall within a normalized input range. I could divide v.x by width and v.y by height, but since my canvas isn’t a perfect square, this may skew the data. Another solution is to normalize the vector, but while this would retain information about the direction from the creature to the glow, it would eliminate any measure of the distance. This won’t do either—if the creature is sitting on top of the glow, it should steer differently than if it were very far away. As a solution, I’ll save the distance in a separate variable before normalizing the vector. For it to work as an input feature, though, I still have to normalize the range. While not a perfect normalization from 0 to 1, I’ll divide it by the canvas width, which will provide a practical normalization that retains the relative magnitude:\n\n    seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    // Save the distance in a variable and normalize according to width (one input).\n    let distance = v.mag() / width;\n    // Normalize the vector pointing from the position to the target (two inputs).\n    v.normalize();\n\nAs you may recall, a key element of Reynolds’s steering formula involved comparing the desired velocity to the current velocity. How the vehicle is currently moving plays a significant role in how it should steer! For the creature to consider its own velocity as part of its decision-making, I can include the velocity vector in the inputs to the neural network as well. To normalize these values, dividing the vector’s components by the maxspeed property works beautifully. This retains both the direction and relative magnitude of the vector. The rest of the seek() method follows the same logic as the previous example, with the outputs of the neural network synthesized into a force to be applied to the creature:\n  seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    let distance = v.mag() / width;\n    v.normalize();\n    // Compile the features into an input array.\n    let inputs = [\n      v.x,\n      v.y,\n      distance,\n      this.velocity.x / this.maxspeed,\n      this.velocity.y / this.maxspeed,\n    ];\n    //{!5} Predict the force to apply.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let force = p5.Vector.fromAngle(angle);\n    let magnitude = outputs[1].value;\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }\nEnough has changed in the transition from rockets to creatures that it’s also worth reconsidering the fitness function. Previously, fitness was calculated based on the rocket’s record distance from the target at the end of each generation. Since the target is now moving, I’d prefer to accumulate the amount of time the creature is able to catch the glow as the measure of fitness. This can be achieved by checking the distance between the creature and the glow in the update() method and incrementing a fitness value when they’re intersecting:\n  update(target) {\n    /* The usual updating of position, velocity, acceleration */\n\n    //{!4} Increase the fitness whenever the creature reaches the glow.\n    let d = p5.Vector.dist(this.position, target.position);\n    if (d < this.r + target.r) {\n      this.fitness++;\n    }\n  }\nBoth the Glow and Creature classes include a radius property r, which I’m using to determine intersection.\nSpeeding Up Time\nOne thing you may have noticed about evolutionary computing is that testing the code is a delightful exercise in patience. You have to watch the slow crawl of the simulation play out generation after generation. This is part of the point—I want to watch the process! It’s also a nice excuse to take a break, which is to be encouraged. Head outside and enjoy some nonsimulated nature for a while, or perhaps a soothing cup of tea. Then check back in on your creatures and see how they’re progressing. Take comfort in having to wait only billions of milliseconds rather than the billions of years required for actual biological evolution.\nNevertheless, for the system to evolve, there’s no inherent requirement that you draw and animate the world. Hundreds of generations could be completed in the blink of an eye if you could skip all the time spent rendering the scene. Or, rather than not render the environment at all, you could choose to simply render it less often. This will save you from tearing your hair out every time you change a small parameter and find yourself waiting what seems like hours to see whether it had any effect on the system’s evolution.\nHere’s where I can use one of my favorite features of p5.js: the ability to quickly create standard interface elements. You saw this before in Example 9.4 with createButton(). This time I’ll create a slider to control the number of iterations of a for loop that runs inside draw(). The for loop will contain the code for updating (but not drawing) the simulation. The more times the loop repeats, the faster the animation will seem.\nHere’s the code for this new time slider, excluding all the other global variables and their initializations in setup(). Notice that the code for the visuals is separated from the code for the physics to ensure that rendering still occurs only once per draw() cycle:\n//{!1} A variable to hold the slider\nlet timeSlider;\n\nfunction setup() {\n  //{!1} Create a slider with a min and max range, and a starting value.\n  timeSlider = createSlider(1, 20, 1);\n}\n\nfunction draw() {\n  //{!5} The drawing code happens just once!\n  background(255);\n  glow.show();\n  for (let creature of creatures) {\n    creature.show();\n  }\n  //{!8} The simulation code runs multiple times according to the slider.\n  for (let i = 0; i < timeSlider.value(); i++) {\n    for (let creature of creatures) {\n      creature.seek(glow);\n      creature.update(glow);\n    }\n    glow.update();\n    lifeCounter++;\n  }\n}\nIn p5.js, a slider is defined with three arguments: a minimum value (for when the slider is all the way to the left), a maximum value (for when it’s all the way to the right), and a starting value (for when the page first loads). In this case, the slider allows you to run the simulation at 20x speed to reach the results of evolution more quickly, then slow it back down to 1x speed to bask in the glory of the intelligent behaviors on display.\nHere’s the final version of the example with a new Creature constructor to create a neural network. Everything else related to applying the steps of the GA has remained the same from the Flappy Bird example code.\n\n  Example 11.4: Dynamic Neuroevolutionary Steering\n  \n    \n    \n  \n\nclass Creature {\n  constructor(x, y, brain) {\n    this.position = createVector(x, y);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n    this.r = 4;\n    this.maxspeed = 4;\n    this.fitness = 0;\n\n    if (brain) {\n      this.brain = brain;\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 5,\n        outputs: 2,\n        task: \"regression\",\n        neuroEvolution: true,\n      });\n    }\n  }\n  \n  /* <code>seek()</code> predicts a steering force as described previously. */\n\n  /* <code>update()</code> increments the fitness if the glow is reached as described previously. */\n\n}\nIt’s hard to believe, but this book has been a journey well over 10 years in the making. Thank you, dear reader, for sticking with it. I promise it’s not an infinite loop. However meandering it might have seemed, like a random walk, I’m finally using an arrival steering behavior to reach the final piece of the puzzle, an attempt to bring together all my past explorations in my own version of the Ecosystem Project.\nA Neuroevolutionary Ecosystem\nA few elements in this chapter’s examples don’t quite fit with my dream of simulating a natural ecosystem. The first goes back to an issue I raised in Chapter 9 with the introduction of the bloops. A system of creatures that all live and die together, starting completely over with each subsequent generation—that isn’t how the biological world works! I’d like to revisit this dilemma in this chapter’s context of neuroevolution.\nSecond, and perhaps more important, a major flaw exists in the way I’m extracting features from a scene to train a model. The creatures in Example 11.4 are all-knowing. Sure, it’s reasonable to assume that a creature is aware of its own current velocity, but I’ve also allowed each creature to know the glow’s exact location, regardless of how far away it is or what might be blocking the creature’s vision or senses. This is a bridge too far. It flies in the face of one of the main tenets of autonomous agents I introduced in Chapter 5: an agent should have a limited ability to perceive its environment.\nSensing the Environment\nA common approach to simulating how a real-world creature (or robot) would have a limited awareness of its surroundings is to attach sensors to an agent. Think back to that mouse in the maze from the beginning of the chapter (hopefully it’s been thriving on the cheese it’s been getting as a reward), and now imagine it has to navigate the maze in the dark. Its whiskers might act as proximity sensors to detect walls and turns. The mouse whiskers can’t see the entire maze, but only sense the immediate surroundings. Another example of sensors is a bat using echolocation to navigate, or a car on a winding road where the driver can see only what’s projected in front of the car’s headlights.\nI’d like to build on this idea of the whiskers (or more formally the vibrissae) found in mice, cats, and other mammals. In the real world, animals use their vibrissae to navigate and detect nearby objects, especially in dark or obscured environments (see Figure 11.5). How can I attach whisker-like sensors to my neuroevolutionary-seeking creatures?\n\n  \n  Figure 11.5: Clawdius the cat sensing his environment with his vibrissae\n\nI’ll keep the generic class name Creature but think of them now as the amoeba-like bloops from Chapter 9, enhanced with whisker-like sensors that emanate from their center in all directions:\nclass Creature {\n  constructor(x, y) {\n    // The creature has a position and radius.\n    this.position = createVector(x, y);\n    this.r = 16;\n    // The creature has an array of sensors.\n    this.sensors = [];\n    // The creature has eight sensors.\n    let totalSensors = 8;\n    for (let i = 0; i < totalSensors; i++) {\n      // First, calculate a direction for the sensor.\n      let angle = map(i, 0, totalSensors, 0, TWO_PI);\n      // Create a vector a little bit longer than the radius as the sensor.\n      this.sensors[i] = p5.Vector.fromAngle(angle);\n      this.sensors[i].setMag(this.r * 1.5);\n    }\n  }\n}\nThe code creates a series of vectors, each describing the direction and length of one whisker sensor attached to the creature. However, just the vector isn’t enough. I want the sensor to include a value, a numeric representation of what it’s sensing. This value can be thought of as analogous to the intensity of touch. Just as Clawdius the cat’s whiskers might detect a faint touch from a distant object or a stronger push from a closer one, the virtual sensor’s value could range to represent proximity.\nBefore I go any further, I need to give the creatures something to sense. How about a Food class to describe a circle of deliciousness that the creature wants to find? Each Food object will have a position and a radius:\nclass Food {\n  //{!4} A piece of food has a random position and a fixed radius.\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.r = 50;\n  }\n\n  show() {\n    noStroke();\n    fill(0, 100);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}\nHow can I determine if a creature’s sensor is touching the food? One approach could be to use raycasting. This technique is commonly employed in computer graphics to project straight lines (often representing beams of light) from an origin point in a scene to determine which objects they intersect with. Raycasting is useful for visibility and collision checks, exactly what I’m doing here!\nWhile raycasting would provide a robust solution, it requires more mathematics than I’d like to delve into here. For those interested, an explanation and implementation are available in Coding Challenge #145 on the Coding Train website. For this example, I’ll opt for a more straightforward approach and check whether the endpoint of a sensor lies inside the food circle (see Figure 11.6).\n\n  \n  Figure 11.6: The endpoint of a sensor is inside or outside the food, based on its distance to the center of the food.\n\nBecause I want the sensor to store a value for its sensing along with the sensing algorithm, encapsulating these elements into a Sensor class makes sense:\nclass Sensor {\n  constructor(v) {\n    this.v = v.copy();\n    //{!1} The sensor also stores a value for the proximity of what it’s sensing.\n    this.value = 0;\n  }\n  \n  sense(position, food) {\n    //{!1} Find the tip (or endpoint) of the sensor by adding the creature’s position.\n    let end = p5.Vector.add(position, this.v);\n    //{!1} How far is it from the food’s center?\n    let d = end.dist(food.position);\n    //{!1} If the sensor is within the radius, light up the sensor.  \n    if (d < food.r) {\n      //{!1} The farther into the center of the food, the more the sensor activates.\n      this.value = map(d, 0, food.r, 1, 0);\n    } else {\n      this.value = 0;\n    }\n  }\n}\nNotice that the sensing mechanism gauges the endpoint’s depth within the food’s radius by using the map() function. When the sensor’s endpoint is just touching the outer boundary of the food, value starts at 0. As the endpoint moves closer to the center of the food, value increases, maxing out at 1. If the sensor isn’t touching the food at all, value remains at 0. This gradient of feedback mirrors the varying intensity of touch or pressure in the real world.\nLet’s test out this sensor mechanism with a simple example: one bloop (controlled by the mouse) and one piece of food (placed at the center of the canvas). When the sensors touch the food, they light up, and they get brighter as they get closer to the center of the food.\n\n  Example 11.5: A Bloop with Sensors\n  \n    \n    \n  \n\nlet bloop, food;\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} One bloop, one piece of food\n  bloop = new Creature();\n  food = new Food();\n}\n\nfunction draw() {\n  background(255);\n  // Temporarily control the bloop with the mouse.\n  bloop.position.x = mouseX;\n  bloop.position.y = mouseY;\n  // Draw the food and the bloop.\n  food.show();\n  bloop.show();\n  // The bloop senses the food.\n  bloop.sense(food);\n}\n\nclass Creature {\n  constructor(x, y) {\n    this.position = createVector(x, y);\n    this.r = 16;\n\n    //{!8} Create the sensors for the creature.\n    this.sensors = [];\n    // Let’s use more sensors! How about 15?\n    let totalSensors = 15;\n    for (let i = 0; i < totalSensors; i++) {\n      let a = map(i, 0, totalSensors, 0, TWO_PI);\n      let v = p5.Vector.fromAngle(a);\n      v.mult(this.r * 2);\n      this.sensors[i] = new Sensor(v);\n    }\n  }\n\n  //{!4} Call the <code>sense()</code> method for each sensor.\n  sense(food) {\n    for (let sensor of this.sensors) {\n      sensor.sense(this.position, food);\n    }\n  }\n\n  // Draw the creature and all the sensors.\n  show() {\n    push();\n    translate(this.position.x, this.position.y);\n    for (let sensor of this.sensors) {\n      stroke(0);\n      line(0, 0, sensor.v.x, sensor.v.y);\n      if (sensor.value > 0) {\n        fill(255, sensor.value * 255);\n        stroke(0, 100)\n        circle(sensor.v.x, sensor.v.y, 8);\n      }\n    }\n    noStroke();\n    fill(0);\n    circle(0, 0, this.r * 2);\n    pop();\n  }\n}\nIn the example, the creature’s sensors are drawn as lines from its center. When a sensor detects something (when value is greater than 0), a circle appears. To visualize the strength of the sensor reading, I use value to set its transparency.\nLearning from the Sensors\nAre you thinking what I’m thinking? What if the values of a creature’s sensors are the inputs to a neural network? Assuming I give the creatures control of their own movements again, I could write a new think() method that processes the sensor values through the neural network brain and outputs a steering force, just as in the last two steering examples:\n  think() {\n    // Build an input array from the sensor values.\n    let inputs = [];\n    for (let i = 0; i < this.sensors.length; i++) {\n      inputs[i] = this.sensors[i].value;\n    }\n    // Predict a steering force from the sensors.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let magnitude = outputs[1].value;\n    let force = p5.Vector.fromAngle(angle)\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }\nThe logical next step might be to incorporate all the usual parts of the GA, writing a fitness function (how much food did each creature eat?) and performing selection after a fixed generational time period. But this is a great opportunity to revisit the principles of a continuous ecosystem and aim for a more sophisticated environment and set of potential behaviors for the creatures themselves. Instead of a fixed life span cycle for each generation, I’ll bring back Chapter 9’s health score for each creature. For every cycle through draw() that a creature lives, its health deteriorates a little bit:\n\n  class Creature {  \n  constructor() {\n    /* All of the creature's properties */\n    // The health starts at 100.\n    this.health = 100;\n  } \n\n  update() {\n    /* The usual updating position, velocity, acceleration */\n    // Lose some health!\n    this.health -= 0.25;\n  }\n\nIn draw(), if any bloop’s health drops below 0, that bloop dies and is deleted from the bloops array. And for reproduction, instead of performing the usual crossover and mutation all at once, each bloop (with a health greater than 0) will have a 0.1 percent chance of reproducing:\n  function draw() {\n    for (let i = bloops.length - 1; i >= 0; i--) {\n      if (bloops[i].health < 0) {\n        bloops.splice(i, 1);\n      } else if (random(1) < 0.001) {\n        let child = bloops[i].reproduce();\n        bloops.push(child);\n      }\n    }\n  }\nIn reproduce(), I’ll use the copy() method (cloning) instead of the crossover() method (mating), with a higher-than-usual mutation rate to help introduce variation. (I encourage you to consider ways to incorporate crossover instead.) Here’s the code:\n  reproduce() {\n    //{!2} Copy and mutate rather than use crossover and mutate.\n    let brain = this.brain.copy();\n    brain.mutate(0.1);\n    return new Creature(this.position.x, this.position.y, brain);\n  }\nFor this to work, some bloops should live longer than others. By consuming food, their health increases, giving them extra time to reproduce. I’ll manage this in an eat() method of the Creature class:\n  eat(food) {\n    // If the bloop is close to the food, increase its health!\n    let d = p5.Vector.dist(this.position, food.position);\n    if (d < this.r + food.r) {\n      this.health += 0.5;\n    }\n  }\nIs this enough for the system to evolve and find its equilibrium? I could dive deeper, tweaking parameters and behaviors in pursuit of the ultimate evolutionary system. The allure of this infinite rabbit hole is one I cannot easily escape, but I’ll explore it on my own time. For the purpose of this book, I invite you to run the example, experiment, and draw your own conclusions.\n\n  Example 11.6: A Neuroevolutionary Ecosystem\n  \n    \n    \n  \n\nlet bloops = [];\nlet food = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i < 20; i++) {\n    bloops[i] = new Creature(random(width), random(height));\n  }\n  for (let i = 0; i < 8; i++) {\n    food[i] = new Food();\n  }\n}\n\nfunction draw() {\n  background(255);\n  for (let i = bloops.length - 1; i >= 0; i--) {\n    bloops[i].think();\n    bloops[i].eat();\n    bloops[i].update();\n    bloops[i].borders();\n    if (bloops[i].health < 0) {\n      bloops.splice(i, 1);\n    } else if (random(1) < 0.001) {\n      let child = bloops[i].reproduce();\n      bloops.push(child);\n    }\n  }\n  for (let treat of food) {\n    treat.show();\n  }\n  for (let bloop of bloops) {\n    bloop.show();\n  }\n}\nThe final example also includes a few additional features that you’ll find in the accompanying online code, such as an array of food that shrinks as it gets eaten (respawning when it’s depleted). Additionally, the bloops shrink as their health deteriorates.\n\n  The Ecosystem Project\n  Try incorporating the concept of a brain into the creatures in your world!\n  \n    Can different creatures have different goals and incentives? Are some searching for food while others seek different resources? What about creatures avoiding dangers like predators or poisons?\n    What are each creature’s inputs and outputs?\n    How do the creatures perceive? Do they see everything or have limits based on sensors?\n    What strategies can you employ to establish and maintain balance in your ecosystem?\n  \n  \n    \n    \n  \n\nThe End\nIf you’re still reading, thank you! You’ve reached the end of the book. But for as much material as this book contains, I’ve barely scratched the surface of the physical world we inhabit and of techniques for simulating it. I intend for this book to live as an ongoing project, and I hope to continue adding new tutorials and examples to the book’s website, as well as expand and update the accompanying video tutorials at the Coding Train website.\nYour feedback is truly appreciated, so please get in touch via email at daniel@shiffman.net or by contributing to the GitHub repository, in keeping with the open source spirit of the project. Share your work. Stay in touch. Let’s be two with nature.\n\n  \n  \n\n",
  "htmlContent": "<section data-type=\"chapter\" id=\"section-neuroevolution\">\n<h1 id=\"chapter-11-neuroevolution\">Chapter 11. Neuroevolution</h1>\n<div class=\"chapter-opening-quote\">\n  <blockquote data-type=\"epigraph\">\n    <p>Reading about nature is fine, but if</p>\n    <p>a person walks in the woods and listens</p>\n    <p>carefully, they can learn more than</p>\n    <p>what is in books.</p>\n    <div class=\"chapter-opening-quote-source\">\n      <p>—George Washington Carver</p>\n    </div>\n  </blockquote>\n</div>\n<div class=\"chapter-opening-figure\">\n  <figure>\n    <img src=\"/content/images/11_nn_ga/11_nn_ga_1.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n  <h3 id=\"star-nosed-moles-courtesy-of-new-york-public-library-c-18261828\">Star-nosed moles (courtesy of New York Public Library, c. 1826–1828)</h3>\n  <p>The star-nosed mole (<em>Condylura cristata</em>), found mainly in the northeastern United States and eastern Canada, has a unique and highly specialized nasal organ. Evolved over numerous generations, its nose consists of 22 tentacles with over 25,000 minute sensory receptors. Despite the moles being functionally blind, these tentacles allow them to create a detailed spatial map of their surroundings. They can navigate their dark underground habitat with astonishing precision and speed, quickly identifying and consuming edible items in a matter of milliseconds.</p>\n</div>\n<p>Congratulations! You’ve made it to the final act of this book. Take a moment to celebrate all that you’ve learned.</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_2.png\" alt>\n  <figcaption></figcaption>\n</figure>\n<p>Throughout this book, you’ve explored the fundamental principles of interactive physics simulations with p5.js, dived into the complexities of agent and other rule-based behaviors, and dipped your toe into the exciting realm of machine learning. You’ve become a natural!</p>\n<p>However, <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a> merely scratched the surface of working with data and neural network–based machine learning—a vast landscape that would require countless sequels to this book to cover comprehensively. My goal was never to go deep into neural networks, but simply to establish the core concepts in preparation for a grand finale, where I find a way to integrate machine learning into the world of animated, interactive p5.js sketches and bring together as many of our new <em>Nature of Code</em> friends as possible for one last hurrah.</p>\n<p>The path forward passes through the field of <strong>neuroevolution</strong>, a style of machine learning that combines the GAs from <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a> with the neural networks from <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a>. A neuroevolutionary system uses Darwinian principles to evolve the weights (and in some cases, the structure itself) of a neural network over generations of trial-and-error learning. In this chapter, I’ll demonstrate how to use neuroevolution with a familiar example from the world of gaming. I’ll then finish off by varying Craig Reynolds’s steering behaviors from <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a> so that they are learned through neuroevolution.</p>\n<h2 id=\"reinforcement-learning\">Reinforcement Learning</h2>\n<p>Neuroevolution shares many similarities with another machine learning methodology that I briefly referenced in <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a>, <strong>reinforcement learning</strong>, which incorporates machine learning into a simulated environment. A neural network–backed agent learns by interacting with the environment and receiving feedback about its decisions in the form of rewards or penalties. It’s a strategy built around observation.</p>\n<p>Think of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.) Presumably, the mouse will learn over time to turn left. Its biological neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch). If the observation is negative, the network can adjust its weights in order to make a different decision the next time.</p>\n<p>In the real world, reinforcement learning is commonly used not for tormenting rodents but rather for developing robots. At time <em>t</em>, the robot performs a task and observes the results. Did it crash into a wall or fall off a table, or is it unharmed? As time goes on, the robot learns to interpret the signals from its environment in the optimal way to accomplish its tasks and avoid harm.</p>\n<p>Instead of a mouse or a robot, now think about any of the example objects from earlier in this book (walker, mover, particle, vehicle). Imagine embedding a neural network into one of these objects and using it to calculate a force or another action. The neural network could receive its inputs from the environment (such as distance to an obstacle) and output some kind of decision. Perhaps the network chooses from a set of discrete options (move left or right) or picks a set of continuous values (the magnitude and direction of a steering force).</p>\n<p>Is this starting to sound familiar? It’s no different from the way a neural network performed after training in the <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a> examples, receiving inputs and predicting a classification or regression! Actually training one of these objects to make a good decision is where the reinforcement learning process diverges from the supervised learning approach. To better illustrate, let’s start with a hopefully easy-to-understand and possibly familiar scenario, the game <em>Flappy Bird</em> (see Figure 11.1).</p>\n<p>The game is deceptively simple. You control a small bird that continually moves horizontally across the screen. With each tap or click, the bird flaps its wings and rises upward. The challenge? A series of vertical pipes spaced apart at irregular intervals emerge from the right. The pipes have gaps, and your primary objective is to navigate the bird safely through these gaps. If you hit a pipe, it’s game over. As you progress, the game’s speed increases, and the more pipes you navigate, the higher your score.</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_3.png\" alt=\"Figure 11.1: The Flappy Bird game\">\n  <figcaption>Figure 11.1: The <em>Flappy Bird</em> game</figcaption>\n</figure>\n<p>Suppose you want to automate the gameplay, and instead of a human tapping, a neural network will make the decision of whether to flap. Could machine learning work here? Skipping over the initial data steps in the machine learning life cycle for a moment, let’s think about how to choose a model. What are the inputs and outputs of the neural network?</p>\n<p>This is quite the intriguing question because, at least in the case of the inputs, there isn’t a definitive answer. If you don’t know much about the game or don’t want to put your thumb on the scale in terms of identifying which aspects of the game are important, it might make the most sense to have the inputs be all the pixels of the game screen. This approach attempts to feed <em>everything</em> about the game into the model and let the model figure out for itself what matters.</p>\n<p>I’ve played <em>Flappy Bird</em> enough that I feel I understand it quite well, however. I can therefore bypass feeding all the pixels to the model and boil down the essence of the game to just a few input data points necessary for making predictions. These data points, often referred to as <strong>features</strong> in machine learning, represent the distinctive characteristics of the data that are most salient for the prediction. Imagine biting into a mysteriously juicy fruit—features like its taste (sweet!), texture (crisp!), and color (a vibrant red!) help you identify it as an apple. In the case of <em>Flappy Bird</em>, the most crucial features are listed here:</p>\n<ol>\n  <li>The y-position of the bird</li>\n  <li>The y-velocity of the bird</li>\n  <li>The y-position of the next top pipe’s opening</li>\n</ol>\n<div class=\"avoid-break\">\n  <ol>\n    <li value=\"4\">The y-position of the next bottom pipe’s opening</li>\n    <li value=\"5\">The x-distance to the next pipe</li>\n  </ol>\n</div>\n<p>These features are illustrated in Figure 11.2.</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_4.png\" alt=\"Figure 11.2: The Flappy Bird input features for a neural network\">\n  <figcaption>Figure 11.2: The <em>Flappy Bird</em> input features for a neural network</figcaption>\n</figure>\n<p>The neural network will have five inputs, one for each feature, but what about the outputs? Is this a classification problem or a regression problem? This may seem like an odd question to ask in the context of a game like <em>Flappy Bird</em>, but it’s actually quite important and relates to the way the game is controlled. Tapping the screen, pressing a button, or using keyboard controls are all examples of classification. After all, the player has only a discrete set of choices: tap or not; press W, A, S, or D on the keyboard. On the other hand, using an analog controller like a joystick leans toward regression. A joystick can be tilted in varying degrees in any direction, translating to continuous output values for both its horizontal and vertical axes.</p>\n<p>For <em>Flappy Bird</em>, the outputs represent a classification decision with only two choices:</p>\n<ul>\n  <li>Flap.</li>\n  <li>Don’t flap.</li>\n</ul>\n<p>This means the network should have two outputs, suggesting an overall network architecture like the one in Figure 11.3.</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_5.png\" alt=\"Figure 11.3: The neural network for Flappy Bird as ml5.js might design it\">\n  <figcaption>Figure 11.3: The neural network for <em>Flappy Bird</em> as ml5.js might design it</figcaption>\n</figure>\n<p>I now have all the information necessary to configure a model and let ml5.js build it:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let options = {\n  inputs: 5,\n  outputs: [\"flap\", \"no flap\"],\n  task: \"classification\"\n};\nlet birdBrain = ml5.neuralNetwork(options);</pre>\n<p>What next? If I were following the steps I laid out in <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a>, I’d have to go back to steps 1 and 2 of the machine learning process: data collection and preparation. How exactly would that work here? One idea could be to scour the earth for the greatest <em>Flappy Bird</em> player of all time and record them playing for hours. I could log the input features for every moment of gameplay along with whether the player flapped or not. Feed all that data into the model, train it, and I can see the headlines already: “Artificial Intelligence Bot Defeats Flappy Bird.”</p>\n<p>But wait a second; has a computerized agent really learned to play <em>Flappy Bird</em> on its own, or has it simply learned to mirror the gameplay of a human? What if that human missed a key aspect of <em>Flappy Bird</em> strategy? The automated player would never discover it. Not to mention that collecting all that data would be incredibly tedious.</p>\n<p>The problem here is that I’ve reverted to a supervised learning scenario like the ones from <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a>, but this is supposed to be a section about reinforcement learning. Unlike supervised learning, in which the correct answers are provided by a training dataset, the agent in reinforcement learning learns the answers—the optimal decisions—through trial and error by interacting with the environment and receiving feedback. In the case of <em>Flappy Bird</em>, the agent could receive a positive reward every time it successfully navigates a pipe, but a negative reward if it hits a pipe or the ground. The agent’s goal is to figure out which actions lead to the most cumulative rewards over time.</p>\n<p>At the start, the <em>Flappy Bird</em> agent won’t know the best time to flap its wings, leading to many crashes. As it accrues more and more feedback from countless play-throughs, however, it will begin to refine its actions and develop the optimal strategy to navigate the pipes without crashing, maximizing its total reward. This process of <em>learning by doing</em> and optimizing based on feedback is the essence of reinforcement learning.</p>\n<p>As the chapter goes on, I’ll explore the principles I’m outlining here, but with a twist. Traditional techniques in reinforcement learning involve defining a strategy (called a <strong>policy</strong>) and a corresponding <strong>reward function</strong> to provide feedback for adjusting the policy. Instead of going down this road, however, I’m going to turn toward the star of this chapter, neuroevolution.</p>\n<h2 id=\"evolving-neural-networks-is-neat\">Evolving Neural Networks Is NEAT!</h2>\n<p>Instead of using traditional backpropagation, a policy, and a reward function, neuroevolution applies principles of GAs and natural selection to train the weights in a neural network. This technique unleashes many neural networks on a problem at once. Periodically, the best-performing neural networks are “selected,” and their “genes” (the network connection weights) are combined and mutated to create the next generation of networks. Neuroevolution is especially effective in environments where the learning rules aren’t precisely defined or the task is complex, with numerous potential solutions.</p>\n<p>One of the first examples of neuroevolution can be found in the 1994 paper <a href=\"https://doi.org/10.1007/3-540-58484-6_288\">“Genetic Lander: An Experiment in Accurate Neuro-genetic Control” by Edmund Ronald and Marc Schoenauer</a>. In the 1990s, traditional neural network training methods were still nascent, and this work explored an alternative approach. The paper describes how a simulated spacecraft—in a game aptly named <em>Lunar Lander</em>—can learn how to safely descend and land on a surface. Rather than use handcrafted rules or labeled datasets, the researchers opted to use GAs to evolve and train neural networks over multiple generations. And it worked!</p>\n<p>In 2002, Kenneth O. Stanley and Risto Miikkulainen expanded on earlier neuroevolutionary approaches with their paper <a href=\"https://doi.org/10.1162/106365602320169811\">“Evolving Neural Networks Through Augmenting Topologies”</a>. Unlike the lunar lander method that focused on evolving the weights of a neural network, Stanley and Miikkulainen introduced a method that also evolved the network’s structure itself! Their NEAT algorithm—NeuroEvolution of Augmenting Topologies—starts with simple networks and progressively refines their topology through evolution. As a result, NEAT can discover network architectures tailored to specific tasks, often yielding more optimized and effective solutions.</p>\n<p>A comprehensive NEAT implementation would require going deeper into neural network architectures and working directly with TensorFlow.js. My goal instead is to emulate Ronald and Schoenauer’s original research in the modern context of the web browser with ml5.js. Rather than use the <em>Lunar Lander</em> game, I’ll give this a try with <em>Flappy Bird.</em> And for that, I first need to code a version of <em>Flappy Bird</em> where my neuroevolutionary network can operate.</p>\n<h2 id=\"coding-flappy-bird\">Coding Flappy Bird</h2>\n<p><em>Flappy Bird</em> was created by Vietnamese game developer Dong Nguyen in 2013. In January 2014, it became the most downloaded app on the Apple App Store. However, on February 8 of that year, Nguyen announced that he was removing the game because of its addictive nature. Since then, it has become one of the most cloned games in history.</p>\n<p><em>Flappy Bird</em> is a perfect example of Nolan’s law, an aphorism attributed to the founder of Atari and creator of <em>Pong</em>, Nolan Bushnell: “All the best games are easy to learn and difficult to master.” It’s also a terrific game for beginner coders to re-create as a learning exercise, and it fits perfectly with the concepts in this book.</p>\n<p>To program the game with p5.js, I’ll start by defining a <code>Bird</code> class. This may shock you, but I’m going to skip using <code>p5.Vector</code> for this demonstration and instead use separate <code>x</code> and <code>y</code> properties for the bird’s position. Since the bird moves only along the vertical axis in the game, <code>x</code> remains constant! Therefore, the <code>velocity</code> (and all the relevant forces) can be a single scalar value for just the y-axis.</p>\n<p>To simplify the code even further, I’ll add the forces directly to the bird’s velocity instead of accumulating them into an <code>acceleration</code> variable. In addition to the usual <code>update()</code>, I’ll include a <code>flap()</code> method for the bird to fly upward. The <code>show()</code> method isn’t included here as it only draws a circle. Here’s the code:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Bird {\n  constructor() {\n    // The bird’s position (<code>x</code> will be constant)\n    this.x = 50\n    this.y = 120;\n    // Velocity and forces are scalar since the bird moves only along the y-axis.\n    this.velocity = 0;\n    this.gravity = 0.5;\n    this.flapForce = -10;\n  }\n\n  // The bird flaps its wings.\n  flap() {\n    this.velocity += this.flapForce;\n  }\n\n  update() {\n    // Add gravity.\n    this.velocity += this.gravity;\n    this.y += this.velocity;\n    // Dampen velocity.\n    this.velocity *= 0.95;\n    // Handle the floor.\n    if (this.y > height) {\n      this.y = height;\n      this.velocity = 0;\n    }\n  }\n}</pre>\n<p>The other primary elements of the game are the pipes that the bird must navigate through. I’ll create a <code>Pipe</code> class to describe a pair of rectangles, one that emanates from the top of the canvas and one from the bottom. Just as the bird moves only vertically, the pipes slide along only the horizontal axis, so the properties can also be scalar values rather than vectors. The pipes move at a constant speed and don’t experience any other forces.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Pipe {\n  constructor() {\n    // The size of the opening between the two parts of the pipe\n    this.spacing = 100;\n    // A random height for the top of the pipe\n    this.top = random(height - this.spacing);\n    // The starting position of the bottom pipe (based on the top)\n    this.bottom = this.top + this.spacing;\n    // The pipe starts at the edge of the canvas.\n    this.x = width;\n    // The width of the pipe\n    this.w = 20;\n    // The horizontal speed of the pipe\n    this.velocity = 2;\n  }\n\n  // Draw the two pipes.\n  show() {\n    fill(0);\n    noStroke();\n    rect(this.x, 0, this.w, this.top);\n    rect(this.x, this.bottom, this.w, height - this.bottom);\n  }\n\n  // Update the horizontal position.\n  update() {\n    this.x -= this.velocity;\n  }\n}</pre>\n<p>To be clear, the game depicts a bird flying through pipes—the bird is moving along two dimensions while the pipes remain stationary. However, it’s simpler to code the game as if the bird is stationary in its horizontal position and the pipes are moving.</p>\n<p>With a <code>Bird</code> and <code>Pipe</code> class written, I’m almost set to run the game. However, a key piece is missing: collisions. The whole game rides on the bird attempting to avoid the pipes! Fortunately, this is nothing new. You’ve seen many examples of objects checking their positions against others throughout this book. I have a design choice to make, though. A method to check collisions could logically be placed in either the <code>Bird</code> class (to check whether the bird hits a pipe) or the <code>Pipe</code> class (to check whether a pipe hits the bird). Either can be justified, depending on your point of view.</p>\n<p>I’ll place the method in the <code>Pipe</code> class and call it <code>collides()</code>. The code itself is a little trickier than you might think at first glance, as the method needs to check both the top and bottom rectangles of a pipe against the position of the bird. I could approach this in a variety of ways. One way is to first check whether the bird is vertically within the bounds of either rectangle (either above the bottom of the top pipe or below the top of the bottom one). But the bird is colliding with the pipe only if the bird is also horizontally within the boundaries of the pipe’s width. An elegant way to write this is to combine each of these checks with a logical <em>and</em>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  collides(bird) {\n    // Is the bird within the vertical range of the top or bottom pipe?\n    let verticalCollision = bird.y &#x3C; this.top || bird.y > this.bottom;\n    // Is the bird within the horizontal range of the pipes?\n    let horizontalCollision = bird.x > this.x &#x26;&#x26; bird.x &#x3C; this.x + this.w;\n    //{!1} If it’s both a vertical and horizontal hit, it’s a hit!\n    return verticalCollision &#x26;&#x26; horizontalCollision;\n  }</pre>\n<p>The algorithm currently treats the bird as a single point and doesn’t take into account its size. This detail should be improved for a more realistic version of the game.</p>\n<p>All that’s left is to write <code>setup()</code> and <code>draw()</code>. I need a single variable for the bird and an array for a list of pipes. The interaction is just a single click of the mouse, which triggers the bird’s <code>flap()</code> method. Rather than build a fully functional game with a score, end screen, and other usual elements, I’ll just make sure that the game mechanics are working by drawing the text <em>OOPS!</em> near any pipe when a collision occurs. The code also assumes an additional <code>offscreen()</code> method on the <code>Pipe</code> class for when a pipe has moved beyond the left edge of the canvas.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-111-flappy-bird-clone\">Example 11.1: Flappy Bird Clone</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/Pv-JlO0cl\" data-example-path=\"examples/11_nn_ga/11_1_flappy_bird\"><img src=\"/content/examples/11_nn_ga/11_1_flappy_bird/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bird;\nlet pipes = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} Create a bird and start with one pipe.\n  bird = new Bird();\n  pipes.push(new Pipe());\n}\n\n//{!3} The bird flaps its wings when the mouse is clicked.\nfunction mousePressed() {\n  bird.flap();\n}\n\nfunction draw() {\n  background(255);\n  // Handle all the pipes.\n  for (let i = pipes.length - 1; i >= 0; i--) {\n    pipes[i].show();\n    pipes[i].update();\n    if (pipes[i].collides(bird)) {\n      text(\"OOPS!\", pipes[i].x, pipes[i].top + 20);\n    }\n    if (pipes[i].offscreen()) {\n      pipes.splice(i, 1);\n    }\n  }\n  // Update and show the bird.\n  bird.update();\n  bird.show();\n  //{!3} Add a new pipe every 100 frames.\n  if (frameCount % 100 === 0) {\n    pipes.push(new Pipe());\n  }\n}</pre>\n<p>The trickiest aspect of this code lies in spawning the pipes at regular intervals with the <code>frameCount</code> variable and modulo operator. In p5.js, <code>frameCount</code> is a system variable that tracks the number of frames rendered since the sketch began, incrementing with each cycle of the <code>draw()</code> loop. The modulo operator, denoted by <code><strong>%</strong></code>, returns the remainder of a division operation. For example, <code>7 % 3</code> yields <code>1</code> because when dividing 7 by 3, the result is 2 with a remainder of 1. The Boolean expression <code>frameCount % 100 === 0</code> therefore checks whether the current <code>frameCount</code> value, when divided by 100, has a remainder of 0. This condition is true every 100 frames, and at those frames, a new pipe is spawned and added to the <code>pipes</code> array.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-111\">Exercise 11.1</h3>\n  <p>Implement a scoring system that awards points for successfully navigating through each set of pipes. Feel free to also add your own visual design elements for the bird, pipes, and environment!</p>\n</div>\n<h2 id=\"neuroevolutionary-flappy-bird\">Neuroevolutionary Flappy Bird</h2>\n<p>My <em>Flappy Bird</em> clone, as it currently stands, is controlled by mouse clicks. Now I want to cede control of the game to the computer and use neuroevolution to teach it how to play. Luckily, the process of neuroevolution is already baked into ml5.js, so making this switch will be relatively straightforward. The first step is to give the bird a brain so it can decide on its own whether to flap its wings.</p>\n<h3 id=\"the-bird-brain\">The Bird Brain</h3>\n<p>When I introduced reinforcement learning, I established a list of input features that should make up the bird’s decision-making process. I’m going to use that same list but with one simplification. Since the size of the opening between the pipes is constant, there’s no need to include the y-positions of both the top and bottom; one or the other will suffice. The input features are therefore as follows:</p>\n<ol>\n  <li>The y-position of the bird</li>\n  <li>The y-velocity of the bird</li>\n  <li>The y-position of the next pipe’s top (or bottom!) opening</li>\n  <li>The x-distance to the next pipe</li>\n</ol>\n<p>The two outputs represent the bird’s two options: to flap or not to flap. With the inputs and outputs set, I can add a <code>brain</code> property to the bird’s constructor to hold an ml5.js neural network with the appropriate configuration. Just to demonstrate a different coding style here, I’ll skip including a separate <code>options</code> variable and pass the properties as an object literal directly into the <code>ml5.neuralNetwork()</code> function. Note the addition of a <code>neuroEvolution</code> property set to <code>true</code>. This is necessary to enable some of the features I’ll be using later in the code.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  constructor() {\n    this.brain = ml5.neuralNetwork({\n      // A bird’s brain receives four inputs and classifies them into one of two labels.\n      inputs: 4,\n      outputs: [\"flap\", \"no flap\"],\n      task: \"classification\",\n      //{!1} A new property necessary to enable neuroevolution functionality\n      neuroEvolution: true\n    });\n  }</pre>\n<p>Next, I’ll add a new method called <code>think()</code> to the <code>Bird</code> class to calculate all the necessary inputs for the bird at each moment in time. The first two inputs are easy—they’re simply the <code>y</code> and <code>velocity</code> properties of the bird. However, for inputs 3 and 4, I need to determine which pipe is the next pipe.</p>\n<p>At first glance, it might seem that the next pipe is always the first one in the array, since the pipes are added one at a time to the end of the array. However, after a pipe passes the bird, it’s no longer relevant, and there’s still some time between when this happens and when that pipe exits the canvas and is removed from the beginning of the array. I therefore need to find the first pipe in the array whose right edge (x-position plus width) is greater than the bird’s x-position:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  think(pipes) {\n    let nextPipe = null;\n    for (let pipe of pipes) {\n      //{!4} The next pipe is the one that hasn’t passed the bird yet.\n      if (pipe.x + pipe.w > this.x) {\n        nextPipe = pipe;\n        break;\n      }\n    }</pre>\n</div>\n<p>Once I have the next pipe, I can create the four inputs:</p>\n<div class=\"snip-above snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">    let inputs = [\n      // y-position of the bird\n      this.y,\n      // y-velocity of the bird\n      this.velocity,\n      // Top opening of the next pipe\n      nextPipe.top,\n      //{!1} Distance to the next pipe\n      nextPipe.x - this.x,\n    ];</pre>\n</div>\n<p>This is close, but I’ve forgotten a critical step. The range of all input values is determined by the dimensions of the canvas, but a neural network expects values in a standardized range, such as 0 to 1. One method to normalize these values is to divide the inputs related to vertical properties by <code>height</code>, and those related to horizontal ones by <code>width</code>:</p>\n<div class=\"snip-above snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">    let inputs = [\n      //{!4} All the inputs are now normalized by width and height.\n      this.y / height,\n      this.velocity / height,\n      nextPipe.top / height,\n      (nextPipe.x - this.x) / width,\n    ];</pre>\n</div>\n<p>With the inputs in hand, I’m ready to pass them to the neural network’s <code>classify()</code> method. I have another small problem, however: <code>classify()</code> is asynchronous, meaning I’d have to implement a callback inside the <code>Bird</code> class to process the model’s decision. This would add a significant level of complexity to the code, but luckily, it’s entirely unnecessary in this case. Asynchronous callbacks with ml5.js’s machine learning functions are typically needed because of the time required to process the large amount of data in the model. Without a callback, the code might have to wait a long time to get a result, and if the model is running as part of a p5.js sketch, that delay could severely impact the smoothness of the animation. The neural network here, however, has only four floating-point<br>inputs and two output labels! It’s tiny and can run fast enough that there’s no reason to use asynchronous code.</p>\n<div class=\"avoid-break\">\n  <p>For completeness, I include a version of the example on the book’s website that implements neuroevolution with asynchronous callbacks. For this discussion, however, I’m going to use a feature of ml5.js that allows me to take a shortcut. The method <code>classifySync()</code> is identical to <code>classify()</code>, but it runs synchronously, meaning the code stops and waits for the results before moving on. You should be very careful when using this version of the method as it can cause problems in other contexts, but it will work well for this simple scenario. Here’s the end of the <code>think()</code> method with <code>classifySync()</code>:</p>\n</div>\n<div class=\"snip-above\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">    let results = this.brain.classifySync(inputs);\n    if (results[0].label === \"flap\") {\n      this.flap();\n    }\n  }</pre>\n</div>\n<p>The neural network’s prediction is in the same format as the gesture classifier from <a href=\"/neural-networks#section-neural-networks\">Chapter 10</a>, and the decision can be made by checking the first element of the <code>results</code> array. If the output label is <code>\"flap\"</code>, then call <code>flap()</code>.</p>\n<p>Now that I’ve finished the <code>think()</code> method, the real challenge can begin: teaching the bird to win the game by consistently flapping its wings at the right moment. This is where the GA comes back into the picture. Recalling the discussion from <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>, three key principles underpin Darwinian evolution: variation, selection, and heredity. I’ll revisit each of these principles in turn as I implement the steps of the GA in this new context of neural networks.</p>\n<h3 id=\"variation-a-flock-of-flappy-birds\">Variation: A Flock of Flappy Birds</h3>\n<p>A single bird with a randomly initialized neural network isn’t likely to have any success at all. That lone bird will most likely jump incessantly and fly way off-screen, or sit perched at the bottom of the canvas awaiting collision after collision with the pipes. This erratic and nonsensical behavior is a reminder: a randomly initialized neural network lacks any knowledge or experience. The bird is essentially making wild guesses for its actions, so success is going to be rare.</p>\n<p>This is where the first key principle of GAs comes in: <strong>variation</strong>. The hope is that by introducing as many different neural network configurations as possible, a few might perform slightly better than the rest. The first step toward variation is to add an array of many birds (Figure 11.4).</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_6.png\" alt=\"Figure 11.4: A population of birds, each with unique neural networks, navigating through the pipes in the neuroevolution process\">\n  <figcaption>Figure 11.4: A population of birds, each with unique neural networks, navigating through the pipes in the neuroevolution process</figcaption>\n</figure>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Population size\nlet populationSize = 200;\n// Array of birds\nlet birds = [];\n\nfunction setup() {\n  //{!3} Create the bird population.\n  for (let i = 0; i &#x3C; populationSize; i++) {\n    birds[i] = new Bird();\n  }\n  //{!1} Run the computations on the CPU for better performance.\n  ml5.setBackend(\"cpu\");\n}\n\nfunction draw() {\n  for (let bird of birds) {\n    //{!1} This is the new method for the bird to make a decision to flap or not.\n    bird.think(pipes);\n    bird.update();\n    bird.show();\n  }\n}</pre>\n<p>You might notice a peculiar line of code that’s crept into the <code>setup()</code> function: <code>ml5.setBackend(\"cpu\")</code>. When running neural networks, a lot of the heavy computational lifting is often offloaded to the GPU. This is the default behavior, and it’s especially critical for the larger pretrained models included with ml5.js.</p>\n<div data-type=\"note\">\n  <h3 id=\"gpu-vs-cpu\">GPU vs. CPU</h3>\n  <ul>\n    <li><strong>Graphics processing unit (GPU):</strong> Originally designed for rendering graphics, GPUs are adept at handling a massive number of operations in parallel. This makes them excellent for the kinds of math operations and computations that machine learning models frequently perform.</li>\n    <li><strong>Central processing unit (CPU):</strong> Often considered the brain or general-purpose heart of a computer, a CPU handles a wider variety of tasks than the specialized GPU, but it isn’t built to do as many tasks simultaneously.</li>\n  </ul>\n</div>\n<p>But there’s a catch! Transferring data to and from the GPU introduces overhead. In most cases,<br>the gains from the GPU’s parallel processing more than offset this overhead, but for a tiny model<br>like the one here, copying data to the GPU and back actually slows the neural network. Calling <code>ml5.setBackend(\"cpu\")</code> tells ml5.js to run the neural network computations on the CPU instead. At least in this simple case of tiny bird brains, this is the more efficient choice.</p>\n<h3 id=\"selection-flappy-bird-fitness\">Selection: Flappy Bird Fitness</h3>\n<p>Once I have a diverse population of birds, each with its own neural network, the next step in the GA is <strong>selection</strong>. Which birds should pass on their genes (in this case, neural network weights) to the next generation? In the world of <em>Flappy Bird</em>, the measure of success is the ability to stay alive the longest by avoiding the pipes. This is the bird’s <em>fitness</em>. A bird that dodges many pipes is considered more fit than one that crashes into the first pipe it encounters.</p>\n<p>To track each bird’s fitness, I’ll add two properties to the <code>Bird</code> class, <code>fitness</code> and <code>alive</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  constructor() {\n    // The bird’s fitness\n    this.fitness = 0;\n    //{!1} Is the bird alive or not?\n    this.alive = true;\n  }</pre>\n<p>I’ll assign the fitness a numeric value that increases by one every cycle through <code>draw()</code>, as long as the bird remains alive. The birds that survive longer should have a higher fitness value. This mechanism mirrors the reinforcement learning technique of rewarding good decisions. In reinforcement learning, however, an agent receives immediate feedback for every decision it makes, allowing it to adjust its policy accordingly. Here, the bird’s fitness is a cumulative measure of its overall success and will be applied only during the selection step of the GA.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    //{!1} Increment the fitness each time through <code>update()</code>.\n    this.fitness++;\n  }</pre>\n<p>The <code>alive</code> property is a Boolean flag that’s initially set to <code>true</code>. When a bird collides with a pipe, this property is set to <code>false</code>. Only birds that are still alive are updated and drawn to the canvas.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  // There’s now an array of birds!\n  for (let bird of birds) {\n    //{!1} Operate only on the birds that are still alive.\n    if (bird.alive) {\n      // Make a decision based on the pipes.\n      bird.think(pipes);\n      // Update and show the bird.\n      bird.update();\n      bird.show();\n      //{!4} Has the bird hit a pipe? If so, it’s no longer alive.\n      for (let pipe of pipes) {  \n        if (pipe.collides(bird)) {\n          bird.alive = false;\n        }\n      }\n    }\n  }\n}</pre>\n<p>In <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>, I demonstrated two techniques for running an evolutionary simulation. In the smart rockets example, the population lived for a fixed amount of time each generation. The same approach could likely work here as well, but I want to allow the birds to accumulate the highest fitness value possible and not arbitrarily stop them based on a time limit. The second technique, demonstrated with the bloops example, eliminated the fitness score entirely and set a random probability for cloning any living creature. For <em>Flappy Bird</em>, this approach could become messy and risks overpopulation or all the birds dying out completely.</p>\n<p>I propose combining elements of both approaches. I’ll allow a generation to continue as long as at least one bird is still alive. When all the birds have died, I’ll select parents for the reproduction step and start anew. I’ll begin by writing a function to check whether all the birds have died:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function allBirdsDead() {\n  for (let bird of birds) {\n    //{!3} If a single bird is alive, they are not all dead!\n    if (bird.alive) {\n      return false;\n    }\n  }\n  //{!1} If the loop completes without finding a living bird, all the birds are dead.\n  return true;\n}</pre>\n<p>When all the birds have died, it’s time for selection! In the previous GA examples, I demonstrated a relay-race technique for giving a fair shot to all members of a population, while still increasing the chances of selection for those with higher fitness scores. I’ll use that same <code>weightedSelection()</code> function here:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} See Chapter 9 for a detailed explanation of this algorithm.\nfunction weightedSelection() {\n  let index = 0;\n  let start = random(1);\n  while (start > 0) {\n    start = start - birds[index].fitness;\n    index++;\n  }\n  index--;\n  //{!1} Instead of returning the entire <code>Bird</code> object, just the brain is returned.\n  return birds[index].brain;\n}</pre>\n<p>For this algorithm to function properly, I need to first normalize the fitness values of the birds so that they collectively add up to 1:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function normalizeFitness() {\n  // Sum the total fitness of all birds.\n  let sum = 0;\n  for (let bird of birds) {\n    sum += bird.fitness;\n  }\n  //{!3} Divide each bird’s fitness by the sum.\n  for (let bird of birds) {\n    bird.fitness = bird.fitness / sum;\n  }\n}</pre>\n<p>Once normalized, each bird’s fitness is equal to its probability of being selected.</p>\n<h3 id=\"heredity-baby-birds\">Heredity: Baby Birds</h3>\n<p>Only one step is left in the GA—reproduction. In <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>, I explored in great detail the two-step process for generating a child element: crossover and mutation. Crossover is where the third key principle of <strong>heredity</strong> arrives: the DNA from the two selected parents is combined to form the<br>child’s DNA.</p>\n<p>At first glance, the idea of inventing a crossover algorithm for two neural networks might seem daunting, and yet it’s quite straightforward. Think of the individual “genes” of a bird’s brain as the weights within the neural network. Mixing two such brains boils down to creating a new neural network with each weight chosen by a virtual coin flip—the weight comes from either the first or the second parent:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Pick two parents and create a child with crossover.\nlet parentA = weightedSelection();\nlet parentB = weightedSelection();\nlet child = parentA.crossover(parentB);</pre>\n<p>Wow, today’s my lucky day! It turns out ml5.js includes a <code>crossover()</code> method that manages the algorithm for mixing the two neural networks. I can happily move on to the mutation step:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Mutate the child.\nchild.mutate(0.01);</pre>\n<p>My luck continues! The ml5.js library also provides a <code>mutate()</code> method that accepts a mutation rate as its primary argument. The rate determines how often a weight will be altered. For example, a rate of 0.01 indicates a 1 percent chance that any given weight will mutate. During mutation, ml5.js adjusts the weight slightly by adding a small random number to it, rather than selecting a completely new random value. This behavior mimics real-world genetic mutations, which typically introduce minor changes rather than entirely new traits. Although this default approach works for many cases, ml5.js offers more control over the process by allowing the use of a custom mutation function as an optional second argument to <code>mutate()</code>.</p>\n<p>The crossover and mutation steps need to be repeated for the size of the population to create an entirely new generation of birds. This is accomplished by populating an empty local array <code>nextBirds</code> with the new birds. Once the population is full, the global <code>birds</code> array is then updated to this fresh generation:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function reproduction() {\n  //{!1} Start with a new empty array.\n  let nextBirds = [];\n  for (let i = 0; i &#x3C; populationSize; i++) {\n    // Pick two parents.\n    let parentA = weightedSelection();\n    let parentB = weightedSelection();\n    // Create a child with crossover.\n    let child = parentA.crossover(parentB);\n    // Apply mutation.\n    child.mutate(0.01);\n    //{!1} Create the new bird object.\n    nextBirds[i] = new Bird(child);\n  }\n  //{!1} The next generation is now the current one!\n  birds = nextBirds;\n}</pre>\n<p>If you look closely at the <code>reproduction()</code> function, you may notice that I’ve slipped in another new feature of the <code>Bird</code> class: an argument to the constructor. When I first introduced the idea of a bird brain, each new <code>Bird</code> object was created with a brand-new brain—a fresh neural network courtesy of ml5.js. However, I now want the new birds to <em>inherit</em> a child brain that was generated through the processes of crossover and mutation. To make this possible, I’ll subtly change the <code>Bird</code> constructor to look for an optional argument named, of course, <code>brain</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  constructor(brain) {\n    //{!1} Check whether a brain was passed in.\n    if (brain) {\n      this.brain = brain;\n    //{!1} If not, make a new one.\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 4,\n        outputs: [\"flap\", \"no flap\"],\n        task: \"classification\",\n        neuroEvolution: true,\n      });\n    }\n  }</pre>\n<p>If no <code>brain</code> is provided when a new bird is created, the <code>brain</code> argument remains <code>undefined</code>. In JavaScript, <code>undefined</code> is treated as <code>false</code>. The <code>if (brain)</code> test will therefore fail, so the code will move on to the <code>else</code> statement and call <code>ml5.neuralNetwork()</code>. On the other hand, if an existing neural network is passed in, <code>brain</code> evaluates to <code>true</code> and is assigned directly to <code>this.brain</code>. This elegant trick allows a single constructor to handle multiple scenarios.</p>\n<p>With that, the example is complete. All that’s left to do is call <code>normalizeFitness()</code> and <code>reproduction()</code> in <code>draw()</code> at the end of each generation, when all the birds have died out.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-112-flappy-bird-with-neuroevolution\">Example 11.2: Flappy Bird with Neuroevolution</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/PEUKc5dpZ\" data-example-path=\"examples/11_nn_ga/11_2_flappy_bird_neuro_evolution\"><img src=\"/content/examples/11_nn_ga/11_2_flappy_bird_neuro_evolution/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  /* All the rest of draw */\n\n  //{!4} Create the next generation when all the birds have died.\n  if (allBirdsDead()) {\n    normalizeFitness();\n    reproduction();\n    resetPipes();\n  }\n}\n\nfunction resetPipes() {\n  // Remove all the pipes but the very latest one.\n  pipes.splice(0, pipes.length - 1);\n}</pre>\n<p>Note the addition of a new <code>resetPipes()</code> function. If I don’t remove the pipes before starting a new generation, the birds may immediately restart at a position colliding with a pipe, in which case even the best bird won’t have a chance to fly! The full online code for Example 11.2 also adjusts the behavior of the birds so that they die when they leave the canvas, either by crashing into the ground or soaring too high above the top.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-112\">Exercise 11.2</h3>\n  <p>It takes a very long time for Example 11.2 to produce any results. Could you “speed up time” by skipping the drawing of every single frame of the game to reach an optimal bird faster? (A solution is presented in <a href=\"#speeding-up-time\" class=\"page-reference\">“Speeding Up Time”</a>.) Additionally, could you add an overlay that displays information about the simulation’s status, such as the number of birds still in play, the current generation, and the life span of the best bird?</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-113\">Exercise 11.3</h3>\n  <p>To avoid starting the neuroevolution process from scratch every time, try using ml5.js’s neural network <code>save()</code> and <code>load()</code> methods. How might you add a feature that saves the best bird model as well as an option to load a previously saved model?</p>\n</div>\n<h2 id=\"steering-the-neuroevolutionary-way\">Steering the Neuroevolutionary Way</h2>\n<p>Having explored neuroevolution with <em>Flappy Bird</em>, I’d like to shift the focus back to the realm of simulation, specifically the steering agents introduced in <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a>. What if, instead of me dictating the rules for an algorithm to calculate a steering force, a simulated creature could evolve its own strategy? Drawing inspiration from Reynolds’s aim of lifelike and improvisational behaviors, my goal isn’t to use neuroevolution to engineer the perfect creature that can flawlessly execute a task. Instead, I hope to create a captivating world of simulated life, where the quirks, nuances, and happy accidents of evolution unfold in the canvas.</p>\n<p>I’ll begin by adapting the smart rockets example from <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>. In that example, the genes for each rocket were an array of vectors:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.genes = [];\nfor (let i = 0; i &#x3C; lifeSpan; i++) {\n  //{!2} Each gene is a vector with random direction and magnitude.\n  this.genes[i] = p5.Vector.random2D();\n  this.genes[i].mult(random(0, this.maxforce));\n}</pre>\n<p>I propose adapting this code to instead use a neural network to predict the vector or steering force, transforming the <code>genes</code> into a <code>brain</code>. Vectors can have a continuous range of values, so this is a regression task:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.brain = ml5.neuralNetwork({\n  inputs: 2,\n  outputs: 2,\n  task: \"regression\",\n  neuroEvolution: true,\n});</pre>\n<p>In the original example, the vectors from the <code>genes</code> array were applied sequentially, querying the array with a <code>counter</code> variable:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">this.applyForce(this.genes[this.counter]);</pre>\n<p>Now, instead of an array lookup, I want the neural network to return a new vector for each frame of the animation. For regression tasks with ml5.js, the output of the neural network is received from the <code>predict()</code> method rather than <code>classify()</code>. And here, I’ll use the <code>predictSync()</code> variant to keep the code simple and allow for synchronous output data from the model in the rocket’s <code>run()</code> method:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">run() {\n  // Get the outputs from the neural network.\n  let outputs = this.brain.predictSync(inputs);\n  // Use one output for an angle.\n  let angle = outputs[0].value * TWO_PI;\n  // Use another output for the magnitude.\n  let magnitude = outputs[1].value * this.maxforce;\n  // Create and apply the force.\n  let force = p5.Vector.fromAngle(angle)\n  force.setMag(magnitude);\n  this.applyForce(force);\n}</pre>\n<p>The neural network brain outputs two values: one for the angle of the vector and one for the magnitude. You might think to instead use these outputs for the vector’s x- and y-components. The default output range for an ml5.js neural network is from 0 to 1, however, and I want the forces to be capable of pointing in both positive and negative directions. Mapping the first output to an angle by multiplying it by <code>TWO_PI</code> offers the full range.</p>\n<p>You may have noticed that the code includes a variable called <code>inputs</code> that I have yet to declare or initialize. Defining the inputs to the neural network is where you, as the designer of the system, can be the most creative. You have to consider the nature of the environment and the simulated biology and capabilities of your creatures, and then decide which features are most important.</p>\n<p>As a first try, I’ll assign something basic for the inputs and see if it works. Since the smart rockets’ environment is static, with fixed obstacles and targets, what if the brain could learn and estimate a flow field to navigate toward its goal? As I demonstrated in <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a>, a flow field receives a position and returns a vector, so the neural network can mirror this functionality and use the rocket’s current x- and y-position as input. I just have to normalize the values according to the canvas dimensions:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let inputs = [this.position.x / width, this.position.y / height];</pre>\n<p>That’s it! Virtually everything else from the original example can remain unchanged: the population, the fitness function, and the selection process.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-113-smart-rockets-with-neuroevolution\">Example 11.3: Smart Rockets with Neuroevolution</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/KkV4lTS4H\" data-example-path=\"examples/11_nn_ga/11_3_smart_rockets_neuro_evolution\"><img src=\"/content/examples/11_nn_ga/11_3_smart_rockets_neuro_evolution/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  reproduction() {\n    let nextPopulation = [];\n    // Create the next population.\n    for (let i = 0; i &#x3C; this.population.length; i++) {\n      // Spin the wheel of fortune to pick two parents.\n      let parentA = this.weightedSelection();\n      let parentB = this.weightedSelection();\n      let child = parentA.crossover(parentB);\n      //{!1} Apply mutation.\n      child.mutate(this.mutationRate);\n      nextPopulation[i] = new Rocket(320, 220, child);\n    }\n    //{!1} Replace the old population.\n    this.population = nextPopulation;\n    this.generations++;\n  }</pre>\n<p>Now that I’m using ml5.js, notice that I no longer need a separate <code>DNA</code> class with implementations of <code>crossover()</code> and <code>mutate()</code>. Instead, those methods are built into <code>ml5.neuralNetwork</code> and can be called directly.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-114\">Exercise 11.4</h3>\n  <p>A steering force, as defined by Reynolds, is the difference between an agent’s desired velocity and its current velocity. How might this evolutionary system mirror that methodology? Instead of using only the position as an input to the neural network, what if you feed in the rocket’s current velocity? You could try using the x- and y-components or the direction and magnitude of the vector. Remember to normalize these values!</p>\n</div>\n<h3 id=\"responding-to-change\">Responding to Change</h3>\n<p>In the previous example, the environment was static, with a stationary target and obstacle. This made the rocket’s task of finding the target easy to accomplish using only its position as input. However, what if the target and the obstacles in the rocket’s path were moving? To handle a more complex and changing environment, I need to expand the neural network’s inputs and consider additional features of the environment. This is similar to what I did with <em>Flappy Bird</em>, as I identified the key data points of the environment to guide the bird’s decision-making process.</p>\n<p>I’ll begin with the simplest version of this scenario, almost identical to the original smart rockets example, but removing obstacles and replacing the fixed target with a random walker controlled by Perlin noise. In this world, I’ll rename the <code>Rocket</code> to <code>Creature</code> and recast the walker as a <code>Glow</code> class that represents a gentle, drifting orb. Imagine that the creature’s goal is to reach the light source and dance in its radiant embrace as long as it can:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Glow {\n  constructor() {\n    //{!2} Two Perlin noise offsets\n    this.xoff = 0;\n    this.yoff = 1000;\n    this.position = createVector();\n    this.r = 24;\n  }\n\n  update() {\n    //{!2} Assign the position according to the Perlin noise.\n    this.position.x = noise(this.xoff) * width;\n    this.position.y = noise(this.yoff) * height;\n    //{!2} Move along the Perlin noise space.\n    this.xoff += 0.01;\n    this.yoff += 0.01;\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(200);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}</pre>\n<p>As the glow moves, the creature should take the glow’s position into account in its decision-making process, as an input to its brain. However, it isn’t sufficient to know only the light’s position; it’s the position relative to the creature’s own that’s key. A nice way to synthesize this information as an input feature is to calculate a vector that points from the creature to the glow. Essentially, I’m reinventing the <code>seek()</code> method from <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a>, using a neural network to estimate the steering force:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  seek(target) {\n    //{!1} Calculate a vector from the position to the target.\n    let v = p5.Vector.sub(target.position, this.position);</pre>\n</div>\n<p>This is a good start, but the components of the vector don’t fall within a normalized input range. I could divide <code>v.x</code> by <code>width</code> and <code>v.y</code> by <code>height</code>, but since my canvas isn’t a perfect square, this may skew the data. Another solution is to normalize the vector, but while this would retain information about the direction from the creature to the glow, it would eliminate any measure of the distance. This won’t do either—if the creature is sitting on top of the glow, it should steer differently than if it were very far away. As a solution, I’ll save the distance in a separate variable before normalizing the vector. For it to work as an input feature, though, I still have to normalize the range. While not a perfect normalization from 0 to 1, I’ll divide it by the canvas width, which will provide a practical normalization that retains the relative magnitude:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    // Save the distance in a variable and normalize according to width (one input).\n    let distance = v.mag() / width;\n    // Normalize the vector pointing from the position to the target (two inputs).\n    v.normalize();</pre>\n</div>\n<p>As you may recall, a key element of Reynolds’s steering formula involved comparing the desired velocity to the current velocity. How the vehicle is currently moving plays a significant role in how it should steer! For the creature to consider its own velocity as part of its decision-making, I can include the velocity vector in the inputs to the neural network as well. To normalize these values, dividing the vector’s components by the <code>maxspeed</code> property works beautifully. This retains both the direction and relative magnitude of the vector. The rest of the <code>seek()</code> method follows the same logic as the previous example, with the outputs of the neural network synthesized into a force to be applied to the creature:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    let distance = v.mag() / width;\n    v.normalize();\n    // Compile the features into an input array.\n    let inputs = [\n      v.x,\n      v.y,\n      distance,\n      this.velocity.x / this.maxspeed,\n      this.velocity.y / this.maxspeed,\n    ];\n    //{!5} Predict the force to apply.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let force = p5.Vector.fromAngle(angle);\n    let magnitude = outputs[1].value;\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }</pre>\n<p>Enough has changed in the transition from rockets to creatures that it’s also worth reconsidering the fitness function. Previously, fitness was calculated based on the rocket’s <em>record</em> distance from the target at the end of each generation. Since the target is now moving, I’d prefer to accumulate the amount of time the creature is able to catch the glow as the measure of fitness. This can be achieved by checking the distance between the creature and the glow in the <code>update()</code> method and incrementing a <code>fitness</code> value when they’re intersecting:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  update(target) {\n    /* The usual updating of position, velocity, acceleration */\n\n    //{!4} Increase the fitness whenever the creature reaches the glow.\n    let d = p5.Vector.dist(this.position, target.position);\n    if (d &#x3C; this.r + target.r) {\n      this.fitness++;\n    }\n  }</pre>\n<p>Both the <code>Glow</code> and <code>Creature</code> classes include a radius property <code>r</code>, which I’m using to determine intersection.</p>\n<h3 id=\"speeding-up-time\">Speeding Up Time</h3>\n<p>One thing you may have noticed about evolutionary computing is that testing the code is a delightful exercise in patience. You have to watch the slow crawl of the simulation play out generation after generation. This is part of the point—I <em>want</em> to watch the process! It’s also a nice excuse to take a break, which is to be encouraged. Head outside and enjoy some nonsimulated nature for a while, or perhaps a soothing cup of tea. Then check back in on your creatures and see how they’re progressing. Take comfort in having to wait only billions of milliseconds rather than the billions of years required for actual biological evolution.</p>\n<p>Nevertheless, for the system to evolve, there’s no inherent requirement that you draw and animate the world. Hundreds of generations could be completed in the blink of an eye if you could skip all the time spent rendering the scene. Or, rather than not render the environment at all, you could choose to simply render it <em>less often</em>. This will save you from tearing your hair out every time you change a small parameter and find yourself waiting what seems like hours to see whether it had any effect on the system’s evolution.</p>\n<p>Here’s where I can use one of my favorite features of p5.js: the ability to quickly create standard interface elements. You saw this before in Example 9.4 with <code>createButton()</code>. This time I’ll create a slider to control the number of iterations of a <code>for</code> loop that runs inside <code>draw()</code>. The <code>for</code> loop will contain the code for updating (but not drawing) the simulation. The more times the loop repeats, the faster the animation will seem.</p>\n<p>Here’s the code for this new time slider, excluding all the other global variables and their initializations in <code>setup()</code>. Notice that the code for the visuals is separated from the code for the physics to ensure that rendering still occurs only once per <code>draw()</code> cycle:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} A variable to hold the slider\nlet timeSlider;\n\nfunction setup() {\n  //{!1} Create a slider with a min and max range, and a starting value.\n  timeSlider = createSlider(1, 20, 1);\n}\n\nfunction draw() {\n  //{!5} The drawing code happens just once!\n  background(255);\n  glow.show();\n  for (let creature of creatures) {\n    creature.show();\n  }\n  //{!8} The simulation code runs multiple times according to the slider.\n  for (let i = 0; i &#x3C; timeSlider.value(); i++) {\n    for (let creature of creatures) {\n      creature.seek(glow);\n      creature.update(glow);\n    }\n    glow.update();\n    lifeCounter++;\n  }\n}</pre>\n<p>In p5.js, a slider is defined with three arguments: a minimum value (for when the slider is all the way to the left), a maximum value (for when it’s all the way to the right), and a starting value (for when the page first loads). In this case, the slider allows you to run the simulation at 20x speed to reach the results of evolution more quickly, then slow it back down to 1x speed to bask in the glory of the intelligent behaviors on display.</p>\n<p>Here’s the final version of the example with a new <code>Creature</code> constructor to create a neural network. Everything else related to applying the steps of the GA has remained the same from the <em>Flappy Bird</em> example code.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-114-dynamic-neuroevolutionary-steering\">Example 11.4: Dynamic Neuroevolutionary Steering</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/fZDfxxVrf\" data-example-path=\"examples/11_nn_ga/11_4_neuro_evolution_steering_seek\"><img src=\"/content/examples/11_nn_ga/11_4_neuro_evolution_steering_seek/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Creature {\n  constructor(x, y, brain) {\n    this.position = createVector(x, y);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n    this.r = 4;\n    this.maxspeed = 4;\n    this.fitness = 0;\n\n    if (brain) {\n      this.brain = brain;\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 5,\n        outputs: 2,\n        task: \"regression\",\n        neuroEvolution: true,\n      });\n    }\n  }\n  \n  /* <code>seek()</code> predicts a steering force as described previously. */\n\n  /* <code>update()</code> increments the fitness if the glow is reached as described previously. */\n\n}</pre>\n<p>It’s hard to believe, but this book has been a journey well over 10 years in the making. Thank you, dear reader, for sticking with it. I promise it’s not an infinite loop. However meandering it might have seemed, like a random walk, I’m finally using an arrival steering behavior to reach the final piece of the puzzle, an attempt to bring together all my past explorations in my own version of the Ecosystem Project.</p>\n<h2 id=\"a-neuroevolutionary-ecosystem\">A Neuroevolutionary Ecosystem</h2>\n<p>A few elements in this chapter’s examples don’t quite fit with my dream of simulating a natural ecosystem. The first goes back to an issue I raised in <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a> with the introduction of the bloops. A system of creatures that all live and die together, starting completely over with each subsequent generation—that isn’t how the biological world works! I’d like to revisit this dilemma in this chapter’s context of neuroevolution.</p>\n<p>Second, and perhaps more important, a major flaw exists in the way I’m extracting features from a scene to train a model. The creatures in Example 11.4 are all-knowing. Sure, it’s reasonable to assume that a creature is aware of its own current velocity, but I’ve also allowed each creature to know the glow’s exact location, regardless of how far away it is or what might be blocking the creature’s vision or senses. This is a bridge too far. It flies in the face of one of the main tenets of autonomous agents I introduced in <a href=\"/autonomous-agents#section-autonomous-agents\">Chapter 5</a>: an agent should have a <em>limited</em> ability to perceive its environment.</p>\n<h3 id=\"sensing-the-environment\">Sensing the Environment</h3>\n<p>A common approach to simulating how a real-world creature (or robot) would have a limited awareness of its surroundings is to attach <strong>sensors</strong> to an agent. Think back to that mouse in the maze from the beginning of the chapter (hopefully it’s been thriving on the cheese it’s been getting as a reward), and now imagine it has to navigate the maze in the dark. Its whiskers might act as proximity sensors to detect walls and turns. The mouse whiskers can’t see the entire maze, but only sense the immediate surroundings. Another example of sensors is a bat using echolocation to navigate, or a car on a winding road where the driver can see only what’s projected in front of the car’s headlights.</p>\n<p>I’d like to build on this idea of the whiskers (or more formally the <em>vibrissae</em>) found in mice, cats, and other mammals. In the real world, animals use their vibrissae to navigate and detect nearby objects, especially in dark or obscured environments (see Figure 11.5). How can I attach whisker-like sensors to my neuroevolutionary-seeking creatures?</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_7.png\" alt=\"Figure 11.5: Clawdius the cat sensing his environment with his vibrissae\">\n  <figcaption>Figure 11.5: Clawdius the cat sensing his environment with his vibrissae</figcaption>\n</figure>\n<p>I’ll keep the generic class name <code>Creature</code> but think of them now as the amoeba-like bloops from <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>, enhanced with whisker-like sensors that emanate from their center in all directions:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Creature {\n  constructor(x, y) {\n    // The creature has a position and radius.\n    this.position = createVector(x, y);\n    this.r = 16;\n    // The creature has an array of sensors.\n    this.sensors = [];\n    // The creature has eight sensors.\n    let totalSensors = 8;\n    for (let i = 0; i &#x3C; totalSensors; i++) {\n      // First, calculate a direction for the sensor.\n      let angle = map(i, 0, totalSensors, 0, TWO_PI);\n      // Create a vector a little bit longer than the radius as the sensor.\n      this.sensors[i] = p5.Vector.fromAngle(angle);\n      this.sensors[i].setMag(this.r * 1.5);\n    }\n  }\n}</pre>\n<p>The code creates a series of vectors, each describing the direction and length of one whisker sensor attached to the creature. However, just the vector isn’t enough. I want the sensor to include a <code>value</code>, a numeric representation of what it’s sensing. This <code>value</code> can be thought of as analogous to the intensity of touch. Just as Clawdius the cat’s whiskers might detect a faint touch from a distant object or a stronger push from a closer one, the virtual sensor’s value could range to represent proximity.</p>\n<p>Before I go any further, I need to give the creatures something to sense. How about a <code>Food</code> class to describe a circle of deliciousness that the creature wants to find? Each <code>Food</code> object will have a position and a radius:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Food {\n  //{!4} A piece of food has a random position and a fixed radius.\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.r = 50;\n  }\n\n  show() {\n    noStroke();\n    fill(0, 100);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}</pre>\n<p>How can I determine if a creature’s sensor is touching the food? One approach could be to use <strong>raycasting</strong>. This technique is commonly employed in computer graphics to project straight lines (often representing beams of light) from an origin point in a scene to determine which objects they intersect with. Raycasting is useful for visibility and collision checks, exactly what I’m doing here!</p>\n<p>While raycasting would provide a robust solution, it requires more mathematics than I’d like to delve into here. For those interested, <a href=\"https://thecodingtrain.com/raycasting\">an explanation and implementation are available in Coding Challenge #145 on the Coding Train website</a>. For this example, I’ll opt for a more straightforward approach and check whether the endpoint of a sensor lies inside the food circle (see Figure 11.6).</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_8.png\" alt=\"Figure 11.6: The endpoint of a sensor is inside or outside the food, based on its distance to the center of the food.\">\n  <figcaption>Figure 11.6: The endpoint of a sensor is inside or outside the food, based on its distance to the center of the food.</figcaption>\n</figure>\n<p>Because I want the sensor to store a value for its sensing along with the sensing algorithm, encapsulating these elements into a <code>Sensor</code> class makes sense:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Sensor {\n  constructor(v) {\n    this.v = v.copy();\n    //{!1} The sensor also stores a value for the proximity of what it’s sensing.\n    this.value = 0;\n  }\n  \n  sense(position, food) {\n    //{!1} Find the tip (or endpoint) of the sensor by adding the creature’s position.\n    let end = p5.Vector.add(position, this.v);\n    //{!1} How far is it from the food’s center?\n    let d = end.dist(food.position);\n    //{!1} If the sensor is within the radius, light up the sensor.  \n    if (d &#x3C; food.r) {\n      //{!1} The farther into the center of the food, the more the sensor activates.\n      this.value = map(d, 0, food.r, 1, 0);\n    } else {\n      this.value = 0;\n    }\n  }\n}</pre>\n<p>Notice that the sensing mechanism gauges the endpoint’s depth within the food’s radius by using the <code>map()</code> function. When the sensor’s endpoint is just touching the outer boundary of the food, <code>value</code> starts at 0. As the endpoint moves closer to the center of the food, <code>value</code> increases, maxing out at 1. If the sensor isn’t touching the food at all, <code>value</code> remains at 0. This gradient of feedback mirrors the varying intensity of touch or pressure in the real world.</p>\n<p>Let’s test out this sensor mechanism with a simple example: one bloop (controlled by the mouse) and one piece of food (placed at the center of the canvas). When the sensors touch the food, they light up, and they get brighter as they get closer to the center of the food.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-115-a-bloop-with-sensors\">Example 11.5: A Bloop with Sensors</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/vCTMtXXSS\" data-example-path=\"examples/11_nn_ga/11_5_creature_sensors\"><img src=\"/content/examples/11_nn_ga/11_5_creature_sensors/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bloop, food;\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} One bloop, one piece of food\n  bloop = new Creature();\n  food = new Food();\n}\n\nfunction draw() {\n  background(255);\n  // Temporarily control the bloop with the mouse.\n  bloop.position.x = mouseX;\n  bloop.position.y = mouseY;\n  // Draw the food and the bloop.\n  food.show();\n  bloop.show();\n  // The bloop senses the food.\n  bloop.sense(food);\n}\n\nclass Creature {\n  constructor(x, y) {\n    this.position = createVector(x, y);\n    this.r = 16;\n\n    //{!8} Create the sensors for the creature.\n    this.sensors = [];\n    // Let’s use more sensors! How about 15?\n    let totalSensors = 15;\n    for (let i = 0; i &#x3C; totalSensors; i++) {\n      let a = map(i, 0, totalSensors, 0, TWO_PI);\n      let v = p5.Vector.fromAngle(a);\n      v.mult(this.r * 2);\n      this.sensors[i] = new Sensor(v);\n    }\n  }\n\n  //{!4} Call the <code>sense()</code> method for each sensor.\n  sense(food) {\n    for (let sensor of this.sensors) {\n      sensor.sense(this.position, food);\n    }\n  }\n\n  // Draw the creature and all the sensors.\n  show() {\n    push();\n    translate(this.position.x, this.position.y);\n    for (let sensor of this.sensors) {\n      stroke(0);\n      line(0, 0, sensor.v.x, sensor.v.y);\n      if (sensor.value > 0) {\n        fill(255, sensor.value * 255);\n        stroke(0, 100)\n        circle(sensor.v.x, sensor.v.y, 8);\n      }\n    }\n    noStroke();\n    fill(0);\n    circle(0, 0, this.r * 2);\n    pop();\n  }\n}</pre>\n<p>In the example, the creature’s sensors are drawn as lines from its center. When a sensor detects something (when <code>value</code> is greater than 0), a circle appears. To visualize the strength of the sensor reading, I use <code>value</code> to set its transparency.</p>\n<h3 id=\"learning-from-the-sensors\">Learning from the Sensors</h3>\n<p>Are you thinking what I’m thinking? What if the values of a creature’s sensors are the inputs to a neural network? Assuming I give the creatures control of their own movements again, I could write a new <code>think()</code> method that processes the sensor values through the neural network brain and outputs a steering force, just as in the last two steering examples:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  think() {\n    // Build an input array from the sensor values.\n    let inputs = [];\n    for (let i = 0; i &#x3C; this.sensors.length; i++) {\n      inputs[i] = this.sensors[i].value;\n    }\n    // Predict a steering force from the sensors.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let magnitude = outputs[1].value;\n    let force = p5.Vector.fromAngle(angle)\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }</pre>\n<p>The logical next step might be to incorporate all the usual parts of the GA, writing a fitness function (how much food did each creature eat?) and performing selection after a fixed generational time period. But this is a great opportunity to revisit the principles of a continuous ecosystem and aim for a more sophisticated environment and set of potential behaviors for the creatures themselves. Instead of a fixed life span cycle for each generation, I’ll bring back <a href=\"/genetic-algorithms#section-genetic-algorithms\">Chapter 9</a>’s <code>health</code> score for each creature. For every cycle through <code>draw()</code> that a creature lives, its health deteriorates a little bit:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">class Creature {  \n  constructor() {\n    /* All of the creature's properties */\n    // The health starts at 100.\n    this.health = 100;\n  } \n\n  update() {\n    /* The usual updating position, velocity, acceleration */\n    // Lose some health!\n    this.health -= 0.25;\n  }</pre>\n</div>\n<p>In <code>draw()</code>, if any bloop’s health drops below 0, that bloop dies and is deleted from the <code>bloops</code> array. And for reproduction, instead of performing the usual crossover and mutation all at once, each bloop (with a health greater than 0) will have a 0.1 percent chance of reproducing:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  function draw() {\n    for (let i = bloops.length - 1; i >= 0; i--) {\n      if (bloops[i].health &#x3C; 0) {\n        bloops.splice(i, 1);\n      } else if (random(1) &#x3C; 0.001) {\n        let child = bloops[i].reproduce();\n        bloops.push(child);\n      }\n    }\n  }</pre>\n<p>In <code>reproduce()</code>, I’ll use the <code>copy()</code> method (cloning) instead of the <code>crossover()</code> method (mating), with a higher-than-usual mutation rate to help introduce variation. (I encourage you to consider ways to incorporate crossover instead.) Here’s the code:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  reproduce() {\n    //{!2} Copy and mutate rather than use crossover and mutate.\n    let brain = this.brain.copy();\n    brain.mutate(0.1);\n    return new Creature(this.position.x, this.position.y, brain);\n  }</pre>\n<p>For this to work, some bloops should live longer than others. By consuming food, their health increases, giving them extra time to reproduce. I’ll manage this in an <code>eat()</code> method of the <code>Creature</code> class:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  eat(food) {\n    // If the bloop is close to the food, increase its health!\n    let d = p5.Vector.dist(this.position, food.position);\n    if (d &#x3C; this.r + food.r) {\n      this.health += 0.5;\n    }\n  }</pre>\n<p>Is this enough for the system to evolve and find its equilibrium? I could dive deeper, tweaking parameters and behaviors in pursuit of the ultimate evolutionary system. The allure of this infinite rabbit hole is one I cannot easily escape, but I’ll explore it on my own time. For the purpose of this book, I invite you to run the example, experiment, and draw your own conclusions.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-116-a-neuroevolutionary-ecosystem\">Example 11.6: A Neuroevolutionary Ecosystem</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/IQbcREjUK\" data-example-path=\"examples/11_nn_ga/11_6_neuroevolution_ecosystem\"><img src=\"/content/examples/11_nn_ga/11_6_neuroevolution_ecosystem/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let bloops = [];\nlet food = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i &#x3C; 20; i++) {\n    bloops[i] = new Creature(random(width), random(height));\n  }\n  for (let i = 0; i &#x3C; 8; i++) {\n    food[i] = new Food();\n  }\n}\n\nfunction draw() {\n  background(255);\n  for (let i = bloops.length - 1; i >= 0; i--) {\n    bloops[i].think();\n    bloops[i].eat();\n    bloops[i].update();\n    bloops[i].borders();\n    if (bloops[i].health &#x3C; 0) {\n      bloops.splice(i, 1);\n    } else if (random(1) &#x3C; 0.001) {\n      let child = bloops[i].reproduce();\n      bloops.push(child);\n    }\n  }\n  for (let treat of food) {\n    treat.show();\n  }\n  for (let bloop of bloops) {\n    bloop.show();\n  }\n}</pre>\n<p>The final example also includes a few additional features that you’ll find in the accompanying online code, such as an array of food that shrinks as it gets eaten (respawning when it’s depleted). Additionally, the bloops shrink as their health deteriorates.</p>\n<div data-type=\"project\">\n  <h3 id=\"the-ecosystem-project-12\">The Ecosystem Project</h3>\n  <p>Try incorporating the concept of a brain into the creatures in your world!</p>\n  <ul>\n    <li>Can different creatures have different goals and incentives? Are some searching for food while others seek different resources? What about creatures avoiding dangers like predators or poisons?</li>\n    <li>What are each creature’s inputs and outputs?</li>\n    <li>How do the creatures perceive? Do they see everything or have limits based on sensors?</li>\n    <li>What strategies can you employ to establish and maintain balance in your ecosystem?</li>\n  </ul>\n  <figure>\n    <img src=\"/content/images/11_nn_ga/11_nn_ga_9.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<h2 id=\"the-end\">The End</h2>\n<p>If you’re still reading, thank you! You’ve reached the end of the book. But for as much material as this book contains, I’ve barely scratched the surface of the physical world we inhabit and of techniques for simulating it. I intend for this book to live as an ongoing project, and I hope to continue adding new tutorials and examples to the book’s website, as well as expand and update the accompanying video tutorials at the Coding Train website.</p>\n<p>Your feedback is truly appreciated, so please get in touch via email at <em>daniel@shiffman.net</em> or by <a href=\"https://github.com/nature-of-code\">contributing to the GitHub repository</a>, in keeping with the open source spirit of the project. Share your work. Stay in touch. Let’s be two with nature.</p>\n<figure>\n  <img src=\"/content/images/11_nn_ga/11_nn_ga_10.png\" alt>\n  <figcaption></figcaption>\n</figure>\n</section>",
  "codeBlocks": [
    {
      "id": "code-0",
      "language": "javascript",
      "code": "let options = {\n  inputs: 5,\n  outputs: [\"flap\", \"no flap\"],\n  task: \"classification\"\n};\nlet birdBrain = ml5.neuralNetwork(options);",
      "lineNumbers": true
    },
    {
      "id": "code-1",
      "language": "javascript",
      "code": "class Bird {\n  constructor() {\n    // The bird’s position (<code>x</code> will be constant)\n    this.x = 50\n    this.y = 120;\n    // Velocity and forces are scalar since the bird moves only along the y-axis.\n    this.velocity = 0;\n    this.gravity = 0.5;\n    this.flapForce = -10;\n  }\n\n  // The bird flaps its wings.\n  flap() {\n    this.velocity += this.flapForce;\n  }\n\n  update() {\n    // Add gravity.\n    this.velocity += this.gravity;\n    this.y += this.velocity;\n    // Dampen velocity.\n    this.velocity *= 0.95;\n    // Handle the floor.\n    if (this.y > height) {\n      this.y = height;\n      this.velocity = 0;\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-2",
      "language": "javascript",
      "code": "class Pipe {\n  constructor() {\n    // The size of the opening between the two parts of the pipe\n    this.spacing = 100;\n    // A random height for the top of the pipe\n    this.top = random(height - this.spacing);\n    // The starting position of the bottom pipe (based on the top)\n    this.bottom = this.top + this.spacing;\n    // The pipe starts at the edge of the canvas.\n    this.x = width;\n    // The width of the pipe\n    this.w = 20;\n    // The horizontal speed of the pipe\n    this.velocity = 2;\n  }\n\n  // Draw the two pipes.\n  show() {\n    fill(0);\n    noStroke();\n    rect(this.x, 0, this.w, this.top);\n    rect(this.x, this.bottom, this.w, height - this.bottom);\n  }\n\n  // Update the horizontal position.\n  update() {\n    this.x -= this.velocity;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-3",
      "language": "javascript",
      "code": "collides(bird) {\n    // Is the bird within the vertical range of the top or bottom pipe?\n    let verticalCollision = bird.y < this.top || bird.y > this.bottom;\n    // Is the bird within the horizontal range of the pipes?\n    let horizontalCollision = bird.x > this.x && bird.x < this.x + this.w;\n    //{!1} If it’s both a vertical and horizontal hit, it’s a hit!\n    return verticalCollision && horizontalCollision;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-4",
      "language": "javascript",
      "code": "let bird;\nlet pipes = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} Create a bird and start with one pipe.\n  bird = new Bird();\n  pipes.push(new Pipe());\n}\n\n//{!3} The bird flaps its wings when the mouse is clicked.\nfunction mousePressed() {\n  bird.flap();\n}\n\nfunction draw() {\n  background(255);\n  // Handle all the pipes.\n  for (let i = pipes.length - 1; i >= 0; i--) {\n    pipes[i].show();\n    pipes[i].update();\n    if (pipes[i].collides(bird)) {\n      text(\"OOPS!\", pipes[i].x, pipes[i].top + 20);\n    }\n    if (pipes[i].offscreen()) {\n      pipes.splice(i, 1);\n    }\n  }\n  // Update and show the bird.\n  bird.update();\n  bird.show();\n  //{!3} Add a new pipe every 100 frames.\n  if (frameCount % 100 === 0) {\n    pipes.push(new Pipe());\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-5",
      "language": "javascript",
      "code": "constructor() {\n    this.brain = ml5.neuralNetwork({\n      // A bird’s brain receives four inputs and classifies them into one of two labels.\n      inputs: 4,\n      outputs: [\"flap\", \"no flap\"],\n      task: \"classification\",\n      //{!1} A new property necessary to enable neuroevolution functionality\n      neuroEvolution: true\n    });\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-6",
      "language": "javascript",
      "code": "think(pipes) {\n    let nextPipe = null;\n    for (let pipe of pipes) {\n      //{!4} The next pipe is the one that hasn’t passed the bird yet.\n      if (pipe.x + pipe.w > this.x) {\n        nextPipe = pipe;\n        break;\n      }\n    }",
      "lineNumbers": true
    },
    {
      "id": "code-7",
      "language": "javascript",
      "code": "let inputs = [\n      // y-position of the bird\n      this.y,\n      // y-velocity of the bird\n      this.velocity,\n      // Top opening of the next pipe\n      nextPipe.top,\n      //{!1} Distance to the next pipe\n      nextPipe.x - this.x,\n    ];",
      "lineNumbers": true
    },
    {
      "id": "code-8",
      "language": "javascript",
      "code": "let inputs = [\n      //{!4} All the inputs are now normalized by width and height.\n      this.y / height,\n      this.velocity / height,\n      nextPipe.top / height,\n      (nextPipe.x - this.x) / width,\n    ];",
      "lineNumbers": true
    },
    {
      "id": "code-9",
      "language": "javascript",
      "code": "let results = this.brain.classifySync(inputs);\n    if (results[0].label === \"flap\") {\n      this.flap();\n    }\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-10",
      "language": "javascript",
      "code": "// Population size\nlet populationSize = 200;\n// Array of birds\nlet birds = [];\n\nfunction setup() {\n  //{!3} Create the bird population.\n  for (let i = 0; i < populationSize; i++) {\n    birds[i] = new Bird();\n  }\n  //{!1} Run the computations on the CPU for better performance.\n  ml5.setBackend(\"cpu\");\n}\n\nfunction draw() {\n  for (let bird of birds) {\n    //{!1} This is the new method for the bird to make a decision to flap or not.\n    bird.think(pipes);\n    bird.update();\n    bird.show();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-11",
      "language": "javascript",
      "code": "constructor() {\n    // The bird’s fitness\n    this.fitness = 0;\n    //{!1} Is the bird alive or not?\n    this.alive = true;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-12",
      "language": "javascript",
      "code": "update() {\n    //{!1} Increment the fitness each time through <code>update()</code>.\n    this.fitness++;\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-13",
      "language": "javascript",
      "code": "function draw() {\n  // There’s now an array of birds!\n  for (let bird of birds) {\n    //{!1} Operate only on the birds that are still alive.\n    if (bird.alive) {\n      // Make a decision based on the pipes.\n      bird.think(pipes);\n      // Update and show the bird.\n      bird.update();\n      bird.show();\n      //{!4} Has the bird hit a pipe? If so, it’s no longer alive.\n      for (let pipe of pipes) {  \n        if (pipe.collides(bird)) {\n          bird.alive = false;\n        }\n      }\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-14",
      "language": "javascript",
      "code": "function allBirdsDead() {\n  for (let bird of birds) {\n    //{!3} If a single bird is alive, they are not all dead!\n    if (bird.alive) {\n      return false;\n    }\n  }\n  //{!1} If the loop completes without finding a living bird, all the birds are dead.\n  return true;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-15",
      "language": "javascript",
      "code": "//{!1} See Chapter 9 for a detailed explanation of this algorithm.\nfunction weightedSelection() {\n  let index = 0;\n  let start = random(1);\n  while (start > 0) {\n    start = start - birds[index].fitness;\n    index++;\n  }\n  index--;\n  //{!1} Instead of returning the entire <code>Bird</code> object, just the brain is returned.\n  return birds[index].brain;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-16",
      "language": "javascript",
      "code": "function normalizeFitness() {\n  // Sum the total fitness of all birds.\n  let sum = 0;\n  for (let bird of birds) {\n    sum += bird.fitness;\n  }\n  //{!3} Divide each bird’s fitness by the sum.\n  for (let bird of birds) {\n    bird.fitness = bird.fitness / sum;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-17",
      "language": "javascript",
      "code": "// Pick two parents and create a child with crossover.\nlet parentA = weightedSelection();\nlet parentB = weightedSelection();\nlet child = parentA.crossover(parentB);",
      "lineNumbers": false
    },
    {
      "id": "code-18",
      "language": "javascript",
      "code": "// Mutate the child.\nchild.mutate(0.01);",
      "lineNumbers": false
    },
    {
      "id": "code-19",
      "language": "javascript",
      "code": "function reproduction() {\n  //{!1} Start with a new empty array.\n  let nextBirds = [];\n  for (let i = 0; i < populationSize; i++) {\n    // Pick two parents.\n    let parentA = weightedSelection();\n    let parentB = weightedSelection();\n    // Create a child with crossover.\n    let child = parentA.crossover(parentB);\n    // Apply mutation.\n    child.mutate(0.01);\n    //{!1} Create the new bird object.\n    nextBirds[i] = new Bird(child);\n  }\n  //{!1} The next generation is now the current one!\n  birds = nextBirds;\n}",
      "lineNumbers": true
    },
    {
      "id": "code-20",
      "language": "javascript",
      "code": "constructor(brain) {\n    //{!1} Check whether a brain was passed in.\n    if (brain) {\n      this.brain = brain;\n    //{!1} If not, make a new one.\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 4,\n        outputs: [\"flap\", \"no flap\"],\n        task: \"classification\",\n        neuroEvolution: true,\n      });\n    }\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-21",
      "language": "javascript",
      "code": "function draw() {\n  /* All the rest of draw */\n\n  //{!4} Create the next generation when all the birds have died.\n  if (allBirdsDead()) {\n    normalizeFitness();\n    reproduction();\n    resetPipes();\n  }\n}\n\nfunction resetPipes() {\n  // Remove all the pipes but the very latest one.\n  pipes.splice(0, pipes.length - 1);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-22",
      "language": "javascript",
      "code": "this.genes = [];\nfor (let i = 0; i < lifeSpan; i++) {\n  //{!2} Each gene is a vector with random direction and magnitude.\n  this.genes[i] = p5.Vector.random2D();\n  this.genes[i].mult(random(0, this.maxforce));\n}",
      "lineNumbers": true
    },
    {
      "id": "code-23",
      "language": "javascript",
      "code": "this.brain = ml5.neuralNetwork({\n  inputs: 2,\n  outputs: 2,\n  task: \"regression\",\n  neuroEvolution: true,\n});",
      "lineNumbers": true
    },
    {
      "id": "code-24",
      "language": "javascript",
      "code": "this.applyForce(this.genes[this.counter]);",
      "lineNumbers": false
    },
    {
      "id": "code-25",
      "language": "javascript",
      "code": "run() {\n  // Get the outputs from the neural network.\n  let outputs = this.brain.predictSync(inputs);\n  // Use one output for an angle.\n  let angle = outputs[0].value * TWO_PI;\n  // Use another output for the magnitude.\n  let magnitude = outputs[1].value * this.maxforce;\n  // Create and apply the force.\n  let force = p5.Vector.fromAngle(angle)\n  force.setMag(magnitude);\n  this.applyForce(force);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-26",
      "language": "javascript",
      "code": "let inputs = [this.position.x / width, this.position.y / height];",
      "lineNumbers": false
    },
    {
      "id": "code-27",
      "language": "javascript",
      "code": "reproduction() {\n    let nextPopulation = [];\n    // Create the next population.\n    for (let i = 0; i < this.population.length; i++) {\n      // Spin the wheel of fortune to pick two parents.\n      let parentA = this.weightedSelection();\n      let parentB = this.weightedSelection();\n      let child = parentA.crossover(parentB);\n      //{!1} Apply mutation.\n      child.mutate(this.mutationRate);\n      nextPopulation[i] = new Rocket(320, 220, child);\n    }\n    //{!1} Replace the old population.\n    this.population = nextPopulation;\n    this.generations++;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-28",
      "language": "javascript",
      "code": "class Glow {\n  constructor() {\n    //{!2} Two Perlin noise offsets\n    this.xoff = 0;\n    this.yoff = 1000;\n    this.position = createVector();\n    this.r = 24;\n  }\n\n  update() {\n    //{!2} Assign the position according to the Perlin noise.\n    this.position.x = noise(this.xoff) * width;\n    this.position.y = noise(this.yoff) * height;\n    //{!2} Move along the Perlin noise space.\n    this.xoff += 0.01;\n    this.yoff += 0.01;\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(200);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-29",
      "language": "javascript",
      "code": "seek(target) {\n    //{!1} Calculate a vector from the position to the target.\n    let v = p5.Vector.sub(target.position, this.position);",
      "lineNumbers": false
    },
    {
      "id": "code-30",
      "language": "javascript",
      "code": "seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    // Save the distance in a variable and normalize according to width (one input).\n    let distance = v.mag() / width;\n    // Normalize the vector pointing from the position to the target (two inputs).\n    v.normalize();",
      "lineNumbers": true
    },
    {
      "id": "code-31",
      "language": "javascript",
      "code": "seek(target) {\n    let v = p5.Vector.sub(target.position, this.position);\n    let distance = v.mag() / width;\n    v.normalize();\n    // Compile the features into an input array.\n    let inputs = [\n      v.x,\n      v.y,\n      distance,\n      this.velocity.x / this.maxspeed,\n      this.velocity.y / this.maxspeed,\n    ];\n    //{!5} Predict the force to apply.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let force = p5.Vector.fromAngle(angle);\n    let magnitude = outputs[1].value;\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-32",
      "language": "javascript",
      "code": "update(target) {\n    /* The usual updating of position, velocity, acceleration */\n\n    //{!4} Increase the fitness whenever the creature reaches the glow.\n    let d = p5.Vector.dist(this.position, target.position);\n    if (d < this.r + target.r) {\n      this.fitness++;\n    }\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-33",
      "language": "javascript",
      "code": "//{!1} A variable to hold the slider\nlet timeSlider;\n\nfunction setup() {\n  //{!1} Create a slider with a min and max range, and a starting value.\n  timeSlider = createSlider(1, 20, 1);\n}\n\nfunction draw() {\n  //{!5} The drawing code happens just once!\n  background(255);\n  glow.show();\n  for (let creature of creatures) {\n    creature.show();\n  }\n  //{!8} The simulation code runs multiple times according to the slider.\n  for (let i = 0; i < timeSlider.value(); i++) {\n    for (let creature of creatures) {\n      creature.seek(glow);\n      creature.update(glow);\n    }\n    glow.update();\n    lifeCounter++;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-34",
      "language": "javascript",
      "code": "class Creature {\n  constructor(x, y, brain) {\n    this.position = createVector(x, y);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0);\n    this.r = 4;\n    this.maxspeed = 4;\n    this.fitness = 0;\n\n    if (brain) {\n      this.brain = brain;\n    } else {\n      this.brain = ml5.neuralNetwork({\n        inputs: 5,\n        outputs: 2,\n        task: \"regression\",\n        neuroEvolution: true,\n      });\n    }\n  }\n  \n  /* <code>seek()</code> predicts a steering force as described previously. */\n\n  /* <code>update()</code> increments the fitness if the glow is reached as described previously. */\n\n}",
      "lineNumbers": true
    },
    {
      "id": "code-35",
      "language": "javascript",
      "code": "class Creature {\n  constructor(x, y) {\n    // The creature has a position and radius.\n    this.position = createVector(x, y);\n    this.r = 16;\n    // The creature has an array of sensors.\n    this.sensors = [];\n    // The creature has eight sensors.\n    let totalSensors = 8;\n    for (let i = 0; i < totalSensors; i++) {\n      // First, calculate a direction for the sensor.\n      let angle = map(i, 0, totalSensors, 0, TWO_PI);\n      // Create a vector a little bit longer than the radius as the sensor.\n      this.sensors[i] = p5.Vector.fromAngle(angle);\n      this.sensors[i].setMag(this.r * 1.5);\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-36",
      "language": "javascript",
      "code": "class Food {\n  //{!4} A piece of food has a random position and a fixed radius.\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.r = 50;\n  }\n\n  show() {\n    noStroke();\n    fill(0, 100);\n    circle(this.position.x, this.position.y, this.r * 2);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-37",
      "language": "javascript",
      "code": "class Sensor {\n  constructor(v) {\n    this.v = v.copy();\n    //{!1} The sensor also stores a value for the proximity of what it’s sensing.\n    this.value = 0;\n  }\n  \n  sense(position, food) {\n    //{!1} Find the tip (or endpoint) of the sensor by adding the creature’s position.\n    let end = p5.Vector.add(position, this.v);\n    //{!1} How far is it from the food’s center?\n    let d = end.dist(food.position);\n    //{!1} If the sensor is within the radius, light up the sensor.  \n    if (d < food.r) {\n      //{!1} The farther into the center of the food, the more the sensor activates.\n      this.value = map(d, 0, food.r, 1, 0);\n    } else {\n      this.value = 0;\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-38",
      "language": "javascript",
      "code": "let bloop, food;\n\nfunction setup() {\n  createCanvas(640, 240);\n  //{!2} One bloop, one piece of food\n  bloop = new Creature();\n  food = new Food();\n}\n\nfunction draw() {\n  background(255);\n  // Temporarily control the bloop with the mouse.\n  bloop.position.x = mouseX;\n  bloop.position.y = mouseY;\n  // Draw the food and the bloop.\n  food.show();\n  bloop.show();\n  // The bloop senses the food.\n  bloop.sense(food);\n}\n\nclass Creature {\n  constructor(x, y) {\n    this.position = createVector(x, y);\n    this.r = 16;\n\n    //{!8} Create the sensors for the creature.\n    this.sensors = [];\n    // Let’s use more sensors! How about 15?\n    let totalSensors = 15;\n    for (let i = 0; i < totalSensors; i++) {\n      let a = map(i, 0, totalSensors, 0, TWO_PI);\n      let v = p5.Vector.fromAngle(a);\n      v.mult(this.r * 2);\n      this.sensors[i] = new Sensor(v);\n    }\n  }\n\n  //{!4} Call the <code>sense()</code> method for each sensor.\n  sense(food) {\n    for (let sensor of this.sensors) {\n      sensor.sense(this.position, food);\n    }\n  }\n\n  // Draw the creature and all the sensors.\n  show() {\n    push();\n    translate(this.position.x, this.position.y);\n    for (let sensor of this.sensors) {\n      stroke(0);\n      line(0, 0, sensor.v.x, sensor.v.y);\n      if (sensor.value > 0) {\n        fill(255, sensor.value * 255);\n        stroke(0, 100)\n        circle(sensor.v.x, sensor.v.y, 8);\n      }\n    }\n    noStroke();\n    fill(0);\n    circle(0, 0, this.r * 2);\n    pop();\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-39",
      "language": "javascript",
      "code": "think() {\n    // Build an input array from the sensor values.\n    let inputs = [];\n    for (let i = 0; i < this.sensors.length; i++) {\n      inputs[i] = this.sensors[i].value;\n    }\n    // Predict a steering force from the sensors.\n    let outputs = this.brain.predictSync(inputs);\n    let angle = outputs[0].value * TWO_PI;\n    let magnitude = outputs[1].value;\n    let force = p5.Vector.fromAngle(angle)\n    force.setMag(magnitude);\n    this.applyForce(force);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-40",
      "language": "javascript",
      "code": "class Creature {  \n  constructor() {\n    /* All of the creature's properties */\n    // The health starts at 100.\n    this.health = 100;\n  } \n\n  update() {\n    /* The usual updating position, velocity, acceleration */\n    // Lose some health!\n    this.health -= 0.25;\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-41",
      "language": "javascript",
      "code": "function draw() {\n    for (let i = bloops.length - 1; i >= 0; i--) {\n      if (bloops[i].health < 0) {\n        bloops.splice(i, 1);\n      } else if (random(1) < 0.001) {\n        let child = bloops[i].reproduce();\n        bloops.push(child);\n      }\n    }\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-42",
      "language": "javascript",
      "code": "reproduce() {\n    //{!2} Copy and mutate rather than use crossover and mutate.\n    let brain = this.brain.copy();\n    brain.mutate(0.1);\n    return new Creature(this.position.x, this.position.y, brain);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-43",
      "language": "javascript",
      "code": "eat(food) {\n    // If the bloop is close to the food, increase its health!\n    let d = p5.Vector.dist(this.position, food.position);\n    if (d < this.r + food.r) {\n      this.health += 0.5;\n    }\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-44",
      "language": "javascript",
      "code": "let bloops = [];\nlet food = [];\n\nfunction setup() {\n  createCanvas(640, 240);\n  for (let i = 0; i < 20; i++) {\n    bloops[i] = new Creature(random(width), random(height));\n  }\n  for (let i = 0; i < 8; i++) {\n    food[i] = new Food();\n  }\n}\n\nfunction draw() {\n  background(255);\n  for (let i = bloops.length - 1; i >= 0; i--) {\n    bloops[i].think();\n    bloops[i].eat();\n    bloops[i].update();\n    bloops[i].borders();\n    if (bloops[i].health < 0) {\n      bloops.splice(i, 1);\n    } else if (random(1) < 0.001) {\n      let child = bloops[i].reproduce();\n      bloops.push(child);\n    }\n  }\n  for (let treat of food) {\n    treat.show();\n  }\n  for (let bloop of bloops) {\n    bloop.show();\n  }\n}",
      "lineNumbers": true
    }
  ],
  "images": [
    "images/11_nn_ga/11_nn_ga_1.png",
    "images/11_nn_ga/11_nn_ga_2.png",
    "images/11_nn_ga/11_nn_ga_3.png",
    "images/11_nn_ga/11_nn_ga_4.png",
    "images/11_nn_ga/11_nn_ga_5.png",
    "examples/11_nn_ga/11_1_flappy_bird/screenshot.png",
    "images/11_nn_ga/11_nn_ga_6.png",
    "examples/11_nn_ga/11_2_flappy_bird_neuro_evolution/screenshot.png",
    "examples/11_nn_ga/11_3_smart_rockets_neuro_evolution/screenshot.png",
    "examples/11_nn_ga/11_4_neuro_evolution_steering_seek/screenshot.png",
    "images/11_nn_ga/11_nn_ga_7.png",
    "images/11_nn_ga/11_nn_ga_8.png",
    "examples/11_nn_ga/11_5_creature_sensors/screenshot.png",
    "examples/11_nn_ga/11_6_neuroevolution_ecosystem/screenshot.png",
    "images/11_nn_ga/11_nn_ga_9.png",
    "images/11_nn_ga/11_nn_ga_10.png"
  ]
}