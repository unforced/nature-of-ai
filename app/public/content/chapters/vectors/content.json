{
  "id": "vectors",
  "slug": "vectors",
  "title": "1. Vectors",
  "type": "chapter",
  "content": "\nChapter 1. Vectors\n\n  \n    I’m committing crimes with both direction and magnitude.\n    \n      —Vector, Despicable Me\n    \n  \n\n\n  \n    \n    \n  \n  Marshall Islands stick chart on display at the Berkeley Art Museum (photo by Jim Heaphy)\n  The stick chart is a navigational tool crafted by the indigenous people of the Marshall Islands, located in the central Pacific Ocean. This ancient tool was made by carefully tying together the midribs of coconut fronds. Shell markings on the chart signify the locations of islands in the region. The layout of the fronds and shells serves as a geographical guide, offering an abstract representation of vectors that capture the ocean swell patterns and their directional flow.\n\nThis book is all about looking at the world around us and developing ways to simulate it with code. In this first part of the book, I’ll start by looking at basic physics: how an apple falls from a tree, how a pendulum swings in the air, how Earth revolves around the sun, and so on. Absolutely everything contained within the book’s first five chapters requires the use of the most basic building block for programming motion, the vector. And so that’s where I’ll begin the story.\nThe word vector can mean a lot of things. It’s the name of a New Wave rock band formed in Sacramento, California, in the early 1980s, and the name of a breakfast cereal manufactured by Kellogg’s Canada. In the field of epidemiology, a vector is an organism that transmits infection from one host to another. In the C++ programming language, a vector (std::vector) is an implementation of a dynamically resizable array data structure.\nWhile all these definitions are worth exploring, they’re not the focus here. Instead, this chapter dives into the Euclidean vector (named for the Greek mathematician Euclid), also known as the geometric vector. When you see the term vector in this book, you can assume it refers to a Euclidean vector, defined as an entity that has both magnitude and direction.\n\n  \n    \n    Figure 1.1: A vector represented as an arrow drawn from point A to point B\n  \n\nA vector is typically drawn as an arrow, as in Figure 1.1. The vector’s direction is indicated by where the arrow is pointing, and its magnitude by the length of the arrow.\nThe vector in Figure 1.1 is drawn as an arrow from point A to point B. It serves as an instruction for how to travel from A to B.\nThe Point of Vectors\n\nBefore diving into more details about vectors, I’d like to create a p5.js example that demonstrates why you should care about vectors in the first place. If you’ve watched any beginner p5.js tutorials, read any introductory p5.js textbooks, or taken an introduction to creative coding course (and hopefully you’ve done one of these things to help prepare you for this book!), you probably, at one point or another, learned how to write a bouncing ball sketch.\n\n  Example 1.1: Bouncing Ball with No Vectors\n  \n    \n    \n  \n\n// Variables for position and speed of ball\nlet x = 100;\nlet y = 100;\nlet xspeed = 2.5;\nlet yspeed = 2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  // Move the ball according to its speed.\n  x = x + xspeed;\n  y = y + yspeed;\n  // Check for bouncing.\n  if (x > width || x < 0) {\n    xspeed = xspeed * -1;\n  }\n  if (y > height || y < 0) {\n    yspeed = yspeed * -1;\n  }\n  // Draw the ball at the position (<em>x</em>, <em>y</em>).\n  stroke(0);\n  fill(127);\n  circle(x, y, 48);\n}\n\n  In this example, there’s a flat, 2D world—a blank canvas—with a circular shape (a “ball”) traveling around. This ball has properties like position and speed that are represented in the code as variables:\n  \n    \n      \n        Property\n        Variable Names\n      \n    \n    \n      \n        Position\n        x and y\n      \n      \n        Speed\n        xspeed and yspeed\n      \n    \n  \n\nIn a more sophisticated sketch, you might have many more variables representing other properties of the ball and its environment:\n\n  \n    \n      Property\n      Variable Names\n    \n  \n  \n    \n      Acceleration\n      xacceleration and yacceleration\n    \n    \n      Target position\n      xtarget and ytarget\n    \n    \n      Wind\n      xwind and ywind\n    \n    \n      Friction\n      xfriction and yfriction\n    \n  \n\nYou might notice that for every concept in this world (wind, position, acceleration, and the like), there are two variables. And this is only a 2D world. In a three-dimensional (3D) world, you’d need three variables for each property: x, y, and z for position; xspeed, yspeed, and zspeed for speed; and so on. Wouldn’t it be nice to simplify the code to use fewer variables? Instead of starting the program with something like this\nlet x;\nlet y;\nlet xspeed;\nlet yspeed;\nyou’d be able to start it with something like this:\nlet position;\nlet speed;\nThinking of the ball’s properties as vectors instead of a loose collection of separate values will allow you to do just that.\nTaking this first step toward using vectors won’t let you do anything new or magically turn a p5.js sketch into a full-on physics simulation. However, using vectors will help organize your code and provide a set of methods for common mathematical operations you’ll need over and over and over again while programming motion.\nAs an introduction to vectors, I’m going to stick to two dimensions for quite some time (at least the first several chapters). All these examples can be fairly easily extended to three dimensions (and the class I’ll use, p5.Vector, allows for three dimensions). However, for the purposes of learning the fundamentals, the added complexity of the third dimension would be a distraction.\nVectors in p5.js\nThink of a vector as the difference between two points, or as instructions for walking from one point to another. For example, Figure 1.2 shows some vectors and possible interpretations of them.\n\n  \n  Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions for walking in north, south, east, or west directions\n\nThese vectors could be thought of in the following way:\n\n  \n    \n      Vector\n      Instructions\n    \n  \n  \n    \n      (–15, 3)\n      Walk 15 steps west; turn and walk 3 steps north.\n    \n    \n      (3, 4)\n      Walk 3 steps east; turn and walk 4 steps north.\n    \n    \n      (2, –1)\n      Walk 2 steps east; turn and walk 1 step south.\n    \n  \n\nYou’ve probably already thought this way when programming motion. For every frame of animation (a single cycle through a p5.js draw() loop), you instruct each object to reposition itself to a new spot a certain number of pixels away horizontally and a certain number of pixels away vertically. This instruction is essentially a vector, as in Figure 1.3; it has both magnitude (how far away did you travel?) and direction (which way did you go?).\n\n  \n  Figure 1.3: A vector showing the number of horizontal and vertical steps to go from a position to a new position\n\nThe vector sets the object’s velocity, defined as the rate of change of the object’s position with respect to time. In other words, the velocity vector determines the object’s new position for every frame of the animation, according to this basic algorithm for motion: the new position is equal to the result of applying the velocity to the current position.\nIf velocity is a vector (the difference between two points), what about position? Is it a vector too? Technically, you could argue that position is not a vector, since it’s not describing how to move from one point to another; it’s describing a single point in space. Nevertheless, another way to describe a position is as the path taken from the origin—point (0, 0)—to the current point. When you think of position in this way, it becomes a vector, just like velocity, as in Figure 1.4.\n\n  \n  Figure 1.4: A computer graphics window with (0, 0) in the top left, showing a position vector and a velocity vector\n\nIn Figure 1.4, the vectors are placed on a computer graphics canvas. Unlike in Figure 1.2, the origin point (0, 0) isn’t at the center; it’s at the top-left corner. And instead of north, south, east, and west, there are positive and negative directions along the x- and y-axes (with y pointing down in the positive direction).\nLet’s examine the underlying data for both position and velocity. In the bouncing ball example, I originally had the following variables:\n\n  \n    \n      Property\n      Variable Names\n    \n  \n  \n    \n      Position\n      x, y\n    \n    \n      Velocity\n      xspeed, yspeed\n    \n  \n\nNow I’ll treat position and velocity as vectors instead, each represented by an object with x and y attributes. If I were to write a Vector class myself, I’d start with something like this:\nclass Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\nNotice that this class is designed to store the same data as before—two floating-point numbers per vector, an x value and a y value. At its core, a Vector object is just a convenient way to store two values (or three, as you’ll see in 3D examples) under one name.\nAs it happens, p5.js already has a built-in p5.Vector class, so I don’t need to write one myself. And so this\nlet x = 100;\nlet y = 100;\nlet xspeed = 1;\nlet yspeed = 3.3;\nbecomes this:\nlet position = createVector(100, 100);\nlet velocity = createVector(1, 3.3);\nNotice that the position and velocity vector objects aren’t created as you might expect,\nby invoking a constructor function. Instead of writing new p5.Vector(x, y), I’ve called createVector(x, y). The createVector() function is included in p5.js as a helper function to\ntake care of details behind the scenes upon creation of the vector. Except in special circumstances, you should always create p5.Vector objects with createVector(). I should note that p5.js functions such as createVector() can’t be executed outside of setup() or draw(), since the library won’t yet be loaded. I’ll demonstrate how to address this in Example 1.2.\nNow that I have two vector objects (position and velocity), I’m ready to implement the vector-based algorithm for motion: position = position + velocity. In Example 1.1, without vectors, the code reads as follows:\n// Add each speed to each position.\nx = x + xspeed;\ny = y + yspeed;\nIn an ideal world, I would be able to rewrite this as shown here:\n// Add the velocity vector to the position vector.\nposition = position + velocity;\nIn JavaScript, however, the addition operator + is reserved for primitive values (integers, floats, and the like). JavaScript doesn’t know how to add two p5.Vector objects together any more than it knows how to add two p5.Font objects or p5.Image objects. Fortunately, the p5.Vector class includes methods for common mathematical operations.\nVector Addition\n\nBefore I continue working with the p5.Vector class and the add() method, let’s examine vector addition by using the notation found in math and physics textbooks. Vectors are typically written either in boldface type or with an arrow on top. For the purposes of this book, to distinguish a vector (with magnitude and direction) from a scalar (a single value, such as an integer or a floating-point number), I’ll use the arrow notation:\n\n  Vector: \\vec{v}\n  Scalar: {x}\n\nLet’s say I have the two vectors shown in Figure 1.5.\n\n  \n  Figure 1.5: Two vectors \\vec{u} and \\vec{v} depicted as triangles\n\nEach vector has two components, an x and a y. To add the two vectors together, add both x-components and y-components to create a new vector, as in Figure 1.6.\n\n  \n  Figure 1.6: Adding vectors by combining the x- and y-components\n\nIn other words, \\vec{w} = \\vec{u} + \\vec{v} can be written as follows:\nw_x = u_x + v_x\nw_y = u_y + v_y\nThen, replacing \\vec{u} and \\vec{v} with their values from Figure 1.6, you get this:\nw_x = 5 + 3 = 8\nw_y = 2 + 4 = 6\nFinally, write the result as a vector:\n\\vec{w} = (8,6)\n\n  Addition Properties with Vectors\n  Addition with vectors follows the same algebraic rules as with real numbers.\n  The commutative rule: \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u}\n  The associative rule: \\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w}\n  Fancy terminology and symbols aside, these rules boil down to quite a simple concept: the result is the same no matter the order in which the vectors are added. Replace the vectors with regular numbers (scalars), and these rules are easy to see:\n  Commutative: 3 + 2 = 2 + 3\n  Associative: (3 + 2) + 1 = 3 + (2 + 1)\n\nNow that I’ve covered the theory behind adding two vectors together, I can turn to adding vector objects in p5.js. Imagine again that I’m creating my own Vector class. I could give it a function called add() that takes another Vector object as its argument:\nclass Vector {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  //{!4} New! A function to add another vector to this vector. Add the x-components and the y-components separately.\n  <strong>add(v) {\n    this.x = this.x + v.x;\n    this.y = this.y + v.y;\n  }</strong>\n}\nThe function looks up the x- and y-components of the two vectors and adds them separately. This is exactly how the built-in p5.Vector class’s add() method is written too. Knowing how it works, I can now return to the bouncing ball example with its position + velocity algorithm and implement vector addition:\n// This does not work!\n<s>position = position + velocity;</s>\n// Add the velocity to the position.\nposition.add(velocity);\nNow you have what you need to rewrite the bouncing ball example with vectors.\n\n  Example 1.2: Bouncing Ball with Vectors!\n  \n    \n    \n  \n\n// Instead of a bunch of floats, you now have just two variables.\n<strong>let position;\nlet velocity;</strong>\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Note that <code>createVector()</code> has to be called inside <code>setup()</code>.\n  <strong>position = createVector(100, 100);\n  velocity = createVector(2.5, 2);</strong>\n}\n\nfunction draw() {\n  background(255);\n  <strong>position.add(velocity);</strong>\n\n  // You still sometimes need to refer to the individual components of a <code>p5.Vector</code> and can do so using the dot syntax: <code>position.x</code>, <code>velocity.y</code>, and so forth.\n  <strong>if (position.x > width || position.x < 0) {\n    velocity.x = velocity.x * -1;\n  }\n  if (position.y > height || position.y < 0) {\n    velocity.y = velocity.y * -1;\n  }</strong>\n\n  stroke(0);\n  fill(127);\n  circle(position.x, position.y, 48);\n}\nAt this stage, you might feel somewhat disappointed. After all, these changes may appear to have made the code more complicated than the original version. While this is a perfectly reasonable and valid critique, it’s important to understand that the power of programming with vectors hasn’t been fully realized just yet. Looking at a bouncing ball and only implementing vector addition is just the first step. As I move forward into a more complex world of multiple objects and multiple forces (which I’ll introduce in Chapter 2) acting on those objects, the benefits of vectors will become more apparent.\nI should, however, note an important aspect of the transition to programming with vectors. Even though I’m using p5.Vector objects to encapsulate two values—the x and y of the ball’s position or the x and y of the ball’s velocity—under a single variable name, I’ll still often need to refer to the x- and y-components of each vector individually.\nThe circle() function doesn’t allow for a p5.Vector object as an argument. A circle can be drawn with only two scalar values, an x-coordinate and a y-coordinate. And so I must dig into the p5.Vector object and pull out the x- and y-components by using object-oriented dot syntax:\n<s>circle(position, 48);</s>\ncircle(position.x, position.y, 48);\nThe same issue arises when testing whether the circle has reached the edge of the window. In this case, I need to access the individual components of both vectors, position and velocity:\nif ((position.x > width) || (position.x < 0)) {\n  velocity.x = velocity.x * -1;\n}\nIt may not always be obvious when to directly access an object’s properties versus when to reference the object as a whole or use one of its methods. The goal of this chapter (and most of this book) is to help you distinguish between these scenarios by providing a variety of examples and use cases.\n\n  Exercise 1.1\n  Take one of the walker examples from Chapter 0 and convert it to use vectors.\n\n\n  Exercise 1.2\n  Find something else you’ve previously made in p5.js using separate x and y variables, and use vectors instead.\n\n\n  Exercise 1.3\n  Extend Example 1.2 into 3D. Can you get a sphere to bounce around a box?\n  \n    \n      \n      \n    \n  \n\nMore Vector Math\nAddition was really just the first step. Many mathematical operations are commonly used with\nvectors. Here’s a comprehensive table of the operations available as methods in the p5.Vector class. Remember, these are not stand-alone functions, but rather methods associated with the p5.Vector class. When you see the word this in the following table, it refers to the specific vector the method is operating on.\n\n  \n    \n      Method\n      Task\n    \n  \n  \n    \n      \n        <code>add()</code>\n      \n      Adds a vector to this vector\n    \n    \n      \n        <code>sub()</code>\n      \n      Subtracts a vector from this vector\n    \n    \n      \n        <code>mult()</code>\n      \n      Scales this vector with multiplication\n    \n    \n      \n        <code>div()</code>\n      \n      Scales this vector with division\n    \n    \n      \n        <code>mag()</code>\n      \n      Returns the magnitude of this vector\n    \n    \n      \n        <code>setMag()</code>\n      \n      Sets the magnitude of this vector\n    \n    \n      \n        <code>normalize()</code>\n      \n      Normalizes this vector to a unit length of 1\n    \n    \n      \n        <code>limit()</code>\n      \n      Limits the magnitude of this vector\n    \n    \n      \n        <code>heading()</code>\n      \n      Returns the 2D heading of this vector expressed as an angle\n    \n    \n      \n        <code>rotate()</code>\n      \n      Rotates this 2D vector by an angle\n    \n    \n      \n        <code>lerp()</code>\n      \n      Linear interpolates to another vector\n    \n    \n      \n        <code>dist()</code>\n      \n      Returns the Euclidean distance between two vectors (considered as points)\n    \n    \n      \n        <code>angleBetween()</code>\n      \n      Finds the angle between two vectors\n    \n    \n      \n        <code>dot()</code>\n      \n      Returns the dot product of two vectors\n    \n    \n      \n        <code>cross()</code>\n      \n      Returns the cross product of two vectors (relevant only in three dimensions)\n    \n    \n      \n        <code>random2D()</code>\n      \n      Returns a random 2D vector\n    \n    \n      \n        <code>random3D()</code>\n      \n      Returns a random 3D vector\n    \n  \n\nI’ll go through a few of the key methods now. As the examples get more sophisticated in later chapters, I’ll continue to reveal more details.\nVector Subtraction\n\n  \n    \n    Figure 1.7: The relationship between \\vec{v} and -\\vec{v} \n  \n\nHaving already covered addition, I’ll now turn to subtraction. This one’s not so bad; just take the plus sign and replace it with a minus! Before tackling subtraction itself, however, consider what it means for a vector \\vec{v} to become -\\vec{v}. The negative version of the scalar 3 is –3. A negative vector is similar: the polarity of each of the vector’s components is inverted. So if \\vec{v} has the components (x, y), then -\\vec{v} is (–x, –y). Visually, this results in an arrow of the same length as the original vector pointing in the opposite direction, as depicted in Figure 1.7.\nSubtraction, then, is the same as addition, only with the second vector in the equation treated as a negative version of itself:\n\\vec{u} - \\vec{v} = \\vec{u} + -\\vec{v}\nJust as vectors are added by placing them “tip to tail”—that is, aligning the tip (or endpoint) of one vector with the tail (or start point) of the next—vectors are subtracted by reversing the direction of the second vector and placing it at the end of the first, as in Figure 1.8.\n\n  \n  Figure 1.8: Vector subtraction places one vector at the end of another, but pointing in the opposite direction.\n\nTo actually solve the subtraction, take the difference of the vectors’ components. That is, \\vec{w} = \\vec{u} - \\vec{v} can be written as shown here:\nw_x = u_x - v_x\nw_y = u_y - v_y\nInside p5.Vector, the code reads as follows:\nsub(v) {\n  this.x = this.x - v.x;\n  this.y = this.y - v.y;\n}\nThe following example demonstrates vector subtraction by taking the difference between two points (which are treated as vectors): the mouse position and the center of the window.\n\n  Example 1.3: Vector Subtraction\n  \n    \n    \n  \n\nfunction draw() {\n  background(255);\n  // Two vectors, one for the mouse location and one for the center of the window\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  // Draw the original two vectors.\n  stroke(200);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n  line(0, 0, center.x, center.y);\n  // Vector subtraction!\n  mouse.sub(center);\n  // Draw a line to represent the result of subtraction.\n  // Notice that I move the origin with <code>translate()</code> to place the vector.\n  stroke(0);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}\nNote the use of translate() to visualize the resulting vector as a line from the center (width / 2,\nheight / 2) to the mouse. Vector subtraction is its own kind of translation, moving the “origin” of a position vector. Here, by subtracting the center vector from the mouse vector, I’m effectively moving the starting point of the resulting vector to the center of the canvas. Therefore, I also need to move the origin by using translate(). Without this, the line would be drawn from the top-left corner, and the visual connection wouldn’t be as clear.\nVector Multiplication and Division\n\n  \n    \n    Figure 1.9: Scaling a vector with multiplication\n  \n\nMoving on to multiplication, you have to think a bit differently. Multiplying a vector typically refers to the process of scaling a vector. If I want to scale a vector to twice its size or one-third of its size, while leaving its direction the same, I would say, “Multiply the vector by 2” or “Multiply the vector by 1/3.” Unlike with addition and subtraction, I’m multiplying the vector by a scalar (a single number), not by another vector. Figure 1.9 illustrates how to scale a vector by a factor of 3.\nTo scale a vector, multiply each component (x and y) by a scalar. That is, \\vec{w} = \\vec{u} \\times n can be written as shown here:\nw_x = u_x \\times n\nw_y = u_y \\times n\nAs an example, say \\vec{u} = (-3, 7) and n = 3. You can calculate \\vec{w} = \\vec{u} \\times n as follows:\nw_x = -3 \\times 3\nw_y = 7 \\times 3\n\\vec{w} = (-9,21)\nThis is exactly how the mult() function inside the p5.Vector class works:\n\n  mult(n) {\n  // The components of the vector are multiplied by a number.\n  this.x = this.x * n;\n  this.y = this.y * n;\n}\n\nImplementing multiplication in code is as simple as the following:\nlet u = createVector(-3, 7);\n// This <code>p5.Vector</code> is now three times the size and is equal to (–9, 21). See Figure 1.9.\nu.mult(3);\nExample 1.4 illustrates vector multiplication by drawing a line between the mouse and the center of the canvas, as in the previous example, and then scaling that line by 0.5.\n\n  Example 1.4: Multiplying a Vector\n  \n    \n    \n  \n\nfunction draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  strokeWeight(2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!1} Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).\n  mouse.mult(0.5);\n  stroke(0);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n}\nThe resulting vector is half its original size. Rather than multiplying the vector by 0.5, I could achieve the same effect by dividing the vector by 2, as in Figure 1.10.\n\n  \n  Figure 1.10: Scaling a vector with division\n\nVector division, then, works just like vector multiplication—just replace the multiplication sign (*) with the division sign (/). Here’s how the p5.Vector class implements the div() function:\ndiv(n) {\n  this.x = this.x / n;\n  this.y = this.y / n;\n}\nAnd here’s how to use the div() function in a sketch:\nlet u = createVector(8, -4);\n// Dividing a vector!  The vector is now half its original size (divided by 2).\nu.div(2);\nThis takes the vector u and divides it by 2.\n\n  More Number Properties with Vectors\n  As with addition, basic algebraic rules of multiplication apply to vectors.\n  The associative rule: (n \\times m) \\times \\vec{v} = n \\times (m \\times \\vec{v})\n  The distributive rule with two scalars, one vector: (n + m) \\times \\vec{v} = (n \\times \\vec{v}) + (m \\times \\vec{v})\n  The distributive rule with two vectors, one scalar: (\\vec{u} + \\vec{v}) \\times n = (\\vec{u} \\times n) + (\\vec{v} \\times n)\n\nVector Magnitude\n\n  \n    \n    Figure 1.11: The length, or magnitude, of a vector \\vec{v} is often written as \\lVert\\vec{v}\\rVert.\n  \n\nMultiplication and division, as just described, alter the length of a vector without affecting its direction. Perhaps you’re wondering, “Okay, so how do I know what the length of a vector is? I know the vector’s components (x and y), but how long (in pixels) is the actual arrow?” Understanding how to calculate the length of a vector, also known as its magnitude, is incredibly useful and important.\n\n  \n    \n    Figure 1.12: The Pythagorean theorem calculates the length of a vector by using its components.\n  \n\nNotice in Figure 1.11 that the vector, drawn as an arrow and two components (x and y), creates a right triangle. The sides are the components, and the hypotenuse is the arrow. We’re lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras discovered a lovely formula that describes the relationship between the sides and hypotenuse of a right triangle. This formula, the Pythagorean theorem, is a^2 + b^2 = c^2 (see Figure 1.12).\nArmed with this formula, we can now compute the magnitude of \\vec{v} as follows:\n||\\vec{v}||=\\sqrt{v_x * v_x + v_y * v_y}\nIn the p5.Vector class, the mag() function is defined using the same formula:\n\n  mag() {\n  return sqrt(this.x * this.x + this.y * this.y);\n}\n\nThe sketch in the next example calculates the magnitude of the vector between the mouse and the center of the canvas, and visualizes it as a rectangle drawn across the top of the window.\n\n  Example 1.5: Vector Magnitude\n  \n    \n    \n  \n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n  //{!3} The magnitude (that is, length) of a vector can be accessed via the <code>mag()</code> method.  Here it is used as the width of a rectangle drawn at the top of the window.\n  let m = mouse.mag();\n  fill(0);\n  rect(0, 0, m, 10);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}\nNotice that the magnitude (length) of a vector is always positive, even if the vector’s components are negative.\nNormalizing Vectors\n\n\n  \n    \n    Figure 1.13: When a vector is normalized, it points in the same direction but has been resized to a unit length of 1.\n  \n\nCalculating the magnitude of a vector is only the beginning. It opens the door to many possibilities, the first of which is normalization (Figure 1.13). This is the process of making something standard or, well . . . normal. In the case of vectors, the convention is that a standard vector has a length of 1. To normalize a vector, therefore, is to take a vector of any length and change its length to 1, without changing its direction. That normalized vector is then called a unit vector.\nA unit vector describes a vector’s direction without regard to its length. You’ll see this come in especially handy once you start to work with forces in Chapter 2.\nFor any given vector \\vec{u}, its unit vector (written as \\hat{u}) is calculated as follows:\n\\hat{u} = \\frac{\\vec{u}}{||\\vec{u}||}\n\n  \n    \n    Figure 1.14: To normalize a vector, its components are divided by its magnitude.\n  \n\nIn other words, to normalize a vector, divide each component by the vector’s magnitude. To see why this works, consider a vector (4, 3), which has a magnitude of 5 (see Figure 1.14). Once normalized, the vector will have a magnitude of 1. Thinking of the vector as a right triangle, normalization shrinks the hypotenuse by dividing by 5 (since 5/5 = 1). In that process, each side shrinks as well, also by a factor of 5. The side lengths go from 4 and 3 to 4/5 and 3/5, respectively.\nIn the p5.Vector class, the normalization method is written as follows:\nnormalize() {\n  let m = this.mag();\n  this.div(m);\n}\nOf course, there’s one small issue. What if the magnitude of the vector is 0? You can’t divide by 0! Some quick error checking, shown next, fixes that right up.\nnormalize() {\n  let m = this.mag();\n  if (m > 0) {\n    this.div(m);\n  }\n}\nThis sketch uses normalization to give the vector between the mouse and the center of the canvas a fixed length, regardless of the actual magnitude of the original vector.\n\n  Example 1.6: Normalizing a Vector\n  \n    \n    \n  \n\nfunction draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!2} In this example, after the vector is normalized, it’s multiplied by 50. Note that no matter where the mouse is, the vector always has the same length (50) because of the normalization process.\n  mouse.normalize();\n  mouse.mult(50);\n  stroke(0);\n  strokeWeight(8);\n  line(0, 0, mouse.x, mouse.y);\n}\nNotice that I’ve multiplied the mouse vector by 50 after normalizing it to 1. Normalization is often the first step in creating a vector of a specific length, even if the desired length is something other than 1. You’ll see more of this later in the chapter.\nAll this vector math stuff sounds like something you should know about, but why? How will it help you write code? Patience. It’ll take some time before the awesomeness of using p5.Vector fully comes to light. This is a fairly common occurrence when learning a new data structure. For example, when you first learn about arrays, it might seem like more work to use an array than to have several variables stand for multiple things. That plan quickly breaks down when you need 100, 1,000, or 10,000 things, however.\nThe same can be true for vectors. What might seem like more work now will pay off later, and quite nicely. And you don’t have to wait too long, as your reward will come in the next chapter. For now, however, I’ll focus on how vectors work, and on how working with them provides a different way to think about motion.\nMotion with Vectors\nWhat does it mean to program motion by using vectors? You got a taste of it in Example 1.2, the bouncing ball. The circle onscreen has a position (its location at any given moment) as well as a velocity (instructions for how it should move from one moment to the next). Velocity is added to position:\nposition.add(velocity);\nThen the object is drawn at the new position:\ncircle(position.x, position.y, 48);\nTogether, these steps are Motion 101:\n\n  Add the velocity to the position.\n  Draw the object at the position.\n\nIn the bouncing ball example, all this code happened within setup() and draw(). What I want to do now is move toward encapsulating all the logic for an object’s motion inside a class. This way, I can create a foundation for programming moving objects that I can easily reuse again and again. (See “The Random Walker Class” for a brief review of OOP basics.)\nTo start, I’m going to create a generic Mover class that will describe a shape moving around the canvas. For that, I must consider the following two questions:\n\n  What data does a mover have?\n  What functionality does a mover have?\n\nThe Motion 101 algorithm answers both of these questions. First, a Mover object has two pieces of data, position and velocity, which are both p5.Vector objects. These are initialized in the object’s constructor. In this case, I’ll arbitrarily decide to initialize the Mover object by giving it a random position and velocity. Note the use of this with all variables that are part of the Mover object:\n\n  class Mover {\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2,2), random(-2, 2));\n  }\n\nThe functionality follows suit. The Mover object needs to move (by applying its velocity to its position) and needs to be visible. I’ll implement these needs as functions named update() and show(). I’ll put all the motion logic code in update() and draw the object in show():\n\n    update() {\n    // The mover moves.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // The mover is drawn as a circle.\n    circle(this.position.x, this.position.y, 48);\n  }\n\nThe Mover class also needs a function that determines what the object should do when it reaches the edge of the canvas. For now, I’ll do something simple and have it wrap around the edges:\n\n    checkEdges() {\n    //{!11.allow-break} When it reaches one edge, set the position to the other edge.\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x < 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y < 0) {\n      this.position.y = height;\n    }\n  }\n}\n\nNow the Mover class is finished, but the class itself isn’t an object; it’s a template for creating an instance of an object. To actually create a Mover object, I first need to declare a variable to hold it:\nlet mover;\nThen, inside the setup() function, I create the object by invoking the class name along with the new keyword. This triggers the class’s constructor to make an instance of the object:\nmover = new Mover();\nNow all that remains is to call the appropriate methods in draw():\nmover.update();\nmover.checkEdges();\nmover.show();\nHere’s the entire example for reference.\n\n  Example 1.7: Motion 101 (Velocity)\n  \n    \n    \n  \n\n// Declare the <code>Mover</code> object.\nlet mover;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create the <code>Mover</code> object.\n  mover = new Mover();\n}\n\nfunction draw() {\n  background(255);\n  // Call methods on the <code>Mover</code> object.\n  mover.update();\n  mover.checkEdges();\n  mover.show();\n}\n\nclass Mover {\n  constructor() {\n    // The object has two vectors: position and velocity.\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2, 2), random(-2, 2));\n  }\n\n  update() {\n    // Motion 101: position changes by velocity.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(127);\n    circle(this.position.x, this.position.y, 48);\n  }\n\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x < 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y < 0) {\n      this.position.y = height;\n    }\n  }\n}\nIf OOP is at all new to you, one aspect here may seem a bit strange. I spent the beginning of this chapter discussing the p5.Vector class, and this class is the template for making the position object and the velocity object. So what are those objects doing inside yet another object, the Mover object?\nIn fact, this is just about the most normal thing ever. An object is something that holds data (and functionality). That data can be numbers, or it can be other objects (arrays too)! You’ll see this over and over again in this book. In Chapter 4, for example, I’ll write a class to describe a system of particles. That ParticleSystem object will include a list of Particle objects . . . and each Particle object will have as its data several p5.Vector objects!\nYou may have also noticed in the Mover class that I’m setting the initial position and velocity directly within the constructor, without using any arguments. While this approach keeps the code simple for now, I’ll explore the benefits of adding arguments to the constructor in Chapter 2.\nAt this point, you hopefully feel comfortable with two concepts: (1) what a vector is and (2) how to use vectors inside an object to keep track of its position and movement. This is an excellent first step and deserves a mild round of applause. Before standing ovations are in order, however, you need to make one more, somewhat bigger step forward. After all, watching the Motion 101 example is fairly boring. The circle never speeds up, never slows down, and never turns. For more sophisticated motion—the kind of motion that appears in the world around us—one more vector needs to be added to the class: acceleration.\nAcceleration\n\nAcceleration is the rate of change of velocity. Think about that definition for a moment. Is it a new concept? Not really. Earlier I defined velocity as the rate of change of position, so in essence I’m developing a trickle-down effect. Acceleration affects velocity, which in turn affects position. (To provide some brief foreshadowing, this point will become even more crucial in the next chapter, when I show how forces like friction affect acceleration, which affects velocity, which affects position.) In code, this trickle-down effect reads like this:\nvelocity.add(acceleration);\nposition.add(velocity);\nAs an exercise, from this point forward, I’m going to make a rule for myself: I’ll try to write every example in the rest of this book without ever touching the values of velocity and position (except to initialize them). In other words, the goal for programming motion is to come up with an algorithm for calculating acceleration and then let the trickle-down effect work its magic. (In truth, there will be a multitude of reasons to break this rule, and break it I shall. Nevertheless, it’s a useful constraint to begin with to illustrate the principles behind the motion algorithm with acceleration.)\nThe next step, then, is to come up with a way to calculate acceleration. Here are a few possible algorithms:\n\n  A constant acceleration\n  A random acceleration\n  An acceleration toward the mouse\n\nI’ll use the rest of this chapter to show you how to implement these algorithms.\nAlgorithm 1: Constant Acceleration\nAcceleration Algorithm 1, a constant acceleration, isn’t particularly interesting, but it’s the simplest and thus an excellent starting point to incorporate acceleration into the code. The first step is to add another variable to the Mover class:\n\n  class Mover {\n  constructor() {\n    // Initialize a stationary mover at the center of the canvas.\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // A new vector for acceleration\n    <strong>this.acceleration = createVector(0, 0);</strong>\n  }\n\n\nNext, incorporate acceleration into the update() function:\n\n    update() {\n    // The motion algorithm is now two lines of code!\n    <strong>this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);</strong>\n  }\n\nI’m almost finished. The only missing piece is to get that mover moving! In the constructor, the initial velocity is set to 0, rather than a random vector as previously done. Therefore, when the sketch starts, the object is at rest. To get it moving instead of changing the velocity directly, I’ll update it through the object’s acceleration. According to Algorithm 1, the acceleration should be constant, so I’ll choose a value now:\n    this.acceleration = createVector(-0.001, 0.01);\n\n  This means that for every frame of the animation, the object’s velocity should increase by –0.001\n  pixels in the x-direction and 0.01 pixels in the y-direction. Maybe you’re thinking, “Gosh, those values seem awfully small!” Indeed, they are quite tiny, but that’s by design. Acceleration values accumulate over time in the velocity, about 30 times per second, depending on the sketch’s frame rate. To keep the magnitude of the velocity vector from growing too quickly and spiraling out of control, the acceleration values should remain quite small.\n\nI can also help keep the velocity within a reasonable range by incorporating the p5.Vector function limit(), which puts a cap on the magnitude of a vector:\n    // The <code>limit()</code> function constrains the magnitude of a vector.\n    this.velocity.limit(10);\nThis translates to the following:\n\n  What is the magnitude of velocity? If it’s less than 10, no worries; just leave it as is. If it’s more than 10, however, reduce it to 10!\n\n\n  Exercise 1.4\n  Write the limit() function for the p5.Vector class:\n    limit(max) {\n    if (<span class=\"blank\">this.mag() > </span><span class=\"blank\">max</span>) {\n      <span class=\"blank\">this.normalize()</span>;\n      <span class=\"blank\">this.mult(max)</span>;\n    }\n  }\n\nLet’s take a look at the changes to the Mover class, complete with acceleration and limit().\n\n  Example 1.8: Motion 101 (Velocity and Constant Acceleration)\n  \n    \n    \n  \n\nclass Mover {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // Acceleration is the key!\n    this.acceleration = createVector(-0.001, 0.01);\n    // The variable <code>topSpeed</code> will limit the magnitude of velocity.\n    this.topSpeed = 10;\n  }\n\n  update() {\n    //{!2} Velocity changes by acceleration and is limited by <code>topSpeed</code>.\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }\n\n  // <code>show()</code> is the same.\n  show() {}\n\n  // <code>checkEdges()</code> is the same.\n  checkEdges() {}\n}\nThe net result is that the object falls down and to the left, gradually moving faster and faster until it reaches the maximum velocity.\n\n  Exercise 1.5\n  Create a simulation of an object (think about a vehicle) that accelerates when you press the up arrow and brakes when you press the down arrow.\n  \n    \n      \n      \n    \n  \n\nAlgorithm 2: Random Acceleration\n\nNow on to Acceleration Algorithm 2, a random acceleration. In this case, instead of initializing acceleration in the object’s constructor, I want to randomly set its value inside the update() method. This way, the object will get a different acceleration vector for every frame of the animation:\nupdate() {\n  // The <code>random2D()</code> method returns a unit vector pointing in a random direction.\n  this.acceleration = p5.Vector.random2D();\n  this.velocity.add(this.acceleration);\n  this.velocity.limit(this.topSpeed);\n  this.position.add(this.velocity);\n}\nThe random2D() method produces a normalized vector, meaning it has a random direction, but its magnitude is always 1. To make things interesting, I can try scaling the random vector by a constant value:\n  this.acceleration = p5.Vector.random2D();\n  // Constant\n  <strong>this.acceleration.mult(0.5);</strong>\nOr, for even greater variety, I can scale the acceleration to a random value. In Example 1.9, the acceleration vector has both a random direction and a random magnitude from 0 to 2.\n\n  Example 1.9: Motion 101 (Velocity and Random Acceleration)\n  \n    \n    \n  \n\n  this.acceleration = p5.Vector.random2D();\n  // Random\n  <strong>this.acceleration.mult(random(2));</strong>\nIt’s crucial to understand that acceleration doesn’t merely refer to speeding up or slowing down. Rather, as this example has shown, it refers to any change in velocity—magnitude or direction. Acceleration is used to steer an object, and you’ll see this again and again in future chapters as I begin to code objects that make decisions about how to move.\nYou might also notice that this example is another kind of random walker. A key distinction between what I’m doing here and the previous chapter’s examples, however, lies in what is being randomized. With the traditional random walker, I was directly manipulating the velocity, meaning each step was completely independent of the last. In Example 1.9, the acceleration (the rate of change of velocity) is being randomized, not the velocity itself. This makes the object’s motion dependent on its previous state: the velocity changes incrementally according to the random acceleration. The resulting movement of the object has a kind of continuity and fluidity that the original random walker lacked. The difference may seem subtle, but it fundamentally changes the way the object moves about the canvas.\n\n  Exercise 1.6\n  Referring back to Example 0.6, implement an acceleration calculated with Perlin noise.\n\nStatic vs. Nonstatic Methods\n\nYou might have noticed something a bit odd and unfamiliar in the previous example. The\nrandom2D() method used to create a random unit vector was called on the class name, as in p5.Vector.random2D(), rather than on the current instance of the class, as in this.random2D().\nThis is because random2D() is a static method, meaning it’s associated with the class as a whole rather than the individual objects (that is, the instances of that class).\nStatic methods are rarely needed when you’re writing your own classes (like Walker or Mover), so you may not have encountered them before. They sometimes form an important part of prewritten classes like p5.Vector, however. In fact, Acceleration Algorithm 3 (accelerate toward the mouse) requires further use of this concept, so let’s take a step back and consider the difference between static and nonstatic methods.\nSetting aside vectors for a second, take a look at the following code:\nlet x = 0;\nlet y = 5;\nx = x + y;\nThis is probably what you’re used to, yes? I give x a value of 0, add y to it, and now x is equal to 5. I could write similar code for adding two vectors:\nlet v = createVector(0, 0);\nlet u = createVector(4, 5);\nv.add(u);\nThe vector v has the value of (0, 0), I add the vector u to it, and now v is equal to (4, 5). Makes sense, right?\nNow consider this example:\nlet x = 0;\nlet y = 5;\nlet z = x + y;\nI give x a value of 0, add y to it, and store the result in a new variable z. The value of x doesn’t change here (neither does y)! This may seem like a trivial point, and one that’s quite intuitive when it comes to mathematical operations with simple numbers. However, it’s not so obvious with mathematical operations using p5.Vector objects. Let’s try to rewrite the example with vectors, based on what I’ve covered of the p5.Vector class so far:\nlet v = createVector(0, 0);\nlet u = createVector(4, 5);\n// Don’t be fooled; this is incorrect!\nlet w = v.add(u);\nThis might seem like a good guess, but it’s just not the way the p5.Vector class works. If you look at the definition of add(), you can see why:\nadd(v) {\n  this.x = this.x + v.x;\n  this.y = this.y + v.y;\n}\nThis code has two problems. First, the add() method doesn’t return a new p5.Vector object, and second, add() changes the value of the vector upon which it’s called. To add two vector objects together and return the result as a new vector, I must use the static version of the add() method by calling it on the class name, rather than calling the nonstatic version on a specific object instance.\nHere’s how I might write the static version of add() if I were declaring the class myself:\n// The static version adds two vectors together and assigns the result to a new vector while leaving the original vectors (<code>v</code> and <code>u</code> in the preceding code blocks) intact.\nstatic add(v1, v2) {\n  let v3 = createVector(v1.x + v2.x, v1.y + v2.y);\n  return v3;\n}\nThe key difference here is that the method returns a new vector (v3) created using the sum of the components of v1 and v2. As a result, the method doesn’t make changes to either original vector.\nWhen calling a static method, instead of referencing an object instance, you reference the name of the class. Here’s the right way to implement the vector addition example:\nlet v = createVector(0, 0);\nlet u = createVector(4, 5);\n<s>let w = v.add(u);</s>\n<strong>let w = p5.Vector.add(v, u);</strong>\nThe p5.Vector class has static versions of add(), sub(), mult(), and div(). These static methods allow you to perform generic mathematical operations on vectors without changing the value of one of the input vectors in the process.\n\n  Exercise 1.7\n  Translate the following pseudocode to code, using static or nonstatic functions where appropriate:\n  \n    The vector v equals (1, 5).\n    The vector u equals v multiplied by 2.\n    The vector w equals v minus u.\n    Divide the vector w by 3.\n  \n  let v = <span class=\"blank\">createVector(1, 5)</span>;\nlet u = <span class=\"blank\">p5.Vector.mult</span>(<span class=\"blank\">v, 2</span>);\nlet w = <span class=\"blank\">p5.Vector.sub</span>(<span class=\"blank\">v, u</span>);\n<span class=\"blank\">w.div(3)</span>;\n\nAlgorithm 3: Interactive Motion\nTo finish out this chapter, let’s try something a bit more complex and a great deal more useful. I’ll dynamically calculate an object’s acceleration according to the rule stated in Acceleration Algorithm 3: the object accelerates toward the mouse.\n\n  \n    \n    Figure 1.15: A vector from an object to the mouse position\n  \n\nAnytime you want to calculate a vector based on a rule or formula, you need to compute two attributes: magnitude and direction. I’ll start with direction. I know the acceleration vector should point from the object’s position toward the mouse position (Figure 1.15). Let’s say the object is located at the position vector (x, y), and the mouse is at (mouseX, mouseY).\n\n  \n    \n    Figure 1.16: Calculating an initial acceleration vector by taking the difference of the mouse and position vectors\n  \n\nIn Figure 1.16, you see that the acceleration vector (dx, dy) can be calculated by subtracting the object’s position from the mouse’s position:\n\n  dx = mouseX - x\n  dy = mouseY - y\n\nLet’s implement that by using p5.Vector syntax. Assuming the code will live inside the Mover class and thus have access to the object’s position, I can write this:\nlet mouse = createVector(mouseX, mouseY);\n// Look! I’m using the static reference to <code>sub()</code> because I want a new <code>p5.Vector</code>!\nlet direction = p5.Vector.sub(mouse, this.position);\nI’ve used the static version of sub() to create a new vector direction that points from the mover’s position to the mouse. If the object were to actually accelerate using that vector, however, it would appear instantaneously at the mouse position, since the magnitude of direction is equal to the distance between the object and the mouse. This wouldn’t make for a smooth animation, of course. The next step, therefore, is to decide how quickly the object should accelerate toward the mouse by changing the vector’s magnitude.\nTo set the magnitude (whatever it may be) of the acceleration vector, I must first ______ the vector. That’s right, you said it: normalize! If I can shrink the vector to its unit vector (of length 1), I can easily scale it to any other value, because 1 multiplied by anything equals anything:\n\n//{!1} Any number!\nlet anything = __________________;\ndirection.normalize();\ndirection.mult(anything);\nTo summarize, follow these steps to make the object accelerate toward the mouse:\n\n  Calculate a vector that points from the object to the target position (mouse).\n  Normalize that vector (reducing its length to 1).\n  Scale that vector to an appropriate value (by multiplying it by a value).\n  Assign that vector to acceleration.\n\n\n  I have a confession to make. Normalization and then scaling is such a common vector operation that p5.Vector includes a function that does both, setting the magnitude of a vector to a given value with a single function call. That function is setMag():\n  let anything = ?????\ndir.setMag(anything);\n\nIn this next example, to emphasize the math, I’m going to write the code using normalize() and mult(), but this is likely the last time I’ll do that. You’ll find setMag() in examples going forward.\n\n\n  Example 1.10: Accelerating Toward the Mouse\n  \n    \n    \n  \n\n  update() {\n    let mouse = createVector(mouseX, mouseY);\n    // Step 1: Compute the direction.\n    let dir = p5.Vector.sub(mouse, this.position);\n    // Step 2: Normalize.\n    dir.normalize();\n    // Step 3: Scale.\n    dir.mult(0.2);\n    //{!1} Step 4: Accelerate.\n    this.acceleration = dir;\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }\nYou may be wondering why the circle doesn’t stop when it reaches the target. It’s important to note that the moving object has no knowledge about trying to stop at a destination; it knows only the destination’s position. The object tries to accelerate there at a fixed rate, regardless of how far away it is. This means it will inevitably overshoot the target and have to turn around, again accelerating toward the destination, overshooting it again, and so forth. Stay tuned; in later chapters, I’ll show you how to program an object to arrive at a target (slow down on approach).\n\n  Exercise 1.8\n  Example 1.10 is remarkably close to the concept of gravitational attraction, with the object being attracted to the mouse position. In the example, however, the attraction magnitude is constant, whereas with a real-life gravitational force, the magnitude is inversely proportional to distance: the closer the object is to the attraction point, the faster it accelerates. I’ll cover gravitational attraction in more detail in the next chapter, but for now, try implementing your own version of Example 1.10 with a variable magnitude of acceleration, stronger when it’s either closer or farther away.\n  \n    \n      \n      \n    \n  \n\n\n  The Ecosystem Project\n  Incorporate vectors to further develop and refine the motion of the elements within your ecosystem. Explore how motion can be directed by solely manipulating an object’s acceleration vector.\n  How might you calculate acceleration to emulate certain behaviors—the erratic buzzing\nof a nervous fly, the gentle hops of a bunny, or the slithering of a snake? What role does acceleration play in nature? Consider the way a bird accelerates when taking off or how a fish suddenly changes direction when swimming. Again, how much of a creature’s personality can be shaped by its behavior alone? What is added (or taken away) by incorporating more visual design elements beyond simple shapes?\n  \n    \n    \n  \n\n",
  "htmlContent": "<section data-type=\"chapter\" id=\"section-vectors\">\n<h1 id=\"chapter-1-vectors\">Chapter 1. Vectors</h1>\n<div class=\"chapter-opening-quote\">\n  <blockquote data-type=\"epigraph\">\n    <p>I’m committing crimes with both direction and magnitude.</p>\n    <div class=\"chapter-opening-quote-source\">\n      <p>—Vector, <em>Despicable Me</em></p>\n    </div>\n  </blockquote>\n</div>\n<div class=\"chapter-opening-figure\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_1.jpg\" alt>\n    <figcaption></figcaption>\n  </figure>\n  <h3 id=\"marshall-islands-stick-chart-on-display-at-the-berkeley-art-museum-photo-by-jim-heaphy\">Marshall Islands stick chart on display at the Berkeley Art Museum (photo by Jim Heaphy)</h3>\n  <p>The stick chart is a navigational tool crafted by the indigenous people of the Marshall Islands, located in the central Pacific Ocean. This ancient tool was made by carefully tying together the midribs of coconut fronds. Shell markings on the chart signify the locations of islands in the region. The layout of the fronds and shells serves as a geographical guide, offering an abstract representation of vectors that capture the ocean swell patterns and their directional flow.</p>\n</div>\n<p>This book is all about looking at the world around us and developing ways to simulate it with code. In this first part of the book, I’ll start by looking at basic physics: how an apple falls from a tree, how a pendulum swings in the air, how Earth revolves around the sun, and so on. Absolutely everything contained within the book’s first five chapters requires the use of the most basic building block for programming motion, the <strong>vector</strong>. And so that’s where I’ll begin the story.</p>\n<p>The word <em>vector</em> can mean a lot of things. It’s the name of a New Wave rock band formed in Sacramento, California, in the early 1980s, and the name of a breakfast cereal manufactured by Kellogg’s Canada. In the field of epidemiology, a vector is an organism that transmits infection from one host to another. In the C++ programming language, a vector (<code>std::vector</code>) is an implementation of a dynamically resizable array data structure.</p>\n<p>While all these definitions are worth exploring, they’re not the focus here. Instead, this chapter dives into the <strong>Euclidean vector</strong> (named for the Greek mathematician Euclid), also known as the <strong>geometric vector</strong>. When you see the term <em>vector</em> in this book, you can assume it refers to a Euclidean vector, defined as an entity that has both magnitude and direction.</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_2.png\" alt=\"Figure 1.1: A vector represented as an arrow drawn from point A to point B\">\n    <figcaption>Figure 1.1: A vector represented as an arrow drawn from point A to point B</figcaption>\n  </figure>\n</div>\n<p>A vector is typically drawn as an arrow, as in Figure 1.1. The vector’s direction is indicated by where the arrow is pointing, and its magnitude by the length of the arrow.</p>\n<p>The vector in Figure 1.1 is drawn as an arrow from point A to point B. It serves as an instruction for how to travel from A to B.</p>\n<h2 id=\"the-point-of-vectors\">The Point of Vectors</h2>\n<div data-type=\"video-link\" data-title=\"What is a Vector?\" href=\"https://www.youtube.com/watch?v=bKEaK7WNLzM&#x26;embeds_referring_euri=https://thecodingtrain.com/&#x26;embeds_referring_origin=https://thecodingtrain.com&#x26;source_ve_path=OTY3MTQ&#x26;feature=emb_imp_woyt\"></div>\n<p>Before diving into more details about vectors, I’d like to create a p5.js example that demonstrates why you should care about vectors in the first place. If you’ve watched any beginner p5.js tutorials, read any introductory p5.js textbooks, or taken an introduction to creative coding course (and hopefully you’ve done one of these things to help prepare you for this book!), you probably, at one point or another, learned how to write a bouncing ball sketch.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-11-bouncing-ball-with-no-vectors\">Example 1.1: Bouncing Ball with No Vectors</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/oadKdOndU\" data-example-path=\"examples/01_vectors/example_1_1_bouncing_ball_with_no_vectors\"><img src=\"/content/examples/01_vectors/example_1_1_bouncing_ball_with_no_vectors/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Variables for position and speed of ball\nlet x = 100;\nlet y = 100;\nlet xspeed = 2.5;\nlet yspeed = 2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  // Move the ball according to its speed.\n  x = x + xspeed;\n  y = y + yspeed;\n  // Check for bouncing.\n  if (x > width || x &#x3C; 0) {\n    xspeed = xspeed * -1;\n  }\n  if (y > height || y &#x3C; 0) {\n    yspeed = yspeed * -1;\n  }\n  // Draw the ball at the position (<em>x</em>, <em>y</em>).\n  stroke(0);\n  fill(127);\n  circle(x, y, 48);\n}</pre>\n<div class=\"avoid-break\">\n  <p>In this example, there’s a flat, 2D world—a blank canvas—with a circular shape (a “ball”) traveling around. This ball has properties like position and speed that are represented in the code as variables:</p>\n  <table>\n    <thead>\n      <tr>\n        <th style=\"width: 200px;\">Property</th>\n        <th>Variable Names</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>Position</td>\n        <td><code>x</code> and <code>y</code></td>\n      </tr>\n      <tr>\n        <td>Speed</td>\n        <td><code>xspeed</code> and <code>yspeed</code></td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<p>In a more sophisticated sketch, you might have many more variables representing other properties of the ball and its environment:</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"width: 200px;\">Property</th>\n      <th>Variable Names</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Acceleration</td>\n      <td><code>xacceleration</code> and <code>yacceleration</code></td>\n    </tr>\n    <tr>\n      <td>Target position</td>\n      <td><code>xtarget</code> and <code>ytarget</code></td>\n    </tr>\n    <tr>\n      <td>Wind</td>\n      <td><code>xwind</code> and <code>ywind</code></td>\n    </tr>\n    <tr>\n      <td>Friction</td>\n      <td><code>xfriction</code> and <code>yfriction</code></td>\n    </tr>\n  </tbody>\n</table>\n<p>You might notice that for every concept in this world (wind, position, acceleration, and the like), there are two variables. And this is only a 2D world. In a three-dimensional (3D) world, you’d need three variables for each property: <code>x</code>, <code>y</code>, and <code>z</code> for position; <code>xspeed</code>, <code>yspeed</code>, and <code>zspeed</code> for speed; and so on. Wouldn’t it be nice to simplify the code to use fewer variables? Instead of starting the program with something like this</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x;\nlet y;\nlet xspeed;\nlet yspeed;</pre>\n<p>you’d be able to start it with something like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let position;\nlet speed;</pre>\n<p>Thinking of the ball’s properties as vectors instead of a loose collection of separate values will allow you to do just that.</p>\n<p>Taking this first step toward using vectors won’t let you do anything new or magically turn a p5.js sketch into a full-on physics simulation. However, using vectors will help organize your code and provide a set of methods for common mathematical operations you’ll need over and over and over again while programming motion.</p>\n<p>As an introduction to vectors, I’m going to stick to two dimensions for quite some time (at least the first several chapters). All these examples can be fairly easily extended to three dimensions (and the class I’ll use, <code>p5.Vector</code>, allows for three dimensions). However, for the purposes of learning the fundamentals, the added complexity of the third dimension would be a distraction.</p>\n<h2 id=\"vectors-in-p5js\">Vectors in p5.js</h2>\n<p>Think of a vector as the difference between two points, or as instructions for walking from one point to another. For example, Figure 1.2 shows some vectors and possible interpretations of them.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_3.png\" alt=\"Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions for walking in north, south, east, or west directions\">\n  <figcaption>Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions for walking in north, south, east, or west directions</figcaption>\n</figure>\n<p>These vectors could be thought of in the following way:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Vector</th>\n      <th>Instructions</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>(–15, 3)</td>\n      <td>Walk 15 steps west; turn and walk 3 steps north.</td>\n    </tr>\n    <tr>\n      <td>(3, 4)</td>\n      <td>Walk 3 steps east; turn and walk 4 steps north.</td>\n    </tr>\n    <tr>\n      <td>(2, –1)</td>\n      <td>Walk 2 steps east; turn and walk 1 step south.</td>\n    </tr>\n  </tbody>\n</table>\n<p>You’ve probably already thought this way when programming motion. For every frame of animation (a single cycle through a p5.js <code>draw()</code> loop), you instruct each object to reposition itself to a new spot a certain number of pixels away horizontally and a certain number of pixels away vertically. This instruction is essentially a vector, as in Figure 1.3; it has both magnitude (how far away did you travel?) and direction (which way did you go?).</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_4.png\" alt=\"Figure 1.3: A vector showing the number of horizontal and vertical steps to go from a position to a new position\">\n  <figcaption>Figure 1.3: A vector showing the number of horizontal and vertical steps to go from a position to a new position</figcaption>\n</figure>\n<p>The vector sets the object’s <strong>velocity</strong>, defined as the rate of change of the object’s position with respect to time. In other words, the velocity vector determines the object’s new position for every frame of the animation, according to this basic algorithm for motion: <em>the new position is equal to the result of applying the velocity to the current position</em>.</p>\n<p>If velocity is a vector (the difference between two points), what about position? Is it a vector too? Technically, you could argue that position is not a vector, since it’s not describing how to move from one point to another; it’s describing a single point in space. Nevertheless, another way to describe a position is as the path taken from the origin—point (0, 0)—to the current point. When you think of position in this way, it becomes a vector, just like velocity, as in Figure 1.4.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_5.png\" alt=\"Figure 1.4: A computer graphics window with (0, 0) in the top left, showing a position vector and a velocity vector\">\n  <figcaption>Figure 1.4: A computer graphics window with (0, 0) in the top left, showing a position vector and a velocity vector</figcaption>\n</figure>\n<p>In Figure 1.4, the vectors are placed on a computer graphics canvas. Unlike in Figure 1.2, the origin point (0, 0) isn’t at the center; it’s at the top-left corner. And instead of north, south, east, and west, there are positive and negative directions along the x- and y-axes (with y pointing down in the positive direction).</p>\n<p>Let’s examine the underlying data for both position and velocity. In the bouncing ball example, I originally had the following variables:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Property</th>\n      <th>Variable Names</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Position</td>\n      <td><code>x</code>, <code>y</code></td>\n    </tr>\n    <tr>\n      <td>Velocity</td>\n      <td><code>xspeed</code>, <code>yspeed</code></td>\n    </tr>\n  </tbody>\n</table>\n<p>Now I’ll treat position and velocity as vectors instead, each represented by an object with <code>x</code> and <code>y</code> attributes. If I were to write a <code>Vector</code> class myself, I’d start with something like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}</pre>\n<p>Notice that this class is designed to store the same data as before—two floating-point numbers per vector, an <code>x</code> value and a <code>y</code> value. At its core, a <code>Vector</code> object is just a convenient way to store two values (or three, as you’ll see in 3D examples) under one name.</p>\n<p>As it happens, p5.js already has a built-in <code>p5.Vector</code> class, so I don’t need to write one myself. And so this</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x = 100;\nlet y = 100;\nlet xspeed = 1;\nlet yspeed = 3.3;</pre>\n<p>becomes this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let position = createVector(100, 100);\nlet velocity = createVector(1, 3.3);</pre>\n<p>Notice that the <code>position</code> and <code>velocity</code> vector objects aren’t created as you might expect,<br>by invoking a constructor function. Instead of writing <code>new p5.Vector(x, y)</code>, I’ve called <code>createVector(x, y)</code>. The <code>createVector()</code> function is included in p5.js as a helper function to<br>take care of details behind the scenes upon creation of the vector. Except in special circumstances, you should always create <code>p5.Vector</code> objects with <code>createVector()</code>. I should note that p5.js functions such as <code>createVector()</code> can’t be executed outside of <code>setup()</code> or <code>draw()</code>, since the library won’t yet be loaded. I’ll demonstrate how to address this in Example 1.2.</p>\n<p>Now that I have two vector objects (<code>position</code> and <code>velocity</code>), I’m ready to implement the vector-based algorithm for motion: <strong>position = position + velocity</strong>. In Example 1.1, without vectors, the code reads as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Add each speed to each position.\nx = x + xspeed;\ny = y + yspeed;</pre>\n<p>In an ideal world, I would be able to rewrite this as shown here:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Add the velocity vector to the position vector.\nposition = position + velocity;</pre>\n<p>In JavaScript, however, the addition operator <code>+</code> is reserved for primitive values (integers, floats, and the like). JavaScript doesn’t know how to add two <code>p5.Vector</code> objects together any more than it knows how to add two <code>p5.Font</code> objects or <code>p5.Image</code> objects. Fortunately, the <code>p5.Vector</code> class includes methods for common mathematical operations.</p>\n<h2 id=\"vector-addition\">Vector Addition</h2>\n<div data-type=\"video-link\" data-title=\"Vector Math\" href=\"https://www.youtube.com/watch?v=Rob0pbE7kks\"></div>\n<p>Before I continue working with the <code>p5.Vector</code> class and the <code>add()</code> method, let’s examine vector addition by using the notation found in math and physics textbooks. Vectors are typically written either in boldface type or with an arrow on top. For the purposes of this book, to distinguish a <strong>vector</strong> (with magnitude and direction) from a <strong>scalar</strong> (a single value, such as an integer or a floating-point number), I’ll use the arrow notation:</p>\n<ul>\n  <li>Vector: <span data-type=\"equation\">\\vec{v}</span></li>\n  <li>Scalar: <span data-type=\"equation\">{x}</span></li>\n</ul>\n<p>Let’s say I have the two vectors shown in Figure 1.5.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_6.png\" alt=\"Figure 1.5: Two vectors  \nvec{u} and vec{v} depicted as triangles\">\n  <figcaption>Figure 1.5: Two vectors <span data-type=\"equation\">\\vec{u}</span> and <span data-type=\"equation\">\\vec{v}</span> depicted as triangles</figcaption>\n</figure>\n<p>Each vector has two <strong>components</strong>, an <em>x</em> and a <em>y</em>. To add the two vectors together, add both x-components and y-components to create a new vector, as in Figure 1.6.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_7.png\" alt=\"Figure 1.6: Adding vectors by combining the x- and y-components\">\n  <figcaption>Figure 1.6: Adding vectors by combining the x- and y-components</figcaption>\n</figure>\n<p>In other words, <span data-type=\"equation\">\\vec{w} = \\vec{u} + \\vec{v}</span> can be written as follows:</p>\n<div data-type=\"equation\">w_x = u_x + v_x</div>\n<div data-type=\"equation\">w_y = u_y + v_y</div>\n<p>Then, replacing <span data-type=\"equation\">\\vec{u}</span> and <span data-type=\"equation\">\\vec{v}</span> with their values from Figure 1.6, you get this:</p>\n<div data-type=\"equation\">w_x = 5 + 3 = 8</div>\n<div data-type=\"equation\">w_y = 2 + 4 = 6</div>\n<p>Finally, write the result as a vector:</p>\n<div data-type=\"equation\">\\vec{w} = (8,6)</div>\n<div data-type=\"note\">\n  <h3 id=\"addition-properties-with-vectors\">Addition Properties with Vectors</h3>\n  <p>Addition with vectors follows the same algebraic rules as with real numbers.</p>\n  <p>The commutative rule: <span data-type=\"equation\">\\vec{u} + \\vec{v} = \\vec{v} + \\vec{u}</span></p>\n  <p>The associative rule: <span data-type=\"equation\">\\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w}</span></p>\n  <p>Fancy terminology and symbols aside, these rules boil down to quite a simple concept: the result is the same no matter the order in which the vectors are added. Replace the vectors with regular numbers (scalars), and these rules are easy to see:</p>\n  <p>Commutative: <span data-type=\"equation\">3 + 2 = 2 + 3</span></p>\n  <p>Associative: <span data-type=\"equation\">(3 + 2) + 1 = 3 + (2 + 1)</span></p>\n</div>\n<p>Now that I’ve covered the theory behind adding two vectors together, I can turn to adding vector objects in p5.js. Imagine again that I’m creating my own <code>Vector</code> class. I could give it a function called <code>add()</code> that takes another <code>Vector</code> object as its argument:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Vector {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  //{!4} New! A function to add another vector to this vector. Add the x-components and the y-components separately.\n  <strong>add(v) {\n    this.x = this.x + v.x;\n    this.y = this.y + v.y;\n  }</strong>\n}</pre>\n<p>The function looks up the x- and y-components of the two vectors and adds them separately. This is exactly how the built-in <code>p5.Vector</code> class’s <code>add()</code> method is written too. Knowing how it works, I can now return to the bouncing ball example with its <strong>position + velocity</strong> algorithm and implement vector addition:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// This does not work!\n<s>position = position + velocity;</s>\n// Add the velocity to the position.\nposition.add(velocity);</pre>\n<p>Now you have what you need to rewrite the bouncing ball example with vectors.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-12-bouncing-ball-with-vectors\">Example 1.2: Bouncing Ball with Vectors!</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/qU5oPJijX\" data-example-path=\"examples/01_vectors/example_1_2_bouncing_ball_with_vectors\"><img src=\"/content/examples/01_vectors/example_1_2_bouncing_ball_with_vectors/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Instead of a bunch of floats, you now have just two variables.\n<strong>let position;\nlet velocity;</strong>\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Note that <code>createVector()</code> has to be called inside <code>setup()</code>.\n  <strong>position = createVector(100, 100);\n  velocity = createVector(2.5, 2);</strong>\n}\n\nfunction draw() {\n  background(255);\n  <strong>position.add(velocity);</strong>\n\n  // You still sometimes need to refer to the individual components of a <code>p5.Vector</code> and can do so using the dot syntax: <code>position.x</code>, <code>velocity.y</code>, and so forth.\n  <strong>if (position.x > width || position.x &#x3C; 0) {\n    velocity.x = velocity.x * -1;\n  }\n  if (position.y > height || position.y &#x3C; 0) {\n    velocity.y = velocity.y * -1;\n  }</strong>\n\n  stroke(0);\n  fill(127);\n  circle(position.x, position.y, 48);\n}</pre>\n<p>At this stage, you might feel somewhat disappointed. After all, these changes may appear to have made the code more complicated than the original version. While this is a perfectly reasonable and valid critique, it’s important to understand that the power of programming with vectors hasn’t been fully realized just yet. Looking at a bouncing ball and only implementing vector addition is just the first step. As I move forward into a more complex world of multiple objects and multiple <em>forces</em> (which I’ll introduce in Chapter 2) acting on those objects, the benefits of vectors will become more apparent.</p>\n<p>I should, however, note an important aspect of the transition to programming with vectors. Even though I’m using <code>p5.Vector</code> objects to encapsulate two values—the <code>x</code> and <code>y</code> of the ball’s position or the <code>x</code> and <code>y</code> of the ball’s velocity—under a single variable name, I’ll still often need to refer to the x- and y-components of each vector individually.</p>\n<p>The <code>circle()</code> function doesn’t allow for a <code>p5.Vector</code> object as an argument. A circle can be drawn with only two scalar values, an x-coordinate and a y-coordinate. And so I must dig into the <code>p5.Vector</code> object and pull out the x- and y-components by using object-oriented dot syntax:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\"><s>circle(position, 48);</s>\ncircle(position.x, position.y, 48);</pre>\n<p>The same issue arises when testing whether the circle has reached the edge of the window. In this case, I need to access the individual components of both vectors, <code>position</code> and <code>velocity</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">if ((position.x > width) || (position.x &#x3C; 0)) {\n  velocity.x = velocity.x * -1;\n}</pre>\n<p>It may not always be obvious when to directly access an object’s properties versus when to reference the object as a whole or use one of its methods. The goal of this chapter (and most of this book) is to help you distinguish between these scenarios by providing a variety of examples and use cases.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-11\">Exercise 1.1</h3>\n  <p>Take one of the walker examples from <a href=\"/random#section-random\">Chapter 0</a> and convert it to use vectors.</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-12\">Exercise 1.2</h3>\n  <p>Find something else you’ve previously made in p5.js using separate <code>x</code> and <code>y</code> variables, and use vectors instead.</p>\n</div>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-13\">Exercise 1.3</h3>\n  <p>Extend Example 1.2 into 3D. Can you get a sphere to bounce around a box?</p>\n  <div class=\"web-only solution\">\n    <figure>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/rJfGWzxlI\" data-example-path=\"examples/01_vectors/exercise_1_3_solution_3_d_bouncing_ball\"><img src=\"/content/examples/01_vectors/exercise_1_3_solution_3_d_bouncing_ball/screenshot.png\"></div>\n      <figcaption></figcaption>\n    </figure>\n  </div>\n</div>\n<h2 id=\"more-vector-math\">More Vector Math</h2>\n<p>Addition was really just the first step. Many mathematical operations are commonly used with<br>vectors. Here’s a comprehensive table of the operations available as methods in the <code>p5.Vector</code> class. Remember, these are not stand-alone functions, but rather methods associated with the <code>p5.Vector</code> class. When you see the word <em>this</em> in the following table, it refers to the specific vector the method is operating on.</p>\n<table>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>Task</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n        <pre><code>add()</code></pre>\n      </td>\n      <td>Adds a vector to this vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>sub()</code></pre>\n      </td>\n      <td>Subtracts a vector from this vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>mult()</code></pre>\n      </td>\n      <td>Scales this vector with multiplication</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>div()</code></pre>\n      </td>\n      <td>Scales this vector with division</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>mag()</code></pre>\n      </td>\n      <td>Returns the magnitude of this vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>setMag()</code></pre>\n      </td>\n      <td>Sets the magnitude of this vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>normalize()</code></pre>\n      </td>\n      <td>Normalizes this vector to a unit length of 1</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>limit()</code></pre>\n      </td>\n      <td>Limits the magnitude of this vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>heading()</code></pre>\n      </td>\n      <td>Returns the 2D heading of this vector expressed as an angle</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>rotate()</code></pre>\n      </td>\n      <td>Rotates this 2D vector by an angle</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>lerp()</code></pre>\n      </td>\n      <td>Linear interpolates to another vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>dist()</code></pre>\n      </td>\n      <td>Returns the Euclidean distance between two vectors (considered as points)</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>angleBetween()</code></pre>\n      </td>\n      <td>Finds the angle between two vectors</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>dot()</code></pre>\n      </td>\n      <td>Returns the dot product of two vectors</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>cross()</code></pre>\n      </td>\n      <td>Returns the cross product of two vectors (relevant only in three dimensions)</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>random2D()</code></pre>\n      </td>\n      <td>Returns a random 2D vector</td>\n    </tr>\n    <tr>\n      <td>\n        <pre><code>random3D()</code></pre>\n      </td>\n      <td>Returns a random 3D vector</td>\n    </tr>\n  </tbody>\n</table>\n<p>I’ll go through a few of the key methods now. As the examples get more sophisticated in later chapters, I’ll continue to reveal more details.</p>\n<h3 id=\"vector-subtraction\">Vector Subtraction</h3>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_8.png\" alt=\"Figure 1.7: The relationship between vec{v} and -vec{v} \">\n    <figcaption>Figure 1.7: The relationship between <span data-type=\"equation\">\\vec{v}</span> and <span data-type=\"equation\">-\\vec{v}</span> </figcaption>\n  </figure>\n</div>\n<p>Having already covered addition, I’ll now turn to subtraction. This one’s not so bad; just take the plus sign and replace it with a minus! Before tackling subtraction itself, however, consider what it means for a vector <span data-type=\"equation\">\\vec{v}</span> to become <span data-type=\"equation\">-\\vec{v}</span>. The negative version of the scalar 3 is –3. A negative vector is similar: the polarity of each of the vector’s components is inverted. So if <span data-type=\"equation\">\\vec{v}</span> has the components (<em>x</em>, <em>y</em>), then <span data-type=\"equation\">-\\vec{v}</span> is (–<em>x</em>, –<em>y</em>). Visually, this results in an arrow of the same length as the original vector pointing in the opposite direction, as depicted in Figure 1.7.</p>\n<p>Subtraction, then, is the same as addition, only with the second vector in the equation treated as a negative version of itself:</p>\n<div data-type=\"equation\">\\vec{u} - \\vec{v} = \\vec{u} + -\\vec{v}</div>\n<p>Just as vectors are added by placing them “tip to tail”—that is, aligning the tip (or endpoint) of one vector with the tail (or start point) of the next—vectors are subtracted by reversing the direction of the second vector and placing it at the end of the first, as in Figure 1.8.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_9.png\" alt=\"Figure 1.8: Vector subtraction places one vector at the end of another, but pointing in the opposite direction.\">\n  <figcaption>Figure 1.8: Vector subtraction places one vector at the end of another, but pointing in the opposite direction.</figcaption>\n</figure>\n<p>To actually solve the subtraction, take the difference of the vectors’ components. That is, <span data-type=\"equation\">\\vec{w} = \\vec{u} - \\vec{v}</span> can be written as shown here:</p>\n<div data-type=\"equation\">w_x = u_x - v_x</div>\n<div data-type=\"equation\">w_y = u_y - v_y</div>\n<p>Inside <code>p5.Vector</code>, the code reads as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">sub(v) {\n  this.x = this.x - v.x;\n  this.y = this.y - v.y;\n}</pre>\n<p>The following example demonstrates vector subtraction by taking the difference between two points (which are treated as vectors): the mouse position and the center of the window.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-13-vector-subtraction\">Example 1.3: Vector Subtraction</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/HtXiElQbC\" data-example-path=\"examples/01_vectors/example_1_3_vector_subtraction\"><img src=\"/content/examples/01_vectors/example_1_3_vector_subtraction/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n  // Two vectors, one for the mouse location and one for the center of the window\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  // Draw the original two vectors.\n  stroke(200);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n  line(0, 0, center.x, center.y);\n  // Vector subtraction!\n  mouse.sub(center);\n  // Draw a line to represent the result of subtraction.\n  // Notice that I move the origin with <code>translate()</code> to place the vector.\n  stroke(0);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}</pre>\n<p>Note the use of <code>translate()</code> to visualize the resulting vector as a line from the center <code>(width / 2,</code><br><code>height / 2)</code> to the mouse. Vector subtraction is its own kind of translation, moving the “origin” of a position vector. Here, by subtracting the center vector from the mouse vector, I’m effectively moving the starting point of the resulting vector to the center of the canvas. Therefore, I also need to move the origin by using <code>translate()</code>. Without this, the line would be drawn from the top-left corner, and the visual connection wouldn’t be as clear.</p>\n<h3 id=\"vector-multiplication-and-division\">Vector Multiplication and Division</h3>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_10.png\" alt=\"Figure 1.9: Scaling a vector with multiplication\">\n    <figcaption>Figure 1.9: Scaling a vector with multiplication</figcaption>\n  </figure>\n</div>\n<p>Moving on to multiplication, you have to think a bit differently. Multiplying a vector typically refers to the process of <strong>scaling</strong> a vector. If I want to scale a vector to twice its size or one-third of its size, while leaving its direction the same, I would say, “Multiply the vector by 2” or “Multiply the vector by 1/3.” Unlike with addition and subtraction, I’m multiplying the vector by a scalar (a single number), not by another vector. Figure 1.9 illustrates how to scale a vector by a factor of 3.</p>\n<p>To scale a vector, multiply each component (<em>x</em> and <em>y</em>) by a scalar. That is, <span data-type=\"equation\">\\vec{w} = \\vec{u} \\times n</span> can be written as shown here:</p>\n<div data-type=\"equation\">w_x = u_x \\times n</div>\n<div data-type=\"equation\">w_y = u_y \\times n</div>\n<p>As an example, say <span data-type=\"equation\">\\vec{u} = (-3, 7)</span> and <span data-type=\"equation\">n = 3</span>. You can calculate <span data-type=\"equation\">\\vec{w} = \\vec{u} \\times n</span> as follows:</p>\n<div data-type=\"equation\">w_x = -3 \\times 3</div>\n<div data-type=\"equation\">w_y = 7 \\times 3</div>\n<div data-type=\"equation\">\\vec{w} = (-9,21)</div>\n<p>This is exactly how the <code>mult()</code> function inside the <code>p5.Vector</code> class works:</p>\n<div class=\"avoid-break\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">mult(n) {\n  // The components of the vector are multiplied by a number.\n  this.x = this.x * n;\n  this.y = this.y * n;\n}</pre>\n</div>\n<p>Implementing multiplication in code is as simple as the following:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let u = createVector(-3, 7);\n// This <code>p5.Vector</code> is now three times the size and is equal to (–9, 21). See Figure 1.9.\nu.mult(3);</pre>\n<p>Example 1.4 illustrates vector multiplication by drawing a line between the mouse and the center of the canvas, as in the previous example, and then scaling that line by 0.5.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-14-multiplying-a-vector\">Example 1.4: Multiplying a Vector</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/VQfwqpDlv\" data-example-path=\"examples/01_vectors/example_1_4_vector_multiplication\"><img src=\"/content/examples/01_vectors/example_1_4_vector_multiplication/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  strokeWeight(2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!1} Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).\n  mouse.mult(0.5);\n  stroke(0);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n}</pre>\n<p>The resulting vector is half its original size. Rather than multiplying the vector by 0.5, I could achieve the same effect by dividing the vector by 2, as in Figure 1.10.</p>\n<figure>\n  <img src=\"/content/images/01_vectors/01_vectors_11.png\" alt=\"Figure 1.10: Scaling a vector with division\">\n  <figcaption>Figure 1.10: Scaling a vector with division</figcaption>\n</figure>\n<p>Vector division, then, works just like vector multiplication—just replace the multiplication sign (<code>*</code>) with the division sign (<code>/</code>). Here’s how the <code>p5.Vector</code> class implements the <code>div()</code> function:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">div(n) {\n  this.x = this.x / n;\n  this.y = this.y / n;\n}</pre>\n<p>And here’s how to use the <code>div()</code> function in a sketch:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let u = createVector(8, -4);\n// Dividing a vector!  The vector is now half its original size (divided by 2).\nu.div(2);</pre>\n<p>This takes the vector <code>u</code> and divides it by 2.</p>\n<div data-type=\"note\">\n  <h3 id=\"more-number-properties-with-vectors\">More Number Properties with Vectors</h3>\n  <p>As with addition, basic algebraic rules of multiplication apply to vectors.</p>\n  <p>The associative rule: <span data-type=\"equation\">(n \\times m) \\times \\vec{v} = n \\times (m \\times \\vec{v})</span></p>\n  <p>The distributive rule with two scalars, one vector: <span data-type=\"equation\">(n + m) \\times \\vec{v} = (n \\times \\vec{v}) + (m \\times \\vec{v})</span></p>\n  <p>The distributive rule with two vectors, one scalar: <span data-type=\"equation\">(\\vec{u} + \\vec{v}) \\times n = (\\vec{u} \\times n) + (\\vec{v} \\times n)</span></p>\n</div>\n<h2 id=\"vector-magnitude\">Vector Magnitude</h2>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_12.png\" alt=\"Figure 1.11: The length, or magnitude, of a vector vec{v} is often written as lVertvec{v}\rVert.\">\n    <figcaption>Figure 1.11: The length, or magnitude, of a vector <span data-type=\"equation\">\\vec{v}</span> is often written as <span data-type=\"equation\">\\lVert\\vec{v}\\rVert</span>.</figcaption>\n  </figure>\n</div>\n<p>Multiplication and division, as just described, alter the length of a vector without affecting its direction. Perhaps you’re wondering, “Okay, so how do I know what the length of a vector is? I know the vector’s components (<em>x</em> and <em>y</em>), but how long (in pixels) is the actual arrow?” Understanding how to calculate the length of a vector, also known as its <strong>magnitude</strong>, is incredibly useful and important.</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_13.png\" alt=\"Figure 1.12: The Pythagorean theorem calculates the length of a vector by using its components.\">\n    <figcaption>Figure 1.12: The Pythagorean theorem calculates the length of a vector by using its components.</figcaption>\n  </figure>\n</div>\n<p>Notice in Figure 1.11 that the vector, drawn as an arrow and two components (<em>x</em> and <em>y</em>), creates a right triangle. The sides are the components, and the hypotenuse is the arrow. We’re lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras discovered a lovely formula that describes the relationship between the sides and hypotenuse of a right triangle. This formula, the <strong>Pythagorean theorem</strong>, is <span data-type=\"equation\">a^2 + b^2 = c^2</span> (see Figure 1.12).</p>\n<p>Armed with this formula, we can now compute the magnitude of <span data-type=\"equation\">\\vec{v}</span> as follows:</p>\n<div data-type=\"equation\">||\\vec{v}||=\\sqrt{v_x * v_x + v_y * v_y}</div>\n<p>In the <code>p5.Vector</code> class, the <code>mag()</code> function is defined using the same formula:</p>\n<div class=\"avoid-break\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">mag() {\n  return sqrt(this.x * this.x + this.y * this.y);\n}</pre>\n</div>\n<p>The sketch in the next example calculates the magnitude of the vector between the mouse and the center of the canvas, and visualizes it as a rectangle drawn across the top of the window.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-15-vector-magnitude\">Example 1.5: Vector Magnitude</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/rld_CtioUU\" data-example-path=\"examples/01_vectors/example_1_5_vector_magnitude\"><img src=\"/content/examples/01_vectors/example_1_5_vector_magnitude/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n  //{!3} The magnitude (that is, length) of a vector can be accessed via the <code>mag()</code> method.  Here it is used as the width of a rectangle drawn at the top of the window.\n  let m = mouse.mag();\n  fill(0);\n  rect(0, 0, m, 10);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}</pre>\n<p>Notice that the magnitude (length) of a vector is always positive, even if the vector’s components are negative.</p>\n<h2 id=\"normalizing-vectors\">Normalizing Vectors</h2>\n<div data-type=\"video-link\" data-title=\"A Unit Vector\" href=\"https://www.youtube.com/watch?v=ttz05d8DSOs\"></div>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_14.png\" alt=\"Figure 1.13: When a vector is normalized, it points in the same direction but has been resized to a unit length of 1.\">\n    <figcaption>Figure 1.13: When a vector is normalized, it points in the same direction but has been resized to a unit length of 1.</figcaption>\n  </figure>\n</div>\n<p>Calculating the magnitude of a vector is only the beginning. It opens the door to many possibilities, the first of which is <strong>normalization</strong> (Figure 1.13). This is the process of making something standard or, well . . . normal. In the case of vectors, the convention is that a standard vector has a length of 1. To normalize a vector, therefore, is to take a vector of any length and change its length to 1, without changing its direction. That normalized vector is then called a <strong>unit vector</strong>.</p>\n<p>A unit vector describes a vector’s direction without regard to its length. You’ll see this come in especially handy once you start to work with forces in Chapter 2.</p>\n<p>For any given vector <span data-type=\"equation\">\\vec{u}</span>, its unit vector (written as <span data-type=\"equation\">\\hat{u}</span>) is calculated as follows:</p>\n<div data-type=\"equation\">\\hat{u} = \\frac{\\vec{u}}{||\\vec{u}||}</div>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_15.png\" alt=\"Figure 1.14: To normalize a vector, its components are divided by its magnitude.\">\n    <figcaption>Figure 1.14: To normalize a vector, its components are divided by its magnitude.</figcaption>\n  </figure>\n</div>\n<p>In other words, to normalize a vector, divide each component by the vector’s magnitude. To see why this works, consider a vector (4, 3), which has a magnitude of 5 (see Figure 1.14). Once normalized, the vector will have a magnitude of 1. Thinking of the vector as a right triangle, normalization shrinks the hypotenuse by dividing by 5 (since 5/5 = 1). In that process, each side shrinks as well, also by a factor of 5. The side lengths go from 4 and 3 to 4/5 and 3/5, respectively.</p>\n<p>In the <code>p5.Vector</code> class, the normalization method is written as follows:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">normalize() {\n  let m = this.mag();\n  this.div(m);\n}</pre>\n<p>Of course, there’s one small issue. What if the magnitude of the vector is 0? You can’t divide by 0! Some quick error checking, shown next, fixes that right up.</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">normalize() {\n  let m = this.mag();\n  if (m > 0) {\n    this.div(m);\n  }\n}</pre>\n<p>This sketch uses normalization to give the vector between the mouse and the center of the canvas a fixed length, regardless of the actual magnitude of the original vector.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-16-normalizing-a-vector\">Example 1.6: Normalizing a Vector</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/5dWkegAID\" data-example-path=\"examples/01_vectors/example_1_6_vector_normalize\"><img src=\"/content/examples/01_vectors/example_1_6_vector_normalize/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">function draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!2} In this example, after the vector is normalized, it’s multiplied by 50. Note that no matter where the mouse is, the vector always has the same length (50) because of the normalization process.\n  mouse.normalize();\n  mouse.mult(50);\n  stroke(0);\n  strokeWeight(8);\n  line(0, 0, mouse.x, mouse.y);\n}</pre>\n<p>Notice that I’ve multiplied the <code>mouse</code> vector by 50 after normalizing it to 1. Normalization is often the first step in creating a vector of a specific length, even if the desired length is something other than 1. You’ll see more of this later in the chapter.</p>\n<p>All this vector math stuff sounds like something you should know about, but why? How will it help you write code? Patience. It’ll take some time before the awesomeness of using <code>p5.Vector</code> fully comes to light. This is a fairly common occurrence when learning a new data structure. For example, when you first learn about arrays, it might seem like more work to use an array than to have several variables stand for multiple things. That plan quickly breaks down when you need 100, 1,000, or 10,000 things, however.</p>\n<p>The same can be true for vectors. What might seem like more work now will pay off later, and quite nicely. And you don’t have to wait too long, as your reward will come in the next chapter. For now, however, I’ll focus on <em>how</em> vectors work, and on how working with them provides a different way to think about motion.</p>\n<h2 id=\"motion-with-vectors\">Motion with Vectors</h2>\n<p>What does it mean to program motion by using vectors? You got a taste of it in Example 1.2, the bouncing ball. The circle onscreen has a position (its location at any given moment) as well as a velocity (instructions for how it should move from one moment to the next). Velocity is added to position:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">position.add(velocity);</pre>\n<p>Then the object is drawn at the new position:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">circle(position.x, position.y, 48);</pre>\n<p>Together, these steps are Motion 101:</p>\n<ol>\n  <li>Add the velocity to the position.</li>\n  <li>Draw the object at the position.</li>\n</ol>\n<p>In the bouncing ball example, all this code happened within <code>setup()</code> and <code>draw()</code>. What I want to do now is move toward encapsulating all the logic for an object’s motion inside a <strong>class</strong>. This way, I can create a foundation for programming moving objects that I can easily reuse again and again. (See “<a href=\"/random#the-random-walker-class\" class=\"page-reference\">The Random Walker Class”</a> for a brief review of OOP basics.)</p>\n<p>To start, I’m going to create a generic <code>Mover</code> class that will describe a shape moving around the canvas. For that, I must consider the following two questions:</p>\n<ol>\n  <li>What data does a mover have?</li>\n  <li>What functionality does a mover have?</li>\n</ol>\n<p>The Motion 101 algorithm answers both of these questions. First, a <code>Mover</code> object has two pieces of data, <code>position</code> and <code>velocity</code>, which are both <code>p5.Vector</code> objects. These are initialized in the object’s constructor. In this case, I’ll arbitrarily decide to initialize the <code>Mover</code> object by giving it a random position and velocity. Note the use of <code>this</code> with all variables that are part of the <code>Mover</code> object:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2,2), random(-2, 2));\n  }</pre>\n</div>\n<p>The functionality follows suit. The <code>Mover</code> object needs to move (by applying its velocity to its position) and needs to be visible. I’ll implement these needs as functions named <code>update()</code> and <code>show()</code>. I’ll put all the motion logic code in <code>update()</code> and draw the object in <code>show()</code>:</p>\n<div class=\"snip-above snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    // The mover moves.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // The mover is drawn as a circle.\n    circle(this.position.x, this.position.y, 48);\n  }</pre>\n</div>\n<p>The <code>Mover</code> class also needs a function that determines what the object should do when it reaches the edge of the canvas. For now, I’ll do something simple and have it wrap around the edges:</p>\n<div class=\"snip-above\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  checkEdges() {\n    //{!11.allow-break} When it reaches one edge, set the position to the other edge.\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x &#x3C; 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y &#x3C; 0) {\n      this.position.y = height;\n    }\n  }\n}</pre>\n</div>\n<p>Now the <code>Mover</code> class is finished, but the class itself isn’t an object; it’s a template for creating an instance of an object. To actually create a <code>Mover</code> object, I first need to declare a variable to hold it:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let mover;</pre>\n<p>Then, inside the <code>setup()</code> function, I create the object by invoking the class name along with the <code>new</code> keyword. This triggers the class’s constructor to make an instance of the object:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">mover = new Mover();</pre>\n<p>Now all that remains is to call the appropriate methods in <code>draw()</code>:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">mover.update();\nmover.checkEdges();\nmover.show();</pre>\n<p>Here’s the entire example for reference.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-17-motion-101-velocity\">Example 1.7: Motion 101 (Velocity)</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/6foX0NUfS\" data-example-path=\"examples/01_vectors/example_1_7_motion_101_velocity\"><img src=\"/content/examples/01_vectors/example_1_7_motion_101_velocity/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// Declare the <code>Mover</code> object.\nlet mover;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create the <code>Mover</code> object.\n  mover = new Mover();\n}\n\nfunction draw() {\n  background(255);\n  // Call methods on the <code>Mover</code> object.\n  mover.update();\n  mover.checkEdges();\n  mover.show();\n}\n\nclass Mover {\n  constructor() {\n    // The object has two vectors: position and velocity.\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2, 2), random(-2, 2));\n  }\n\n  update() {\n    // Motion 101: position changes by velocity.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(127);\n    circle(this.position.x, this.position.y, 48);\n  }\n\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x &#x3C; 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y &#x3C; 0) {\n      this.position.y = height;\n    }\n  }\n}</pre>\n<p>If OOP is at all new to you, one aspect here may seem a bit strange. I spent the beginning of this chapter discussing the <code>p5.Vector</code> class, and this class is the template for making the <code>position</code> object and the <code>velocity</code> object. So what are those objects doing inside yet another object, the <code>Mover</code> object?</p>\n<p>In fact, this is just about the most normal thing ever. An object is something that holds data (and functionality). That data can be numbers, or it can be other objects (arrays too)! You’ll see this over and over again in this book. In Chapter 4, for example, I’ll write a class to describe a system of particles. That <code>ParticleSystem</code> object will include a list of <code>Particle</code> objects . . . and each <code>Particle</code> object will have as its data several <code>p5.Vector</code> objects!</p>\n<p>You may have also noticed in the <code>Mover</code> class that I’m setting the initial position and velocity directly within the constructor, without using any arguments. While this approach keeps the code simple for now, I’ll explore the benefits of adding arguments to the constructor in <a href=\"/forces#section-forces\">Chapter 2</a>.</p>\n<p>At this point, you hopefully feel comfortable with two concepts: (1) what a vector is and (2) how to use vectors inside an object to keep track of its position and movement. This is an excellent first step and deserves a mild round of applause. Before standing ovations are in order, however, you need to make one more, somewhat bigger step forward. After all, watching the Motion 101 example is fairly boring. The circle never speeds up, never slows down, and never turns. For more sophisticated motion—the kind of motion that appears in the world around us—one more vector needs to be added to the class: <code>acceleration</code>.</p>\n<h2 id=\"acceleration\">Acceleration</h2>\n<div data-type=\"video-link\" data-title=\"Acceleration Vector\" href=\"https://www.youtube.com/watch?time_continue=1&#x26;v=T84AWnntxZA&#x26;embeds_referring_origin=https://thecodingtrain.com\"></div>\n<p><strong>Acceleration</strong> is the<em> </em>rate of change of velocity. Think about that definition for a moment. Is it a new concept? Not really. Earlier I defined velocity as<em> </em>the rate of change of position, so in essence I’m developing a trickle-down effect. Acceleration affects velocity, which in turn affects position. (To provide some brief foreshadowing, this point will become even more crucial in the next chapter, when I show how forces like friction affect acceleration, which affects velocity, which affects position.) In code, this trickle-down effect reads like this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">velocity.add(acceleration);\nposition.add(velocity);</pre>\n<p>As an exercise, from this point forward, I’m going to make a rule for myself: I’ll try to write every example in the rest of this book without ever touching the values of velocity and position (except to initialize them). In other words, the goal for programming motion is to come up with an algorithm for calculating acceleration and then let the trickle-down effect work its magic. (In truth, there will be a multitude of reasons to break this rule, and break it I shall. Nevertheless, it’s a useful constraint to begin with to illustrate the principles behind the motion algorithm with acceleration.)</p>\n<p>The next step, then, is to come up with a way to calculate acceleration. Here are a few possible algorithms:</p>\n<ul>\n  <li>A constant acceleration</li>\n  <li>A random acceleration</li>\n  <li>An acceleration toward the mouse</li>\n</ul>\n<p>I’ll use the rest of this chapter to show you how to implement these algorithms.</p>\n<h3 id=\"algorithm-1-constant-acceleration\">Algorithm 1: Constant Acceleration</h3>\n<p>Acceleration Algorithm 1, a constant acceleration, isn’t particularly interesting, but it’s the simplest and thus an excellent starting point to incorporate acceleration into the code. The first step is to add another variable to the <code>Mover</code> class:</p>\n<div class=\"snip-below\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    // Initialize a stationary mover at the center of the canvas.\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // A new vector for acceleration\n    <strong>this.acceleration = createVector(0, 0);</strong>\n  }</pre>\n</div>\n<p></p>\n<p>Next, incorporate acceleration into the <code>update()</code> function:</p>\n<div class=\"snip-below snip-above\">\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    // The motion algorithm is now two lines of code!\n    <strong>this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);</strong>\n  }</pre>\n</div>\n<p>I’m almost finished. The only missing piece is to get that mover moving! In the constructor, the initial velocity is set to 0, rather than a random vector as previously done. Therefore, when the sketch starts, the object is at rest. To get it moving instead of changing the velocity directly, I’ll update it through the object’s acceleration. According to Algorithm 1, the acceleration should be constant, so I’ll choose a value now:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">    this.acceleration = createVector(-0.001, 0.01);</pre>\n<p>\n  This means that for every frame of the animation, the object’s velocity should increase by –0.001\n  pixels in the x-direction and 0.01 pixels in the y-direction. Maybe you’re thinking, “Gosh, those values seem awfully small!” Indeed, they are quite tiny, but that’s by design. Acceleration values accumulate over time in the velocity, about 30 times per second, depending on the sketch’s frame rate. To keep the magnitude of the velocity vector from growing too quickly and spiraling out of control, the acceleration values should remain quite small.\n</p>\n<p>I can also help keep the velocity within a reasonable range by incorporating the <code>p5.Vector</code> function <code>limit()</code>, which puts a cap on the magnitude of a vector:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">    // The <code>limit()</code> function constrains the magnitude of a vector.\n    this.velocity.limit(10);</pre>\n<p>This translates to the following:</p>\n<blockquote data-type=\"epigraph\">\n  <p><em>What is the magnitude of </em><em>velocity</em><em>? If it’s less than 10, no worries; just leave it as is. If it’s more than 10, however, reduce it to 10!</em></p>\n</blockquote>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-14\">Exercise 1.4</h3>\n  <p>Write the <code>limit()</code> function for the <code>p5.Vector</code> class:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">  limit(max) {\n    if (<span class=\"blank\">this.mag() > </span><span class=\"blank\">max</span>) {\n      <span class=\"blank\">this.normalize()</span>;\n      <span class=\"blank\">this.mult(max)</span>;\n    }\n  }</pre>\n</div>\n<p>Let’s take a look at the changes to the <code>Mover</code> class, complete with <code>acceleration</code> and <code>limit()</code>.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-18-motion-101-velocity-and-constant-acceleration\">Example 1.8: Motion 101 (Velocity and Constant Acceleration)</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/4GSialOpQw\" data-example-path=\"examples/01_vectors/example_1_8_motion_101_velocity_and_constant_acceleration\"><img src=\"/content/examples/01_vectors/example_1_8_motion_101_velocity_and_constant_acceleration/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">class Mover {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // Acceleration is the key!\n    this.acceleration = createVector(-0.001, 0.01);\n    // The variable <code>topSpeed</code> will limit the magnitude of velocity.\n    this.topSpeed = 10;\n  }\n\n  update() {\n    //{!2} Velocity changes by acceleration and is limited by <code>topSpeed</code>.\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }\n\n  // <code>show()</code> is the same.\n  show() {}\n\n  // <code>checkEdges()</code> is the same.\n  checkEdges() {}\n}</pre>\n<p>The net result is that the object falls down and to the left, gradually moving faster and faster until it reaches the maximum velocity.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-15\">Exercise 1.5</h3>\n  <p>Create a simulation of an object (think about a vehicle) that accelerates when you press the up arrow and brakes when you press the down arrow.</p>\n  <div class=\"web-only solution\">\n    <figure>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/WqxzIQW-w\" data-example-path=\"examples/01_vectors/exercise_1_5_solution_accelerate_and_decelerate\"><img src=\"/content/examples/01_vectors/exercise_1_5_solution_accelerate_and_decelerate/screenshot.png\"></div>\n      <figcaption></figcaption>\n    </figure>\n  </div>\n</div>\n<h3 id=\"algorithm-2-random-acceleration\">Algorithm 2: Random Acceleration</h3>\n<div data-type=\"video-link\" data-title=\"Random Vectors\" href=\"https://www.youtube.com/watch?v=jupjuq9Jl-M\"></div>\n<p>Now on to Acceleration Algorithm 2, a random acceleration. In this case, instead of initializing <code>acceleration</code> in the object’s constructor, I want to randomly set its value inside the <code>update()</code> method. This way, the object will get a different acceleration vector for every frame of the animation:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">update() {\n  // The <code>random2D()</code> method returns a unit vector pointing in a random direction.\n  this.acceleration = p5.Vector.random2D();\n  this.velocity.add(this.acceleration);\n  this.velocity.limit(this.topSpeed);\n  this.position.add(this.velocity);\n}</pre>\n<p>The <code>random2D()</code> method produces a normalized vector, meaning it has a random direction, but its magnitude is always 1. To make things interesting, I can try scaling the random vector by a constant value:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  this.acceleration = p5.Vector.random2D();\n  // Constant\n  <strong>this.acceleration.mult(0.5);</strong></pre>\n<p>Or, for even greater variety, I can scale the acceleration to a random value. In Example 1.9, the <code>acceleration</code> vector has both a random direction and a random magnitude from 0 to 2.</p>\n<div data-type=\"example\">\n  <h3 id=\"example-19-motion-101-velocity-and-random-acceleration\">Example 1.9: Motion 101 (Velocity and Random Acceleration)</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/w9DU8ccWMf\" data-example-path=\"examples/01_vectors/example_1_9_motion_101_velocity_and_random_acceleration\"><img src=\"/content/examples/01_vectors/example_1_9_motion_101_velocity_and_random_acceleration/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  this.acceleration = p5.Vector.random2D();\n  // Random\n  <strong>this.acceleration.mult(random(2));</strong></pre>\n<p>It’s crucial to understand that acceleration doesn’t merely refer to <em>speeding up</em> or <em>slowing down.</em> Rather, as this example has shown, it refers to <em>any change</em> in velocity—magnitude or direction. Acceleration is used to steer an object, and you’ll see this again and again in future chapters as I begin to code objects that make decisions about how to move.</p>\n<p>You might also notice that this example is another kind of random walker.<strong><em> </em></strong>A key distinction between what I’m doing here and the previous chapter’s examples, however, lies in <em>what</em> is being randomized. With the traditional random walker, I was directly manipulating the velocity, meaning each step was completely independent of the last. In Example 1.9, the acceleration (the rate of change of velocity) is being randomized, not the velocity itself. This makes the object’s motion dependent on its previous state: the velocity changes incrementally according to the random acceleration. The resulting movement of the object has a kind of continuity and fluidity that the original random walker lacked. The difference may seem subtle, but it fundamentally changes the way the object moves about the canvas.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-16\">Exercise 1.6</h3>\n  <p>Referring back to Example 0.6, implement an acceleration calculated with Perlin noise.</p>\n</div>\n<h3 id=\"static-vs-nonstatic-methods\">Static vs. Nonstatic Methods</h3>\n<div data-type=\"video-link\" data-title=\"Static Functions\" href=\"https://www.youtube.com/watch?v=YN8Q-QEmQ8Y&#x26;embeds_referring_euri=https://thecodingtrain.com/&#x26;embeds_referring_origin=https://thecodingtrain.com&#x26;source_ve_path=OTY3MTQ&#x26;feature=emb_imp_woyt\"></div>\n<p>You might have noticed something a bit odd and unfamiliar in the previous example. The<br><code>random2D()</code> method used to create a random unit vector was called on the class name, as in <code>p5.Vector.random2D()</code>, rather than on the current instance of the class, as in <code>this.random2D()</code>.<br>This is because <code>random2D()</code> is a <strong>static method</strong>, meaning it’s associated with the class as a whole rather than the individual objects (that is, the instances of that class).</p>\n<p>Static methods are rarely needed when you’re writing your own classes (like <code>Walker</code> or <code>Mover</code>), so you may not have encountered them before. They sometimes form an important part of prewritten classes like <code>p5.Vector</code>, however. In fact, Acceleration Algorithm 3 (accelerate toward the mouse) requires further use of this concept, so let’s take a step back and consider the difference between static and nonstatic methods.</p>\n<p>Setting aside vectors for a second, take a look at the following code:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x = 0;\nlet y = 5;\nx = x + y;</pre>\n<p>This is probably what you’re used to, yes? I give <code>x</code> a value of 0, add <code>y</code> to it, and now <code>x</code> is equal to 5. I could write similar code for adding two vectors:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let v = createVector(0, 0);\nlet u = createVector(4, 5);\nv.add(u);</pre>\n<p>The vector <code>v</code> has the value of (0, 0), I add the vector <code>u</code> to it, and now <code>v</code> is equal to (4, 5). Makes sense, right?</p>\n<p>Now consider this example:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let x = 0;\nlet y = 5;\nlet z = x + y;</pre>\n<p>I give <code>x</code> a value of 0, add <code>y</code> to it, and store the result in a new variable <code>z</code>. The value of <code>x</code> doesn’t change here (neither does <code>y</code>)! This may seem like a trivial point, and one that’s quite intuitive when it comes to mathematical operations with simple numbers. However, it’s not so obvious with mathematical operations using <code>p5.Vector</code> objects. Let’s try to rewrite the example with vectors, based on what I’ve covered of the <code>p5.Vector</code> class so far:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let v = createVector(0, 0);\nlet u = createVector(4, 5);\n// Don’t be fooled; this is incorrect!\nlet w = v.add(u);</pre>\n<p>This might seem like a good guess, but it’s just not the way the <code>p5.Vector</code> class works. If you look at the definition of <code>add()</code>, you can see why:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">add(v) {\n  this.x = this.x + v.x;\n  this.y = this.y + v.y;\n}</pre>\n<p>This code has two problems. First, the <code>add()</code> method doesn’t return a new <code>p5.Vector</code> object, and second, <code>add()</code> changes the value of the vector upon which it’s called. To add two vector objects together and return the result as a new vector, I must use the static version of the <code>add()</code> method by calling it on the class name, rather than calling the nonstatic version on a specific object instance.</p>\n<p>Here’s how I might write the static version of <code>add()</code> if I were declaring the class myself:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">// The static version adds two vectors together and assigns the result to a new vector while leaving the original vectors (<code>v</code> and <code>u</code> in the preceding code blocks) intact.\nstatic add(v1, v2) {\n  let v3 = createVector(v1.x + v2.x, v1.y + v2.y);\n  return v3;\n}</pre>\n<p>The key difference here is that the method returns a new vector (<code>v3</code>) created using the sum of the components of <code>v1</code> and <code>v2</code>. As a result, the method doesn’t make changes to either original vector.</p>\n<p>When calling a static method, instead of referencing an object instance, you reference the name of the class. Here’s the right way to implement the vector addition example:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let v = createVector(0, 0);\nlet u = createVector(4, 5);\n<s>let w = v.add(u);</s>\n<strong>let w = p5.Vector.add(v, u);</strong></pre>\n<p>The <code>p5.Vector</code> class has static versions of <code>add()</code>, <code>sub()</code>, <code>mult()</code>, and <code>div()</code>. These static methods allow you to perform generic mathematical operations on vectors without changing the value of one of the input vectors in the process.</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-17\">Exercise 1.7</h3>\n  <p>Translate the following pseudocode to code, using static or nonstatic functions where appropriate:</p>\n  <ul>\n    <li>The vector <code>v</code> equals (1, 5).</li>\n    <li>The vector <code>u</code> equals <code>v</code> multiplied by 2.</li>\n    <li>The vector <code>w</code> equals <code>v</code> minus <code>u</code>.</li>\n    <li>Divide the vector <code>w</code> by 3.</li>\n  </ul>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">let v = <span class=\"blank\">createVector(1, 5)</span>;\nlet u = <span class=\"blank\">p5.Vector.mult</span>(<span class=\"blank\">v, 2</span>);\nlet w = <span class=\"blank\">p5.Vector.sub</span>(<span class=\"blank\">v, u</span>);\n<span class=\"blank\">w.div(3)</span>;</pre>\n</div>\n<h3 id=\"algorithm-3-interactive-motion\">Algorithm 3: Interactive Motion</h3>\n<p>To finish out this chapter, let’s try something a bit more complex and a great deal more useful. I’ll dynamically calculate an object’s acceleration according to the rule stated in Acceleration Algorithm 3: the object accelerates toward the mouse.</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_16.png\" alt=\"Figure 1.15: A vector from an object to the mouse position\">\n    <figcaption>Figure 1.15: A vector from an object to the mouse position</figcaption>\n  </figure>\n</div>\n<p>Anytime you want to calculate a vector based on a rule or formula, you need to compute two attributes: magnitude and direction. I’ll start with direction. I know the acceleration vector should point from the object’s position toward the mouse position (Figure 1.15). Let’s say the object is located at the position vector (<em>x</em>, <em>y</em>), and the mouse is at (<em>mouseX</em>, <em>mouseY</em>).</p>\n<div class=\"half-width-right\">\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_17.png\" alt=\"Figure 1.16: Calculating an initial acceleration vector by taking the difference of the mouse and position vectors\">\n    <figcaption>Figure 1.16: Calculating an initial acceleration vector by taking the difference of the mouse and position vectors</figcaption>\n  </figure>\n</div>\n<p>In Figure 1.16, you see that the acceleration vector (<em>dx</em>, <em>dy</em>) can be calculated by subtracting the object’s position from the mouse’s position:</p>\n<ul>\n  <li><span data-type=\"equation\">dx = mouseX - x</span></li>\n  <li><span data-type=\"equation\">dy = mouseY - y</span></li>\n</ul>\n<p>Let’s implement that by using <code>p5.Vector</code> syntax. Assuming the code will live inside the <code>Mover</code> class and thus have access to the object’s <code>position</code>, I can write this:</p>\n<pre class=\"codesplit\" data-code-language=\"javascript\">let mouse = createVector(mouseX, mouseY);\n// Look! I’m using the static reference to <code>sub()</code> because I want a new <code>p5.Vector</code>!\nlet direction = p5.Vector.sub(mouse, this.position);</pre>\n<p>I’ve used the static version of <code>sub()</code> to create a new vector <code>direction</code> that points from the mover’s position to the mouse. If the object were to actually accelerate using that vector, however, it would appear instantaneously at the mouse position, since the magnitude of <code>direction</code> is equal to the distance between the object and the mouse. This wouldn’t make for a smooth animation, of course. The next step, therefore, is to decide how quickly the object should accelerate toward the mouse by changing the vector’s magnitude.</p>\n<p>To set the magnitude (whatever it may be) of the acceleration vector, I must first ______ the vector. That’s right, you said it: <em>normalize</em>! If I can shrink the vector to its unit vector (of length 1), I can easily scale it to any other value, because 1 multiplied by anything equals anything:</p>\n<div data-type=\"video-link\" data-title=\"A Unit Vector\" href=\"https://thecodingtrain.com/tracks/the-nature-of-code-2/noc/1-vectors/5-unit-vector\"></div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">//{!1} Any number!\nlet anything = __________________;\ndirection.normalize();\ndirection.mult(anything);</pre>\n<p>To summarize, follow these steps to make the object accelerate toward the mouse:</p>\n<ol>\n  <li>Calculate a vector that points from the object to the target position (mouse).</li>\n  <li>Normalize that vector (reducing its length to 1).</li>\n  <li>Scale that vector to an appropriate value (by multiplying it by a value).</li>\n  <li>Assign that vector to acceleration.</li>\n</ol>\n<div class=\"avoid-break\">\n  <p>I have a confession to make. Normalization and then scaling is such a common vector operation that <code>p5.Vector</code> includes a function that does both, setting the magnitude of a vector to a given value with a single function call. That function is <code>setMag()</code>:</p>\n  <pre class=\"codesplit\" data-code-language=\"javascript\">let anything = ?????\ndir.setMag(anything);</pre>\n</div>\n<p>In this next example, to emphasize the math, I’m going to write the code using <code>normalize()</code> and <code>mult()</code>, but this is likely the last time I’ll do that. You’ll find <code>setMag()</code> in examples going forward.</p>\n<div data-type=\"video-link\" data-title=\"Acceleration Vector\" href=\"https://thecodingtrain.com/tracks/the-nature-of-code-2/noc/1-vectors/6-acceleration-vector\"></div>\n<div data-type=\"example\">\n  <h3 id=\"example-110-accelerating-toward-the-mouse\">Example 1.10: Accelerating Toward the Mouse</h3>\n  <figure>\n    <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/gYJHm1EFL\" data-example-path=\"examples/01_vectors/example_1_10_accelerating_towards_the_mouse\"><img src=\"/content/examples/01_vectors/example_1_10_accelerating_towards_the_mouse/screenshot.png\"></div>\n    <figcaption></figcaption>\n  </figure>\n</div>\n<pre class=\"codesplit\" data-code-language=\"javascript\">  update() {\n    let mouse = createVector(mouseX, mouseY);\n    // Step 1: Compute the direction.\n    let dir = p5.Vector.sub(mouse, this.position);\n    // Step 2: Normalize.\n    dir.normalize();\n    // Step 3: Scale.\n    dir.mult(0.2);\n    //{!1} Step 4: Accelerate.\n    this.acceleration = dir;\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }</pre>\n<p>You may be wondering why the circle doesn’t stop when it reaches the target. It’s important to note that the moving object has no knowledge about trying to stop at a destination; it knows only the destination’s position. The object tries to accelerate there at a fixed rate, regardless of how far away it is. This means it will inevitably overshoot the target and have to turn around, again accelerating toward the destination, overshooting it again, and so forth. Stay tuned; in later chapters, I’ll show you how to program an object to <strong>arrive</strong> at a target (slow down on approach).</p>\n<div data-type=\"exercise\">\n  <h3 id=\"exercise-18\">Exercise 1.8</h3>\n  <p>Example 1.10 is remarkably close to the concept of gravitational attraction, with the object being attracted to the mouse position. In the example, however, the attraction magnitude is constant, whereas with a real-life gravitational force, the magnitude is inversely proportional to distance: the closer the object is to the attraction point, the faster it accelerates. I’ll cover gravitational attraction in more detail in the next chapter, but for now, try implementing your own version of Example 1.10 with a variable magnitude of acceleration, stronger when it’s either closer or farther away.</p>\n  <div class=\"web-only solution\">\n    <figure>\n      <div data-type=\"embed\" data-p5-editor=\"https://editor.p5js.org/natureofcode/sketches/ZVr3kjeSI\" data-example-path=\"examples/01_vectors/exercise_1_8_solution_attraction_magnitude\"><img src=\"/content/examples/01_vectors/exercise_1_8_solution_attraction_magnitude/screenshot.png\"></div>\n      <figcaption></figcaption>\n    </figure>\n  </div>\n</div>\n<div data-type=\"project\">\n  <h3 id=\"the-ecosystem-project-2\">The Ecosystem Project</h3>\n  <p>Incorporate vectors to further develop and refine the motion of the elements within your ecosystem. Explore how motion can be directed by solely manipulating an object’s acceleration vector.</p>\n  <p>How might you calculate acceleration to emulate certain behaviors—the erratic buzzing<br>of a nervous fly, the gentle hops of a bunny, or the slithering of a snake? What role does acceleration play in nature? Consider the way a bird accelerates when taking off or how a fish suddenly changes direction when swimming. Again, how much of a creature’s personality can be shaped by its behavior alone? What is added (or taken away) by incorporating more visual design elements beyond simple shapes?</p>\n  <figure>\n    <img src=\"/content/images/01_vectors/01_vectors_18.png\" alt>\n    <figcaption></figcaption>\n  </figure>\n</div>\n</section>",
  "codeBlocks": [
    {
      "id": "code-0",
      "language": "javascript",
      "code": "// Variables for position and speed of ball\nlet x = 100;\nlet y = 100;\nlet xspeed = 2.5;\nlet yspeed = 2;\n\nfunction setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  // Move the ball according to its speed.\n  x = x + xspeed;\n  y = y + yspeed;\n  // Check for bouncing.\n  if (x > width || x < 0) {\n    xspeed = xspeed * -1;\n  }\n  if (y > height || y < 0) {\n    yspeed = yspeed * -1;\n  }\n  // Draw the ball at the position (<em>x</em>, <em>y</em>).\n  stroke(0);\n  fill(127);\n  circle(x, y, 48);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-1",
      "language": "javascript",
      "code": "let x;\nlet y;\nlet xspeed;\nlet yspeed;",
      "lineNumbers": false
    },
    {
      "id": "code-2",
      "language": "javascript",
      "code": "let position;\nlet speed;",
      "lineNumbers": false
    },
    {
      "id": "code-3",
      "language": "javascript",
      "code": "class Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-4",
      "language": "javascript",
      "code": "let x = 100;\nlet y = 100;\nlet xspeed = 1;\nlet yspeed = 3.3;",
      "lineNumbers": false
    },
    {
      "id": "code-5",
      "language": "javascript",
      "code": "let position = createVector(100, 100);\nlet velocity = createVector(1, 3.3);",
      "lineNumbers": false
    },
    {
      "id": "code-6",
      "language": "javascript",
      "code": "// Add each speed to each position.\nx = x + xspeed;\ny = y + yspeed;",
      "lineNumbers": false
    },
    {
      "id": "code-7",
      "language": "javascript",
      "code": "// Add the velocity vector to the position vector.\nposition = position + velocity;",
      "lineNumbers": false
    },
    {
      "id": "code-8",
      "language": "javascript",
      "code": "class Vector {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  //{!4} New! A function to add another vector to this vector. Add the x-components and the y-components separately.\n  <strong>add(v) {\n    this.x = this.x + v.x;\n    this.y = this.y + v.y;\n  }</strong>\n}",
      "lineNumbers": true
    },
    {
      "id": "code-9",
      "language": "javascript",
      "code": "// This does not work!\n<s>position = position + velocity;</s>\n// Add the velocity to the position.\nposition.add(velocity);",
      "lineNumbers": false
    },
    {
      "id": "code-10",
      "language": "javascript",
      "code": "// Instead of a bunch of floats, you now have just two variables.\n<strong>let position;\nlet velocity;</strong>\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Note that <code>createVector()</code> has to be called inside <code>setup()</code>.\n  <strong>position = createVector(100, 100);\n  velocity = createVector(2.5, 2);</strong>\n}\n\nfunction draw() {\n  background(255);\n  <strong>position.add(velocity);</strong>\n\n  // You still sometimes need to refer to the individual components of a <code>p5.Vector</code> and can do so using the dot syntax: <code>position.x</code>, <code>velocity.y</code>, and so forth.\n  <strong>if (position.x > width || position.x < 0) {\n    velocity.x = velocity.x * -1;\n  }\n  if (position.y > height || position.y < 0) {\n    velocity.y = velocity.y * -1;\n  }</strong>\n\n  stroke(0);\n  fill(127);\n  circle(position.x, position.y, 48);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-11",
      "language": "javascript",
      "code": "<s>circle(position, 48);</s>\ncircle(position.x, position.y, 48);",
      "lineNumbers": false
    },
    {
      "id": "code-12",
      "language": "javascript",
      "code": "if ((position.x > width) || (position.x < 0)) {\n  velocity.x = velocity.x * -1;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-13",
      "language": "javascript",
      "code": "sub(v) {\n  this.x = this.x - v.x;\n  this.y = this.y - v.y;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-14",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n  // Two vectors, one for the mouse location and one for the center of the window\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  // Draw the original two vectors.\n  stroke(200);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n  line(0, 0, center.x, center.y);\n  // Vector subtraction!\n  mouse.sub(center);\n  // Draw a line to represent the result of subtraction.\n  // Notice that I move the origin with <code>translate()</code> to place the vector.\n  stroke(0);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-15",
      "language": "javascript",
      "code": "mult(n) {\n  // The components of the vector are multiplied by a number.\n  this.x = this.x * n;\n  this.y = this.y * n;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-16",
      "language": "javascript",
      "code": "let u = createVector(-3, 7);\n// This <code>p5.Vector</code> is now three times the size and is equal to (–9, 21). See Figure 1.9.\nu.mult(3);",
      "lineNumbers": false
    },
    {
      "id": "code-17",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  strokeWeight(2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!1} Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).\n  mouse.mult(0.5);\n  stroke(0);\n  strokeWeight(4);\n  line(0, 0, mouse.x, mouse.y);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-18",
      "language": "javascript",
      "code": "div(n) {\n  this.x = this.x / n;\n  this.y = this.y / n;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-19",
      "language": "javascript",
      "code": "let u = createVector(8, -4);\n// Dividing a vector!  The vector is now half its original size (divided by 2).\nu.div(2);",
      "lineNumbers": false
    },
    {
      "id": "code-20",
      "language": "javascript",
      "code": "mag() {\n  return sqrt(this.x * this.x + this.y * this.y);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-21",
      "language": "javascript",
      "code": "function setup() {\n  createCanvas(640, 240);\n}\n\nfunction draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n  //{!3} The magnitude (that is, length) of a vector can be accessed via the <code>mag()</code> method.  Here it is used as the width of a rectangle drawn at the top of the window.\n  let m = mouse.mag();\n  fill(0);\n  rect(0, 0, m, 10);\n  translate(width / 2, height / 2);\n  line(0, 0, mouse.x, mouse.y);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-22",
      "language": "javascript",
      "code": "normalize() {\n  let m = this.mag();\n  this.div(m);\n}",
      "lineNumbers": false
    },
    {
      "id": "code-23",
      "language": "javascript",
      "code": "normalize() {\n  let m = this.mag();\n  if (m > 0) {\n    this.div(m);\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-24",
      "language": "javascript",
      "code": "function draw() {\n  background(255);\n\n  let mouse = createVector(mouseX, mouseY);\n  let center = createVector(width / 2, height / 2);\n  mouse.sub(center);\n\n  translate(width / 2, height / 2);\n  stroke(200);\n  line(0, 0, mouse.x, mouse.y);\n  //{!2} In this example, after the vector is normalized, it’s multiplied by 50. Note that no matter where the mouse is, the vector always has the same length (50) because of the normalization process.\n  mouse.normalize();\n  mouse.mult(50);\n  stroke(0);\n  strokeWeight(8);\n  line(0, 0, mouse.x, mouse.y);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-25",
      "language": "javascript",
      "code": "position.add(velocity);",
      "lineNumbers": false
    },
    {
      "id": "code-26",
      "language": "javascript",
      "code": "circle(position.x, position.y, 48);",
      "lineNumbers": false
    },
    {
      "id": "code-27",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2,2), random(-2, 2));\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-28",
      "language": "javascript",
      "code": "update() {\n    // The mover moves.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    fill(175);\n    // The mover is drawn as a circle.\n    circle(this.position.x, this.position.y, 48);\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-29",
      "language": "javascript",
      "code": "checkEdges() {\n    //{!11.allow-break} When it reaches one edge, set the position to the other edge.\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x < 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y < 0) {\n      this.position.y = height;\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-30",
      "language": "javascript",
      "code": "let mover;",
      "lineNumbers": false
    },
    {
      "id": "code-31",
      "language": "javascript",
      "code": "mover = new Mover();",
      "lineNumbers": false
    },
    {
      "id": "code-32",
      "language": "javascript",
      "code": "mover.update();\nmover.checkEdges();\nmover.show();",
      "lineNumbers": false
    },
    {
      "id": "code-33",
      "language": "javascript",
      "code": "// Declare the <code>Mover</code> object.\nlet mover;\n\nfunction setup() {\n  createCanvas(640, 240);\n  // Create the <code>Mover</code> object.\n  mover = new Mover();\n}\n\nfunction draw() {\n  background(255);\n  // Call methods on the <code>Mover</code> object.\n  mover.update();\n  mover.checkEdges();\n  mover.show();\n}\n\nclass Mover {\n  constructor() {\n    // The object has two vectors: position and velocity.\n    this.position = createVector(random(width), random(height));\n    this.velocity = createVector(random(-2, 2), random(-2, 2));\n  }\n\n  update() {\n    // Motion 101: position changes by velocity.\n    this.position.add(this.velocity);\n  }\n\n  show() {\n    stroke(0);\n    strokeWeight(2);\n    fill(127);\n    circle(this.position.x, this.position.y, 48);\n  }\n\n  checkEdges() {\n    if (this.position.x > width) {\n      this.position.x = 0;\n    } else if (this.position.x < 0) {\n      this.position.x = width;\n    }\n\n    if (this.position.y > height) {\n      this.position.y = 0;\n    } else if (this.position.y < 0) {\n      this.position.y = height;\n    }\n  }\n}",
      "lineNumbers": true
    },
    {
      "id": "code-34",
      "language": "javascript",
      "code": "velocity.add(acceleration);\nposition.add(velocity);",
      "lineNumbers": false
    },
    {
      "id": "code-35",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    // Initialize a stationary mover at the center of the canvas.\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // A new vector for acceleration\n    <strong>this.acceleration = createVector(0, 0);</strong>\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-36",
      "language": "javascript",
      "code": "update() {\n    // The motion algorithm is now two lines of code!\n    <strong>this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);</strong>\n  }",
      "lineNumbers": false
    },
    {
      "id": "code-37",
      "language": "javascript",
      "code": "this.acceleration = createVector(-0.001, 0.01);",
      "lineNumbers": false
    },
    {
      "id": "code-38",
      "language": "javascript",
      "code": "// The <code>limit()</code> function constrains the magnitude of a vector.\n    this.velocity.limit(10);",
      "lineNumbers": false
    },
    {
      "id": "code-39",
      "language": "javascript",
      "code": "limit(max) {\n    if (<span class=\"blank\">this.mag() > </span><span class=\"blank\">max</span>) {\n      <span class=\"blank\">this.normalize()</span>;\n      <span class=\"blank\">this.mult(max)</span>;\n    }\n  }",
      "lineNumbers": true
    },
    {
      "id": "code-40",
      "language": "javascript",
      "code": "class Mover {\n  constructor() {\n    this.position = createVector(width / 2, height / 2);\n    this.velocity = createVector(0, 0);\n    // Acceleration is the key!\n    this.acceleration = createVector(-0.001, 0.01);\n    // The variable <code>topSpeed</code> will limit the magnitude of velocity.\n    this.topSpeed = 10;\n  }\n\n  update() {\n    //{!2} Velocity changes by acceleration and is limited by <code>topSpeed</code>.\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }\n\n  // <code>show()</code> is the same.\n  show() {}\n\n  // <code>checkEdges()</code> is the same.\n  checkEdges() {}\n}",
      "lineNumbers": true
    },
    {
      "id": "code-41",
      "language": "javascript",
      "code": "update() {\n  // The <code>random2D()</code> method returns a unit vector pointing in a random direction.\n  this.acceleration = p5.Vector.random2D();\n  this.velocity.add(this.acceleration);\n  this.velocity.limit(this.topSpeed);\n  this.position.add(this.velocity);\n}",
      "lineNumbers": true
    },
    {
      "id": "code-42",
      "language": "javascript",
      "code": "this.acceleration = p5.Vector.random2D();\n  // Constant\n  <strong>this.acceleration.mult(0.5);</strong>",
      "lineNumbers": false
    },
    {
      "id": "code-43",
      "language": "javascript",
      "code": "this.acceleration = p5.Vector.random2D();\n  // Random\n  <strong>this.acceleration.mult(random(2));</strong>",
      "lineNumbers": false
    },
    {
      "id": "code-44",
      "language": "javascript",
      "code": "let x = 0;\nlet y = 5;\nx = x + y;",
      "lineNumbers": false
    },
    {
      "id": "code-45",
      "language": "javascript",
      "code": "let v = createVector(0, 0);\nlet u = createVector(4, 5);\nv.add(u);",
      "lineNumbers": false
    },
    {
      "id": "code-46",
      "language": "javascript",
      "code": "let x = 0;\nlet y = 5;\nlet z = x + y;",
      "lineNumbers": false
    },
    {
      "id": "code-47",
      "language": "javascript",
      "code": "let v = createVector(0, 0);\nlet u = createVector(4, 5);\n// Don’t be fooled; this is incorrect!\nlet w = v.add(u);",
      "lineNumbers": false
    },
    {
      "id": "code-48",
      "language": "javascript",
      "code": "add(v) {\n  this.x = this.x + v.x;\n  this.y = this.y + v.y;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-49",
      "language": "javascript",
      "code": "// The static version adds two vectors together and assigns the result to a new vector while leaving the original vectors (<code>v</code> and <code>u</code> in the preceding code blocks) intact.\nstatic add(v1, v2) {\n  let v3 = createVector(v1.x + v2.x, v1.y + v2.y);\n  return v3;\n}",
      "lineNumbers": false
    },
    {
      "id": "code-50",
      "language": "javascript",
      "code": "let v = createVector(0, 0);\nlet u = createVector(4, 5);\n<s>let w = v.add(u);</s>\n<strong>let w = p5.Vector.add(v, u);</strong>",
      "lineNumbers": false
    },
    {
      "id": "code-51",
      "language": "javascript",
      "code": "let v = <span class=\"blank\">createVector(1, 5)</span>;\nlet u = <span class=\"blank\">p5.Vector.mult</span>(<span class=\"blank\">v, 2</span>);\nlet w = <span class=\"blank\">p5.Vector.sub</span>(<span class=\"blank\">v, u</span>);\n<span class=\"blank\">w.div(3)</span>;",
      "lineNumbers": false
    },
    {
      "id": "code-52",
      "language": "javascript",
      "code": "let mouse = createVector(mouseX, mouseY);\n// Look! I’m using the static reference to <code>sub()</code> because I want a new <code>p5.Vector</code>!\nlet direction = p5.Vector.sub(mouse, this.position);",
      "lineNumbers": false
    },
    {
      "id": "code-53",
      "language": "javascript",
      "code": "//{!1} Any number!\nlet anything = __________________;\ndirection.normalize();\ndirection.mult(anything);",
      "lineNumbers": false
    },
    {
      "id": "code-54",
      "language": "javascript",
      "code": "let anything = ?????\ndir.setMag(anything);",
      "lineNumbers": false
    },
    {
      "id": "code-55",
      "language": "javascript",
      "code": "update() {\n    let mouse = createVector(mouseX, mouseY);\n    // Step 1: Compute the direction.\n    let dir = p5.Vector.sub(mouse, this.position);\n    // Step 2: Normalize.\n    dir.normalize();\n    // Step 3: Scale.\n    dir.mult(0.2);\n    //{!1} Step 4: Accelerate.\n    this.acceleration = dir;\n    this.velocity.add(this.acceleration);\n    this.velocity.limit(this.topSpeed);\n    this.position.add(this.velocity);\n  }",
      "lineNumbers": true
    }
  ],
  "images": [
    "images/01_vectors/01_vectors_1.jpg",
    "images/01_vectors/01_vectors_2.png",
    "examples/01_vectors/example_1_1_bouncing_ball_with_no_vectors/screenshot.png",
    "images/01_vectors/01_vectors_3.png",
    "images/01_vectors/01_vectors_4.png",
    "images/01_vectors/01_vectors_5.png",
    "images/01_vectors/01_vectors_6.png",
    "images/01_vectors/01_vectors_7.png",
    "examples/01_vectors/example_1_2_bouncing_ball_with_vectors/screenshot.png",
    "examples/01_vectors/exercise_1_3_solution_3_d_bouncing_ball/screenshot.png",
    "images/01_vectors/01_vectors_8.png",
    "images/01_vectors/01_vectors_9.png",
    "examples/01_vectors/example_1_3_vector_subtraction/screenshot.png",
    "images/01_vectors/01_vectors_10.png",
    "examples/01_vectors/example_1_4_vector_multiplication/screenshot.png",
    "images/01_vectors/01_vectors_11.png",
    "images/01_vectors/01_vectors_12.png",
    "images/01_vectors/01_vectors_13.png",
    "examples/01_vectors/example_1_5_vector_magnitude/screenshot.png",
    "images/01_vectors/01_vectors_14.png",
    "images/01_vectors/01_vectors_15.png",
    "examples/01_vectors/example_1_6_vector_normalize/screenshot.png",
    "examples/01_vectors/example_1_7_motion_101_velocity/screenshot.png",
    "examples/01_vectors/example_1_8_motion_101_velocity_and_constant_acceleration/screenshot.png",
    "examples/01_vectors/exercise_1_5_solution_accelerate_and_decelerate/screenshot.png",
    "examples/01_vectors/example_1_9_motion_101_velocity_and_random_acceleration/screenshot.png",
    "images/01_vectors/01_vectors_16.png",
    "images/01_vectors/01_vectors_17.png",
    "examples/01_vectors/example_1_10_accelerating_towards_the_mouse/screenshot.png",
    "examples/01_vectors/exercise_1_8_solution_attraction_magnitude/screenshot.png",
    "images/01_vectors/01_vectors_18.png"
  ]
}